// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://my.sevdesk.de/api/v1' | 'http://sevdesk.local/api/v1' | (string & {});
};

/**
 * CheckAccount model
 *
 * CheckAccount model. Responsible for the payment accounts.
 */
export type ModelCheckAccountResponse = {
    /**
     * The check account id
     */
    readonly id?: string;
    /**
     * The check account object name
     */
    readonly objectName?: string;
    /**
     * Date of check account creation
     */
    readonly create?: string;
    /**
     * Date of last check account update
     */
    readonly update?: string;
    /**
     * Client to which check account belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Name of the check account
     */
    name?: string;
    /**
     * The IBAN of the account
     */
    iban?: string | null;
    /**
     * The type of the check account. Account with a CSV or MT940 import are regarded as online.
     */
    type?: 'online' | 'offline' | 'register';
    /**
     * Import type, for accounts that are type "online" but not connected to a data provider.
     */
    importType?: 'CSV' | 'MT940' | null;
    /**
     * The currency of the check account.
     */
    currency?: string;
    /**
     * Defines if this check account is the default account.
     */
    defaultAccount?: string;
    /**
     * This will be 1 if the account is your base account that comes with every sevdesk setup.
     */
    baseAccount?: string;
    /**
     * Defines the sorting of accounts, highest is first.
     */
    priority?: string;
    /**
     * Status of the check account. 0 <-> Archived - 100 <-> Active
     */
    status?: '0' | '100';
    /**
     * The account balance as reported by PayPal or finAPI. Not set for other types of accounts.
     */
    balance?: string | null;
    /**
     * Bank server of check account, only set if the account is connected to a data provider
     */
    bankServer?: string | null;
    /**
     * Defines if transactions on this account are automatically mapped to invoice and vouchers when imported if possible.
     */
    autoMapTransactions?: string | null;
    /**
     * If this is 1 the account will be automatically updated through PayPal or finAPI. Only applicable for connected online accounts.
     */
    autoSyncTransactions?: string;
    /**
     * Timepoint of the last payment import through PayPal or finAPI.
     */
    lastSync?: string;
    /**
     * The booking account used for this account, e.g. 1800 in SKR04 and 1200 in SKR03. Must be unique among all your CheckAccounts.
     */
    accountingNumber?: string;
};

/**
 * Data to create a file import account
 */
export type CreateFileImportAccount = {
    /**
     * Name of the check account
     */
    name?: string;
    /**
     * Import type. Transactions can be imported by this method on the check account.
     */
    importType?: 'CSV' | 'MT940';
    /**
     * The booking account used for this bank account, e.g. 1800 in SKR04 and 1200 in SKR03. Must be unique among all your CheckAccounts. Ignore to use a sensible default.
     */
    accountingNumber?: number | null;
    /**
     * IBAN of the bank account, without spaces
     */
    iban?: string | null;
};

/**
 * CheckAccount model
 *
 * CheckAccount model. Showing the properties relevant to file import accounts.
 */
export type CreateFileImportAccountResponse = {
    /**
     * The check account id
     */
    id?: string;
    /**
     * The check account object name, always 'CheckAccount'
     */
    objectName?: string;
    /**
     * Date of check account creation
     */
    create?: string;
    /**
     * Date of last check account update
     */
    update?: string;
    /**
     * Client to which check account belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Name of the check account
     */
    name?: string;
    /**
     * The IBAN of the account
     */
    iban?: string | null;
    /**
     * The type of the check account. Account with a CSV or MT940 import are regarded as online.
     */
    type?: 'online' | 'offline';
    /**
     * Import type, for accounts that are type "online" but not connected to a data provider. Transactions can be imported by this method on the check account.
     */
    importType?: 'CSV' | 'MT940';
    /**
     * The currency of the check account.
     */
    currency?: string;
    /**
     * Defines if this check account is the default account.
     */
    defaultAccount?: '0' | '1';
    /**
     * Status of the check account. 0 <-> Archived - 100 <-> Active
     */
    status?: '0' | '100';
    /**
     * Defines if transactions on this account are automatically mapped to invoice and vouchers when imported if possible.
     */
    autoMapTransactions?: '0' | '1';
    /**
     * The booking account used for this bank account, e.g. 1800 in SKR04 and 1200 in SKR03. Must be unique among all your CheckAccounts. Ignore to use a sensible default.
     */
    accountingNumber?: string;
};

/**
 * Data to create a clearing account
 */
export type CreateClearingAccount = {
    /**
     * Name of the check account
     */
    name?: string;
    /**
     * The booking account used for this clearing account, e.g. 3320 in SKR04 and 1723 in SKR03. Must be unique among all your CheckAccounts. Ask your tax consultant what to choose.
     */
    accountingNumber?: number | null;
};

/**
 * CheckAccount model
 *
 * CheckAccount model. Showing the properties relevant to clearing accounts.
 */
export type CreateClearingAccountResponse = {
    /**
     * The check account id
     */
    id?: string;
    /**
     * The check account object name, always 'CheckAccount'
     */
    objectName?: string;
    /**
     * Date of check account creation
     */
    create?: string;
    /**
     * Date of last check account update
     */
    update?: string;
    /**
     * Client to which check account belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Name of the check account
     */
    name?: string;
    /**
     * The type of the check account. Clearing accounts are regarded as offline.
     */
    type?: 'online' | 'offline';
    /**
     * The currency of the check account.
     */
    currency?: string;
    /**
     * Defines if this check account is the default account.
     */
    defaultAccount?: '0' | '1';
    /**
     * Status of the check account. 0 <-> Archived - 100 <-> Active
     */
    status?: '0' | '100';
    /**
     * The booking account used for this clearing account.
     */
    accountingNumber?: string;
};

/**
 * CheckAccount model
 *
 * CheckAccount model. Responsible for the payment accounts.
 */
export type ModelCheckAccountUpdate = {
    /**
     * Name of the check account
     */
    name?: string;
    /**
     * The type of the check account. Account with a CSV or MT940 import are regarded as online.<br>
     * Apart from that, created check accounts over the API need to be offline, as online accounts with an active connection
     * to a bank application can not be managed over the API.
     */
    type?: 'online' | 'offline';
    /**
     * Import type. Transactions can be imported by this method on the check account.
     */
    importType?: 'CSV' | 'MT940' | null;
    /**
     * The currency of the check account.
     */
    currency?: string;
    /**
     * Defines if this check account is the default account.
     */
    defaultAccount?: 0 | 1;
    /**
     * Status of the check account. 0 <-> Archived - 100 <-> Active
     */
    status?: 0 | 100;
    /**
     * Defines if transactions on this account are automatically mapped to invoice and vouchers when imported if possible.
     */
    autoMapTransactions?: number | null;
    /**
     * The booking account used for this bank account, e.g. 1800 in SKR04 and 1200 in SKR03. Must be unique among all your CheckAccounts. Ignore to use a sensible default.
     */
    accountingNumber?: string;
};

/**
 * CheckAccountTransaction model
 *
 * CheckAccountTransaction model. Responsible for the transactions on payment accounts.
 */
export type ModelCheckAccountTransactionResponse = {
    /**
     * The check account transaction id
     */
    readonly id?: string;
    /**
     * The check account transaction object name
     */
    readonly objectName?: string;
    /**
     * Date of check account transaction creation
     */
    readonly create?: string;
    /**
     * Date of last check account transaction update
     */
    readonly update?: string;
    /**
     * Client to which check account transaction belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Date the check account transaction was imported
     */
    valueDate?: string;
    /**
     * Date the check account transaction was booked
     */
    entryDate?: string | null;
    /**
     * The purpose of the transaction
     */
    paymtPurpose?: string | null;
    /**
     * Amount of the transaction
     */
    amount?: string;
    /**
     * Name of the other party
     */
    payeePayerName?: string | null;
    /**
     * IBAN or account number of the other party
     */
    payeePayerAcctNo?: string | null;
    /**
     * BIC or bank code of the other party
     */
    payeePayerBankCode?: string | null;
    /**
     * ZKA business transaction code. This can be given for finAPI accounts.
     */
    gvCode?: string | null;
    /**
     * Transaction type, according to the bank. This can be given for finAPI accounts.
     */
    entryText?: string | null;
    /**
     * Transaction primanota. This can be given for finAPI accounts.
     */
    primaNotaNo?: string | null;
    /**
     * The check account to which the transaction belongs
     */
    readonly checkAccount?: {
        /**
         * Unique identifier of the check account
         */
        id: string;
        /**
         * Model name, which is 'CheckAccount'
         */
        objectName: string;
    };
    /**
     * Status of the check account transaction.<br>
     * 100 <-> Created<br>
     * 200 <-> Linked<br>
     * 300 <-> Private<br>
     * 350 <-> Auto-booked without user confirmation<br>400 <-> Booked
     */
    status?: '100' | '200' | '300' | '350' | '400';
    /**
     * The check account transaction serving as the source of a money transit
     */
    readonly sourceTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: string;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    };
    /**
     * The check account transaction serving as the target of a money transit
     */
    readonly targetTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: string;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    };
    /**
     * Timepoint when the transaction was enshrined.
     */
    readonly enshrined?: string;
};

/**
 * CheckAccountTransaction model
 *
 * CheckAccountTransaction model. Responsible for the transactions on payment accounts.
 */
export type ModelCheckAccountTransaction = {
    /**
     * The check account transaction id
     */
    readonly id?: number;
    /**
     * The check account transaction object name
     */
    readonly objectName?: string;
    /**
     * Date of check account transaction creation
     */
    readonly create?: string;
    /**
     * Date of last check account transaction update
     */
    readonly update?: string;
    /**
     * Client to which check account transaction belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Date the check account transaction was booked
     */
    valueDate: string;
    /**
     * Date the check account transaction was imported
     */
    entryDate?: string | null;
    /**
     * The purpose of the transaction
     */
    paymtPurpose?: string | null;
    /**
     * Amount of the transaction
     */
    amount: number;
    /**
     * Name of the other party
     */
    payeePayerName: string | null;
    /**
     * IBAN or account number of the other party
     */
    payeePayerAcctNo?: string | null;
    /**
     * BIC or bank code of the other party
     */
    payeePayerBankCode?: string | null;
    /**
     * The check account to which the transaction belongs
     */
    checkAccount: {
        /**
         * Unique identifier of the check account
         */
        id: number;
        /**
         * Model name, which is 'CheckAccount'
         */
        objectName: string;
    };
    /**
     * Status of the check account transaction.<br>
     * 100 <-> Created<br>
     * 200 <-> Linked<br>
     * 300 <-> Private<br>
     * 400 <-> Booked
     */
    status: 100 | 200 | 300 | 400;
    /**
     * The check account transaction serving as the source of the rebooking
     */
    sourceTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: number;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    } | null;
    /**
     * The check account transaction serving as the target of the rebooking
     */
    targetTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: number;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    } | null;
};

/**
 * CheckAccountTransaction model
 *
 * CheckAccountTransaction model. Responsible for the transactions on payment accounts.
 */
export type ModelCheckAccountTransactionUpdate = {
    /**
     * Date the check account transaction was booked
     */
    valueDate?: string;
    /**
     * Date the check account transaction was imported
     */
    entryDate?: string | null;
    /**
     * the purpose of the transaction
     */
    paymtPurpose?: string;
    /**
     * Amount of the transaction
     */
    amount?: number | null;
    /**
     * Name of the payee/payer
     */
    payeePayerName?: string | null;
    /**
     * The check account to which the transaction belongs
     */
    checkAccount?: {
        /**
         * Unique identifier of the check account
         */
        id: number;
        /**
         * Model name, which is 'CheckAccount'
         */
        objectName: string;
    };
    /**
     * Status of the check account transaction.<br>
     * 100 <-> Created<br>
     * 200 <-> Linked<br>
     * 300 <-> Private<br>
     * 400 <-> Booked
     */
    status?: 100 | 200 | 300 | 400;
    /**
     * The check account transaction serving as the source of the rebooking
     */
    sourceTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: number;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    } | null;
    /**
     * The check account transaction serving as the target of the rebooking
     */
    targetTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: number;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    } | null;
};

export type ValidationError = {
    error?: {
        message?: string;
        /**
         * An identifier of this exact problem that can be given to the support team.
         */
        exceptionUUID?: string;
    };
};

/**
 * PrivateTransactionRule model, response format
 *
 * A rule defining which transactions to mark as private automatically.
 */
export type ModelPrivateTransactionRuleResponse = {
    /**
     * The entity id
     */
    id?: string;
    /**
     * The entity object name, PrivateTransactionRule
     */
    objectName?: string;
    /**
     * Date of entity creation
     */
    create?: string;
    /**
     * Date of last entity update
     */
    update?: string;
    /**
     * Client to which the entity belongs.
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id?: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName?: string;
    };
    /**
     * The payment purpose of transactions to match
     */
    paymentPurpose?: string | null;
    /**
     * The counterpart name of transactions to match
     */
    counterpartName?: string | null;
};

/**
 * Request body to create a PrivateTransactionRule
 */
export type CreatePrivateTransactionRule = {
    /**
     * PrivateTransactionRule
     */
    objectName: string;
    /**
     * The purpose of transactions that you want to match
     */
    paymentPurpose?: string | null;
    /**
     * The counterpart name of transactions that you want to match
     */
    counterpartName?: string | null;
};

/**
 * Contact model
 *
 * Contact model
 */
export type ModelContactResponse = {
    /**
     * The contact id
     */
    readonly id?: string;
    /**
     * The contact object name
     */
    readonly objectName?: string;
    /**
     * Date of contact creation
     */
    readonly create?: string;
    /**
     * Date of last contact update
     */
    readonly update?: string;
    /**
     * The organization name.<br>
     * Be aware that the type of contact will depend on this attribute.<br>
     * If it holds a value, the contact will be regarded as an organization.
     */
    readonly name?: string;
    /**
     * Defines the status of the contact. 100 <-> Lead - 500 <-> Pending - 1000 <-> Active.
     */
    readonly status?: string;
    /**
     * The customer number
     */
    readonly customerNumber?: string;
    /**
     * The parent contact to which this contact belongs. Must be an organization.
     */
    readonly parent?: {
        /**
         * Unique identifier of the parent contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * The <b>first</b> name of the contact.<br>
     * Yeah... not quite right in literally every way. We know.<br>
     * Not to be used for organizations.
     */
    readonly surename?: string;
    /**
     * The last name of the contact.<br>
     * Not to be used for organizations.
     */
    readonly familyname?: string;
    /**
     * A non-academic title for the contact.
     * Not to be used for organizations.
     */
    readonly titel?: string;
    /**
     * Category of the contact.<br> For more information,
     * see <a href='https://my.sevdesk.de/apiOverview/index.html#/doc-contacts#types'>here</a>.
     */
    readonly category?: {
        /**
         * Unique identifier of the category
         */
        id: string;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    };
    /**
     * A description for the contact.
     */
    readonly description?: string;
    /**
     * A academic title for the contact.
     * Not to be used for organizations.
     */
    readonly academicTitle?: string;
    /**
     * Gender of the contact.<br>
     * Not to be used for organizations.
     */
    readonly gender?: string;
    /**
     * Client to which contact belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Second name of the contact.<br>
     * Not to be used for organizations.
     */
    readonly name2?: string;
    /**
     * Birthday of the contact.<br>
     * Not to be used for organizations.
     */
    readonly birthday?: string;
    /**
     * Vat number of the contact.
     */
    readonly vatNumber?: string;
    /**
     * Bank account number (IBAN) of the contact.
     */
    readonly bankAccount?: string;
    /**
     * Bank number of the bank used by the contact.
     */
    readonly bankNumber?: string;
    /**
     * Absolute time in days which the contact has to pay his invoices and subsequently get a cashback.
     */
    readonly defaultCashbackTime?: string;
    /**
     * Percentage of the invoice sum the contact gets back if he paid invoices in time.
     */
    readonly defaultCashbackPercent?: string;
    /**
     * The payment goal in days which is set for every invoice of the contact.
     */
    readonly defaultTimeToPay?: string;
    /**
     * The tax number of the contact.
     */
    readonly taxNumber?: string;
    /**
     * The tax office of the contact (only for greek customers).
     */
    readonly taxOffice?: string;
    /**
     * Defines if the contact is freed from paying vat.
     */
    readonly exemptVat?: string;
    /**
     * The default discount the contact gets for every invoice.<br>
     * Depending on defaultDiscountPercentage attribute, in percent or absolute value.
     */
    readonly defaultDiscountAmount?: string;
    /**
     * Defines if the discount is a percentage (true) or an absolute value (false).
     */
    readonly defaultDiscountPercentage?: string;
    /**
     * Buyer reference of the contact.
     */
    readonly buyerReference?: string;
    /**
     * Defines whether the contact is a government agency (true) or not (false).
     */
    readonly governmentAgency?: string;
    /**
     * Additional information stored for the contact.
     *
     * @deprecated
     */
    readonly additionalInformation?: string;
};

/**
 * Contact model
 *
 * Contact model
 */
export type ModelContact = {
    /**
     * The organization name.<br>
     * Be aware that the type of contact will depend on this attribute.<br>
     * If it holds a value, the contact will be regarded as an organization.
     */
    name?: string | null;
    /**
     * Defines the status of the contact. 100 <-> Lead - 500 <-> Pending - 1000 <-> Active.
     */
    status?: number | null;
    /**
     * The customer number
     */
    customerNumber?: string | null;
    /**
     * The parent contact to which this contact belongs. Must be an organization.
     */
    parent?: {
        /**
         * Unique identifier of the parent contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The <b>first</b> name of the contact.<br>
     * Yeah... not quite right in literally every way. We know.<br>
     * Not to be used for organizations.
     */
    surename?: string | null;
    /**
     * The last name of the contact.<br>
     * Not to be used for organizations.
     */
    familyname?: string | null;
    /**
     * A non-academic title for the contact.
     * Not to be used for organizations.
     */
    titel?: string | null;
    /**
     * Category of the contact.<br> For more information,
     * see <a href='https://my.sevdesk.de/apiOverview/index.html#/doc-contacts#types'>here</a>.
     */
    category: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    };
    /**
     * A description for the contact.
     */
    description?: string | null;
    /**
     * A academic title for the contact.
     * Not to be used for organizations.
     */
    academicTitle?: string | null;
    /**
     * Gender of the contact.<br>
     * Not to be used for organizations.
     */
    gender?: string | null;
    /**
     * Second name of the contact.<br>
     * Not to be used for organizations.
     */
    name2?: string | null;
    /**
     * Birthday of the contact.<br>
     * Not to be used for organizations.
     */
    birthday?: string | null;
    /**
     * Vat number of the contact.
     */
    vatNumber?: string | null;
    /**
     * Bank account number (IBAN) of the contact.
     */
    bankAccount?: string | null;
    /**
     * Bank number of the bank used by the contact.
     */
    bankNumber?: string | null;
    /**
     * Absolute time in days which the contact has to pay his invoices and subsequently get a cashback.
     */
    defaultCashbackTime?: number | null;
    /**
     * Percentage of the invoice sum the contact gets back if he paid invoices in time.
     */
    defaultCashbackPercent?: number | null;
    /**
     * The payment goal in days which is set for every invoice of the contact.
     */
    defaultTimeToPay?: number | null;
    /**
     * The tax number of the contact.
     */
    taxNumber?: string | null;
    /**
     * The tax office of the contact (only for greek customers).
     */
    taxOffice?: string | null;
    /**
     * Defines if the contact is freed from paying vat.
     */
    exemptVat?: boolean | null;
    /**
     * The default discount the contact gets for every invoice.<br>
     * Depending on defaultDiscountPercentage attribute, in percent or absolute value.
     */
    defaultDiscountAmount?: number | null;
    /**
     * Defines if the discount is a percentage (true) or an absolute value (false).
     */
    defaultDiscountPercentage?: boolean | null;
    /**
     * Buyer reference of the contact.
     */
    buyerReference?: string | null;
    /**
     * Defines whether the contact is a government agency (true) or not (false).
     */
    governmentAgency?: boolean | null;
};

/**
 * Contact model
 *
 * Contact model
 */
export type ModelContactUpdate = {
    /**
     * The organization name.<br>
     * Be aware that the type of contact will depend on this attribute.<br>
     * If it holds a value, the contact will be regarded as an organization.
     */
    name?: string | null;
    /**
     * Defines the status of the contact. 100 <-> Lead - 500 <-> Pending - 1000 <-> Active.
     */
    status?: number | null;
    /**
     * The customer number
     */
    customerNumber?: string | null;
    /**
     * The parent contact to which this contact belongs. Must be an organization.
     */
    parent?: {
        /**
         * Unique identifier of the parent contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The <b>first</b> name of the contact.<br>
     * Yeah... not quite right in literally every way. We know.<br>
     * Not to be used for organizations.
     */
    surename?: string | null;
    /**
     * The last name of the contact.<br>
     * Not to be used for organizations.
     */
    familyname?: string | null;
    /**
     * A non-academic title for the contact.
     * Not to be used for organizations.
     */
    titel?: string | null;
    /**
     * Category of the contact.<br> For more information,
     * see <a href='https://my.sevdesk.de/apiOverview/index.html#/doc-contacts#types'>here</a>.
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * A description for the contact.
     */
    description?: string | null;
    /**
     * A academic title for the contact.
     * Not to be used for organizations.
     */
    academicTitle?: string | null;
    /**
     * Gender of the contact.<br>
     * Not to be used for organizations.
     */
    gender?: string | null;
    /**
     * Second name of the contact.<br>
     * Not to be used for organizations.
     */
    name2?: string | null;
    /**
     * Birthday of the contact.<br>
     * Not to be used for organizations.
     */
    birthday?: string | null;
    /**
     * Vat number of the contact.
     */
    vatNumber?: string | null;
    /**
     * Bank account number (IBAN) of the contact.
     */
    bankAccount?: string | null;
    /**
     * Bank number of the bank used by the contact.
     */
    bankNumber?: string | null;
    /**
     * Absolute time in days which the contact has to pay his invoices and subsequently get a cashback.
     */
    defaultCashbackTime?: number | null;
    /**
     * Percentage of the invoice sum the contact gets back if he paid invoices in time.
     */
    defaultCashbackPercent?: number | null;
    /**
     * The payment goal in days which is set for every invoice of the contact.
     */
    defaultTimeToPay?: number | null;
    /**
     * The tax number of the contact.
     */
    taxNumber?: string | null;
    /**
     * The tax office of the contact (only for greek customers).
     */
    taxOffice?: string | null;
    /**
     * Defines if the contact is freed from paying vat.
     */
    exemptVat?: boolean | null;
    /**
     * The default discount the contact gets for every invoice.<br>
     * Depending on defaultDiscountPercentage attribute, in percent or absolute value.
     */
    defaultDiscountAmount?: number | null;
    /**
     * Defines if the discount is a percentage (true) or an absolute value (false).
     */
    defaultDiscountPercentage?: boolean | null;
    /**
     * Buyer reference of the contact.
     */
    buyerReference?: string | null;
    /**
     * Defines whether the contact is a government agency (true) or not (false).
     */
    governmentAgency?: boolean | null;
};

/**
 * Contact address
 *
 * ContactAddress model
 */
export type ModelContactAddressResponse = {
    /**
     * The contact address id
     */
    readonly id?: number;
    /**
     * The contact address object name
     */
    readonly objectName?: string;
    /**
     * Date of contact address creation
     */
    readonly create?: string;
    /**
     * Date of last contact address update
     */
    readonly update?: string;
    /**
     * The contact to which this contact address belongs.
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Street name
     */
    street?: string | null;
    /**
     * Zib code
     */
    zip?: string | null;
    /**
     * City name
     */
    city?: string | null;
    /**
     * Country of the contact address.<br>
     * For all countries, send a GET to /StaticCountry
     */
    country: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Category of the contact address.<br>
     * For all categories, send a GET to /Category?objectType=ContactAddress.
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * Name in address
     */
    name?: string | null;
    /**
     * Client to which contact address belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Second name in address
     */
    name2?: string;
    /**
     * Third name in address
     */
    name3?: string | null;
    /**
     * Fourth name in address
     */
    name4?: string | null;
};

/**
 * Contact address
 *
 * ContactAddress model
 */
export type ModelContactAddress = {
    /**
     * The contact address id
     */
    readonly id?: number;
    /**
     * The contact address object name
     */
    readonly objectName?: string;
    /**
     * Date of contact address creation
     */
    readonly create?: string;
    /**
     * Date of last contact address update
     */
    readonly update?: string;
    /**
     * The contact to which this contact address belongs.
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Street name
     */
    street?: string | null;
    /**
     * Zib code
     */
    zip?: string | null;
    /**
     * City name
     */
    city?: string | null;
    /**
     * Country of the contact address.<br>
     * For all countries, send a GET to /StaticCountry
     */
    country: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Category of the contact address.<br>
     * For all categories, send a GET to /Category?objectType=ContactAddress.
     */
    category: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * Name in address
     */
    name?: string | null;
    /**
     * Client to which contact address belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Second name in address
     */
    name2?: string;
    /**
     * Third name in address
     */
    name3?: string | null;
    /**
     * Fourth name in address
     */
    name4?: string | null;
};

/**
 * Contact address
 *
 * ContactAddress model
 */
export type ModelContactAddressUpdate = {
    /**
     * The contact to which this contact address belongs.
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * Street name
     */
    street?: string | null;
    /**
     * Zib code
     */
    zip?: string | null;
    /**
     * City name
     */
    city?: string | null;
    /**
     * Country of the contact address.<br>
     * For all countries, send a GET to /StaticCountry
     */
    country?: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Category of the contact address.<br>
     * For all categories, send a GET to /Category?objectType=ContactAddress.
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * Name in address
     */
    name?: string | null;
    /**
     * Second name in address
     */
    name2?: string;
    /**
     * Third name in address
     */
    name3?: string | null;
    /**
     * Fourth name in address
     */
    name4?: string | null;
};

/**
 * CommunicationWay model
 *
 * Contact communication way model
 */
export type ModelCommunicationWayResponse = {
    /**
     * The communication way id
     */
    readonly id?: string;
    /**
     * The communication way object name
     */
    readonly objectName?: string;
    /**
     * Date of communication way creation
     */
    readonly create?: string;
    /**
     * Date of last communication way update
     */
    readonly update?: string;
    /**
     * The contact to which this communication way belongs.
     */
    readonly contact?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Type of the communication way
     */
    type?: 'EMAIL' | 'PHONE' | 'WEB' | 'MOBILE';
    /**
     * The value of the communication way.<br>
     * For example the phone number, e-mail address or website.
     */
    readonly value?: string;
    /**
     * The key of the communication way.<br>
     * Similar to the category of addresses.<br>
     * For all communication way keys please send a GET to /CommunicationWayKey.
     */
    readonly key?: {
        /**
         * Unique identifier of the key
         */
        id: string;
        /**
         * Model name, which is 'CommunicationWayKey'
         */
        objectName: string;
    };
    /**
     * Defines whether the communication way is the main communication way for the contact.
     */
    readonly main?: string;
    /**
     * Client to which communication way key belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

/**
 * CommunicationWay model
 *
 * Contact communication way model
 */
export type ModelCommunicationWay = {
    /**
     * The communication way id
     */
    readonly id?: number;
    /**
     * The communication way object name
     */
    readonly objectName?: string;
    /**
     * Date of communication way creation
     */
    readonly create?: string;
    /**
     * Date of last communication way update
     */
    readonly update?: string;
    /**
     * The contact to which this communication way belongs.
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Type of the communication way
     */
    type: 'EMAIL' | 'PHONE' | 'WEB' | 'MOBILE';
    /**
     * The value of the communication way.<br>
     * For example the phone number, e-mail address or website.
     */
    value: string;
    /**
     * The key of the communication way.<br>
     * Similar to the category of addresses.<br>
     * For all communication way keys please send a GET to /CommunicationWayKey.
     */
    key: {
        /**
         * Unique identifier of the key
         */
        id: number;
        /**
         * Model name, which is 'CommunicationWayKey'
         */
        objectName: string;
    };
    /**
     * Defines whether the communication way is the main communication way for the contact.
     */
    main?: boolean | null;
    /**
     * Client to which communication way key belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

/**
 * CommunicationWay model
 *
 * Contact communication way model
 */
export type ModelCommunicationWayUpdate = {
    /**
     * The contact to which this communication way belongs.
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * Type of the communication way
     */
    type?: 'EMAIL' | 'PHONE' | 'WEB' | 'MOBILE';
    /**
     * The value of the communication way.<br>
     * For example the phone number, e-mail address or website.
     */
    value?: string;
    /**
     * The key of the communication way.<br>
     * Similar to the category of addresses.<br>
     * For all communication way keys please send a GET to /CommunicationWayKey.
     */
    key?: {
        /**
         * Unique identifier of the key
         */
        id: number;
        /**
         * Model name, which is 'CommunicationWayKey'
         */
        objectName: string;
    } | null;
    /**
     * Defines whether the communication way is the main communication way for the contact.
     */
    main?: boolean | null;
};

/**
 * AccountingContact model
 *
 * Accounting contact model
 */
export type ModelAccountingContactResponse = {
    /**
     * The accounting contact id
     */
    readonly id?: string;
    /**
     * The accounting contact object name
     */
    readonly objectName?: string;
    /**
     * Date of accounting contact creation
     */
    readonly create?: string;
    /**
     * Date of last accounting contact update
     */
    readonly update?: string;
    /**
     * The contact to which this accounting contact belongs.
     */
    readonly contact?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Client to which accounting contact belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Debitor number of the accounting contact.
     */
    readonly debitorNumber?: string;
    /**
     * Creditor number of the accounting contact.
     */
    readonly creditorNumber?: string;
};

/**
 * AccountingContact model
 *
 * Accounting contact model
 */
export type ModelAccountingContact = {
    /**
     * The contact to which this accounting contact belongs.
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Debitor number of the accounting contact.
     */
    debitorNumber?: number | null;
    /**
     * Creditor number of the accounting contact.
     */
    creditorNumber?: number | null;
};

/**
 * AccountingContact model
 *
 * Accounting contact model
 */
export type ModelAccountingContactUpdate = {
    /**
     * The contact to which this accounting contact belongs.
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * Debitor number of the accounting contact.
     */
    debitorNumber?: number | null;
    /**
     * Creditor number of the accounting contact.
     */
    creditorNumber?: number | null;
};

/**
 * Textparser fetchDictionaryEntriesByType model
 *
 * Textparser fetchDictionaryEntriesByType model
 */
export type ModelTextparserFetchDictionaryEntriesByTypeResponse = {
    key?: string;
    value?: Array<{
        key?: string;
        value?: string;
    }>;
};

/**
 * contact fields model
 *
 * contact fields model
 */
export type ModelContactCustomFieldSettingResponse = {
    /**
     * Id of the contact field
     */
    readonly id?: string;
    /**
     * Internal object name which is 'ContactCustomFieldSetting'.
     */
    readonly objectName?: string;
    /**
     * Date of contact field creation
     */
    readonly create?: string;
    /**
     * Date of contact field updated
     */
    readonly update?: string;
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * name of the contact fields
     */
    readonly name?: string;
    /**
     * Unique identifier for the contact field
     */
    readonly identifier?: string;
    /**
     * The description of the contact field
     */
    readonly description?: string;
};

/**
 * contact fields model
 *
 * contact fields model
 */
export type ModelContactCustomFieldResponse = {
    /**
     * id of the contact field
     */
    id?: string;
    /**
     * Internal object name which is 'ContactCustomField'.
     */
    objectName?: string;
    /**
     * Date of contact field creation
     */
    create?: string;
    /**
     * Date of contact field update
     */
    update?: string;
    /**
     * Client to which contact field belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * name of the contact
     */
    contact?: {
        /**
         * Unique identifier of contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * the contact custom field setting
     */
    contactCustomFieldSetting?: ModelContactCustomFieldSettingResponse;
    /**
     * The value of the contact field
     */
    value?: string;
};

/**
 * Contact fields model
 *
 * Contact fields model
 */
export type ModelContactCustomField = {
    /**
     * name of the contact
     */
    contact: {
        /**
         * Unique identifier of contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * name of the contact custom field setting
     */
    contactCustomFieldSetting: {
        /**
         * Unique identifier of contact custom field setting
         */
        id: number;
        /**
         * Model name, which is 'ContactCustomFieldSetting'
         */
        objectName: string;
    };
    /**
     * The value of the contact field
     */
    value: string;
    /**
     * Internal object name which is 'ContactCustomField'.
     */
    objectName: string;
};

/**
 * contact fields model
 *
 * contact fields model
 */
export type ModelContactCustomFieldUpdate = {
    /**
     * name of the contact
     */
    contact?: {
        /**
         * Unique identifier of contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * name of the contact custom field setting
     */
    contactCustomFieldSetting?: {
        /**
         * Unique identifier of contact custom field setting
         */
        id: number;
        /**
         * Model name, which is 'contactCustomFieldSetting'
         */
        objectName: string;
    };
    /**
     * The value of the contact field
     */
    value?: string;
    /**
     * Internal object name which is 'ContactCustomField'.
     */
    objectName?: string;
};

/**
 * contact field settings model
 *
 * contact field settings model
 */
export type ModelContactCustomFieldSetting = {
    /**
     * name of the contact fields
     */
    name: string;
    /**
     * The description of the contact field
     */
    description?: string;
    /**
     * Internal object name which is 'ContactCustomFieldSetting'.
     */
    objectName?: string;
};

/**
 * contact fields model
 *
 * contact fields model
 */
export type ModelContactCustomFieldSettingUpdate = {
    /**
     * name of the contact fields
     */
    name?: string;
    /**
     * The description of the contact field
     */
    description?: string;
    /**
     * Internal object name which is 'ContactCustomFieldSetting'.
     */
    objectName?: string;
};

/**
 * creditNote model
 *
 * creditNote model
 */
export type ModelCreditNoteResponse = {
    /**
     * The creditNote id
     */
    readonly id?: string;
    /**
     * The creditNote object name
     */
    readonly objectName?: string;
    /**
     * Date of creditNote creation
     */
    readonly create?: string;
    /**
     * Date of last creditNote update
     */
    readonly update?: string;
    /**
     * The creditNote number
     */
    creditNoteNumber?: string | null;
    /**
     * The contact used in the creditNote
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The credit note date
     */
    creditNoteDate?: string;
    /**
     * Please have a look in
     * <a href='#tag/CreditNote/Status-of-credit-notes'>status of credit note</a>
     * to see what the different status codes mean
     */
    status?: '100' | '200' | '750' | '1000';
    /**
     * Normally consist of prefix plus the creditNote number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: string;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Will be filled automatically by our system and can't be changed
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Client to which creditNote belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil
     */
    deliveryDate?: string;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the creditNote must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the creditNote
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    } | null;
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: string | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the creditNote. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string | null;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the creditNote.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * The date the creditNote was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the creditNote. Needs to be currency code according to ISO-4217
     */
    currency?: string | null;
    /**
     * Net sum of the creditNote
     */
    readonly sumNet?: string;
    /**
     * Tax sum of the creditNote
     */
    readonly sumTax?: string;
    /**
     * Gross sum of the creditNote
     */
    readonly sumGross?: string;
    /**
     * Sum of all discounts in the creditNote
     */
    readonly sumDiscounts?: string;
    /**
     * Net sum of the creditNote in the foreign currency
     */
    readonly sumNetForeignCurrency?: string;
    /**
     * Tax sum of the creditNote in the foreign currency
     */
    readonly sumTaxForeignCurrency?: string;
    /**
     * Gross sum of the creditNote in the foreign currency
     */
    readonly sumGrossForeignCurrency?: string;
    /**
     * Discounts sum of the creditNote in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: string;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * creditNote model
 *
 * creditNote model
 */
export type ModelCreditNote = {
    /**
     * The creditNote id. <span style='color:red'>Required</span> if you want to create/update an credit note position for an existing credit note"
     */
    id?: number;
    /**
     * The creditNote object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * Date of creditNote creation
     */
    readonly create?: string;
    /**
     * Date of last creditNote update
     */
    readonly update?: string;
    /**
     * The creditNote number
     */
    creditNoteNumber: string;
    /**
     * The contact used in the creditNote
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    creditNoteDate: string;
    /**
     * Please have a look in
     * <a href='#tag/CreditNote/Status-of-credit-notes'>status of credit note</a>
     * to see what the different status codes mean
     */
    status: '100' | '200' | '300' | '500' | '750' | '1000';
    /**
     * Normally consist of prefix plus the creditNote number
     */
    header: string;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Will be filled automatically by our system and can't be changed
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Client to which creditNote belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the creditNote must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the creditNote
     */
    contactPerson: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate: number;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the creditNote. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the creditNote.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: string;
    /**
     * The date the creditNote was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Defines the booking category, for more information see the section [Credit note booking categories](#tag/CreditNote/Credit-note-booking-categories)
     *
     * The booking category of the credit note.
     *
     * **<code>ACCOUNTING_TYPE</code> is currently not supported in sevdesk-Update 2.0.**
     */
    bookingCategory: 'PROVISION' | 'ROYALTY_ASSIGNED' | 'ROYALTY_UNASSIGNED' | 'UNDERACHIEVEMENT' | 'ACCOUNTING_TYPE';
    /**
     * Currency used in the creditNote. Needs to be currency code according to ISO-4217
     */
    currency: string;
    /**
     * Net sum of the creditNote
     */
    readonly sumNet?: number;
    /**
     * Tax sum of the creditNote
     */
    readonly sumTax?: number;
    /**
     * Gross sum of the creditNote
     */
    readonly sumGross?: number;
    /**
     * Sum of all discounts in the creditNote
     */
    readonly sumDiscounts?: number;
    /**
     * Net sum of the creditNote in the foreign currency
     */
    readonly sumNetForeignCurrency?: number;
    /**
     * Tax sum of the creditNote in the foreign currency
     */
    readonly sumTaxForeignCurrency?: number;
    /**
     * Gross sum of the creditNote in the foreign currency
     */
    readonly sumGrossForeignCurrency?: number;
    /**
     * Discounts sum of the creditNote in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: number;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * creditNote position model
 *
 * creditNote position model
 */
export type ModelCreditNotePos = {
    /**
     * The creditNote position id.
     */
    readonly id?: number | null;
    /**
     * The creditNote position object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * Date of creditNote position creation
     */
    readonly create?: string;
    /**
     * Date of last creditNote position update
     */
    readonly update?: string;
    /**
     * The creditNote to which the position belongs.  <span style='color:red'>Required</span> if you want to create/update an credit note position for an existing credit note"
     */
    creditNote?: {
        /**
         * Unique identifier of the creditNote
         */
        id: number;
        /**
         * Model name, which is 'creditNote'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: number;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Net price of the part
     */
    readonly priceNet?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Client to which creditNote position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to creditNote multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate: number;
    /**
     * Discount sum of the position
     */
    readonly sumDiscount?: number | null;
};

export type SaveCreditNote = {
    creditNote: ModelCreditNote;
    creditNotePosSave?: Array<ModelCreditNotePos>;
    creditNotePosDelete?: {
        /**
         * Id of credit note position
         */
        id: number;
        /**
         * Object name of credit note position
         */
        objectName: string;
    };
    discountSave?: {
        /**
         * Defines if this is a discount or a surcharge
         */
        discount: boolean;
        /**
         * A text for your discount
         */
        text: string;
        /**
         * Defines if this is a percentage or an absolute discount
         */
        percentage: boolean;
        /**
         * Value of the discount
         */
        value: number;
        /**
         * Object name of the discount
         */
        objectName: string;
        /**
         * Internal param
         */
        mapAll: boolean;
    };
    discountDelete?: {
        /**
         * ID of discount to delete
         */
        id: number;
        /**
         * Object name of discount
         */
        objectName: string;
    };
};

/**
 * creditNote position model
 *
 * creditNote position model
 */
export type ModelCreditNotePosResponse = {
    /**
     * The creditNote position id
     */
    readonly id?: string;
    /**
     * The creditNote position object name
     */
    readonly objectName?: string;
    /**
     * Date of creditNote position creation
     */
    readonly create?: string;
    /**
     * Date of last creditNote position update
     */
    readonly update?: string;
    /**
     * The creditNote to which the position belongs.
     */
    creditNote: {
        /**
         * Unique identifier of the creditNote
         */
        id: string;
        /**
         * Model name, which is 'creditNote'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: string;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: string;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: string | null;
    /**
     * Net price of the part
     */
    readonly priceNet?: string | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: string | null;
    /**
     * Gross price of the part
     */
    priceGross?: string | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: string;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Client to which creditNote position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to creditNote multiple positions.
     */
    positionNumber?: string | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: string | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate: string;
    /**
     * Discount sum of the position
     */
    readonly sumDiscount?: string | null;
};

export type SaveCreditNoteResponse = {
    creditNote?: ModelCreditNoteResponse;
    creditNotePos?: Array<ModelCreditNotePosResponse>;
};

export type ModelDiscountsResponse = {
    /**
     * The id of the discount
     */
    id?: number;
    /**
     * Model name, which is 'Discounts'
     */
    objectName?: string;
    /**
     * Date of discount creation
     */
    create?: string;
    /**
     * Date of last discount update
     */
    update?: string;
    /**
     * Client to which the discount belongs
     */
    sevClient?: string;
    /**
     * Indicates that this is a discount or a surcharge (0 = surcharge, 1 = discount)
     */
    discount?: string;
    /**
     * A text describing your position.
     */
    text?: string;
    /**
     * Defines if this is a percentage or an absolute discount
     */
    percentage?: string;
    /**
     * Value of the discount
     */
    value?: string;
    /**
     * Defines is the Discount net or gross (0 = net, 1 = gross)
     */
    isNet?: string;
};

/**
 * creditNote model
 *
 * creditNote model
 */
export type ModelCreditNoteUpdate = {
    /**
     * The creditNote id
     */
    readonly id?: number;
    /**
     * The creditNote object name
     */
    readonly objectName?: string;
    /**
     * Date of creditNote creation
     */
    readonly create?: string;
    /**
     * Date of last creditNote update
     */
    readonly update?: string;
    /**
     * The creditNote number
     */
    creditNoteNumber?: string | null;
    /**
     * The contact used in the creditNote
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    creditNoteDate?: string;
    /**
     * Please have a look in
     * <a href='#tag/CreditNote/Status-of-credit-notes'>status of credit note</a>
     * to see what the different status codes mean
     */
    status?: '100' | '200' | '750' | '1000';
    /**
     * Normally consist of prefix plus the creditNote number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Will be filled automatically by our system and can't be changed
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Client to which creditNote belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil
     */
    deliveryDate?: string;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the creditNote must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the creditNote
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    } | null;
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the creditNote. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string | null;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the creditNote.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * The date the creditNote was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the creditNote. Needs to be currency code according to ISO-4217
     */
    currency?: string | null;
    /**
     * Net sum of the creditNote
     */
    readonly sumNet?: number;
    /**
     * Tax sum of the creditNote
     */
    readonly sumTax?: number;
    /**
     * Gross sum of the creditNote
     */
    readonly sumGross?: number;
    /**
     * Sum of all discounts in the creditNote
     */
    readonly sumDiscounts?: number;
    /**
     * Net sum of the creditNote in the foreign currency
     */
    readonly sumNetForeignCurrency?: number;
    /**
     * Tax sum of the creditNote in the foreign currency
     */
    readonly sumTaxForeignCurrency?: number;
    /**
     * Gross sum of the creditNote in the foreign currency
     */
    readonly sumGrossForeignCurrency?: number;
    /**
     * Discounts sum of the creditNote in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: number;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

export type ModelCreditNoteSendByWithRender = {
    thumbs?: Array<unknown>;
    pages?: number;
    docId?: string;
    parameters?: Array<{
        key?: string;
        name?: string;
        values?: Array<{
            name?: string;
            translationCade?: string;
            value?: string;
        }>;
        visible?: boolean;
        value?: string;
    }>;
};

export type ModelCreditNoteMailResponse = {
    id?: number;
    objectName?: string;
    additionalInformation?: string;
    /**
     * Date of email creation
     */
    readonly create?: string;
    /**
     * Date of last email update
     */
    readonly update?: string;
    object?: ModelCreditNoteResponse;
    from?: string;
    to?: string;
    subject?: string;
    text?: string;
    /**
     * Client to which creditNote belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

/**
 * Export progress data JSON
 */
export type ExportProgressData = {
    /**
     * Current progress of the export. Export is finished when "current" reaches "total" (usually 100)
     */
    current?: number;
    /**
     * Total value of the export
     */
    total?: number;
};

/**
 * Export job download info JSON
 */
export type ExportJobDownloadInfo = {
    /**
     * Current progress of the export. Export is finished when "current" reaches "total" (usually 100)
     */
    filename?: string;
    /**
     * Download url of the export file
     */
    link?: string;
    /**
     * Expire date of the download url
     */
    linkExpireDate?: string;
};

/**
 * Part model
 *
 * Part model
 */
export type ModelPart = {
    /**
     * The part id
     */
    readonly id?: number;
    /**
     * The part object name
     */
    readonly objectName?: string;
    /**
     * Date of part creation
     */
    readonly create?: string;
    /**
     * Date of last part update
     */
    readonly update?: string;
    /**
     * Name of the part
     */
    name: string;
    /**
     * The part number
     */
    partNumber: string;
    /**
     * A text describing the part
     */
    text?: string | null;
    /**
     * Category of the part.<br>
     * For all categories, send a GET to /Category?objectType=Part
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * The stock of the part
     */
    stock: number;
    /**
     * Defines if the stock should be enabled
     */
    stockEnabled?: boolean;
    /**
     * The unit in which the part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Net price for which the part is sold. we will change this parameter so that the gross price is calculated automatically, until then the priceGross parameter must be used.
     */
    price?: number | null;
    /**
     * Net price for which the part is sold
     */
    priceNet?: number | null;
    /**
     * Gross price for which the part is sold
     */
    priceGross?: number | null;
    /**
     * Client to which part belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Purchase price of the part
     */
    pricePurchase?: number | null;
    /**
     * Tax rate of the part
     */
    taxRate: number;
    /**
     * Status of the part. 50 <-> Inactive - 100 <-> Active
     */
    status?: 50 | 100;
    /**
     * An internal comment for the part.<br>
     * Does not appear on invoices and orders.
     */
    internalComment?: string | null;
};

/**
 * Part model
 *
 * Part model
 */
export type ModelPartUpdate = {
    /**
     * The part id
     */
    readonly id?: number | null;
    /**
     * The part object name
     */
    readonly objectName?: string | null;
    /**
     * Date of part creation
     */
    readonly create?: string;
    /**
     * Date of last part update
     */
    readonly update?: string;
    /**
     * Name of the part
     */
    name?: string;
    /**
     * The part number
     */
    partNumber?: string;
    /**
     * A text describing the part
     */
    text?: string | null;
    /**
     * Category of the part.<br>
     * For all categories, send a GET to /Category?objectType=Part
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * The stock of the part
     */
    stock?: number;
    /**
     * Defines if the stock should be enabled
     */
    stockEnabled?: boolean | null;
    /**
     * The unit in which the part is measured
     */
    unity?: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Net price for which the part is sold. we will change this parameter so that the gross price is calculated automatically, until then the priceGross parameter must be used.
     */
    price?: number | null;
    /**
     * Net price for which the part is sold
     */
    priceNet?: number | null;
    /**
     * Gross price for which the part is sold
     */
    priceGross?: number | null;
    /**
     * Client to which part belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Purchase price of the part
     */
    pricePurchase?: number | null;
    /**
     * Tax rate of the part
     */
    taxRate?: number;
    /**
     * Status of the part. 50 <-> Inactive - 100 <-> Active
     */
    status?: 50 | 100;
    /**
     * An internal comment for the part.<br>
     * Does not appear on invoices and orders.
     */
    internalComment?: string | null;
};

/**
 * Invoice model
 *
 * Invoice model
 */
export type ModelInvoiceResponse = {
    /**
     * The invoice id
     */
    readonly id?: string;
    /**
     * The invoice object name
     */
    readonly objectName?: string;
    /**
     * The invoice number
     */
    readonly invoiceNumber?: string;
    /**
     * The contact used in the invoice
     */
    readonly contact?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Date of invoice creation
     */
    readonly create?: string;
    /**
     * Date of last invoice update
     */
    readonly update?: string;
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * The invoice date.
     */
    readonly invoiceDate?: string;
    /**
     * Normally consist of prefix plus the invoice number
     */
    readonly header?: string;
    /**
     * Certain html tags can be used here to format your text
     */
    readonly headText?: string;
    /**
     * Certain html tags can be used here to format your text
     */
    readonly footText?: string;
    /**
     * The time the customer has to pay the invoice in days
     */
    readonly timeToPay?: string;
    /**
     * If a value other than zero is used for the discount attribute,
     * you need to specify the amount of days for which the discount is granted.
     */
    readonly discountTime?: string;
    /**
     * If you want to give a discount, define the percentage here. Otherwise provide zero as value
     */
    readonly discount?: string;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    readonly addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: string;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    readonly payDate?: string;
    /**
     * Will be filled automatically by our system and can't be changed
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil
     */
    readonly deliveryDate?: string;
    /**
     * Please have a look in our
     * <a href='#tag/Invoice/Types-and-status-of-invoices'>Types and status of invoices</a>
     * to see what the different status codes mean
     */
    status?: '50' | '100' | '200' | '750' | '1000';
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the invoice must not contain any vat
     */
    readonly smallSettlement?: boolean;
    /**
     * The user who acts as a contact person for the invoice
     */
    readonly contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    readonly taxRate?: string;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    readonly taxText?: string;
    /**
     * Defines how many reminders have already been sent for the invoice.
     * Starts with 1 (Payment reminder) and should be incremented by one every time another reminder is sent.
     */
    readonly dunningLevel?: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the invoice.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: 'default' | 'eu' | 'noteu' | 'custom';
    /**
     * Payment method used for the invoice
     */
    readonly paymentMethod?: {
        /**
         * Unique identifier of the payment method
         */
        id: string;
        /**
         * Model name, which is 'PaymentMethod'
         */
        objectName: string;
    };
    /**
     * Cost centre for the invoice
     */
    readonly costCentre?: {
        /**
         * Unique identifier of the cost centre
         */
        id: string;
        /**
         * Model name, which is 'CostCentre'
         */
        objectName: string;
    };
    /**
     * The date the invoice was sent to the customer
     */
    readonly sendDate?: string;
    /**
     * Origin of the invoice. Could f.e. be an order
     */
    readonly origin?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name. Could f.e. be 'Order''
         */
        objectName: string;
    };
    /**
     * Type of the invoice. For more information on the different types, check
     * <a href='#tag/Invoice/Types-and-status-of-invoices'>this</a> section
     *
     */
    invoiceType?: 'RE' | 'WKR' | 'SR' | 'MA' | 'TR' | 'AR' | 'ER';
    /**
     * The interval in which recurring invoices are due as ISO-8601 duration.<br>
     * Necessary attribute for all recurring invoices.
     */
    readonly accountIntervall?: string;
    /**
     * Timestamp when the next invoice will be generated by this recurring invoice.
     */
    readonly accountNextInvoice?: string;
    /**
     * Total reminder amount
     */
    readonly reminderTotal?: string;
    /**
     * Debit of the reminder
     */
    readonly reminderDebit?: string;
    /**
     * Deadline of the reminder as timestamp
     */
    readonly reminderDeadline?: string;
    /**
     * The additional reminder charge
     */
    readonly reminderCharge?: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the invoice. Needs to be added if you chose the tax type custom
     */
    readonly taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    };
    /**
     * Complete address of the recipient including name, street, city, zip and country.
     * * Line breaks can be used and will be displayed on the invoice pdf.
     */
    readonly address?: string;
    /**
     * Currency used in the invoice. Needs to be currency code according to ISO-4217
     */
    readonly currency?: string;
    /**
     * Net sum of the invoice
     */
    readonly sumNet?: string;
    /**
     * Tax sum of the invoice
     */
    readonly sumTax?: string;
    /**
     * Gross sum of the invoice
     */
    readonly sumGross?: string;
    /**
     * Sum of all discounts in the invoice
     */
    readonly sumDiscounts?: string;
    /**
     * Net sum of the invoice in the foreign currency
     */
    readonly sumNetForeignCurrency?: string;
    /**
     * Tax sum of the invoice in the foreign currency
     */
    readonly sumTaxForeignCurrency?: string;
    /**
     * Gross sum of the invoice in the foreign currency
     */
    readonly sumGrossForeignCurrency?: string;
    /**
     * Discounts sum of the invoice in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: string;
    /**
     * Net accounting sum of the invoice. Is usually the same as sumNet
     */
    readonly sumNetAccounting?: string;
    /**
     * Tax accounting sum of the invoice. Is usually the same as sumTax
     */
    readonly sumTaxAccounting?: string;
    /**
     * Gross accounting sum of the invoice. Is usually the same as sumGross
     */
    readonly sumGrossAccounting?: string;
    /**
     * Amount which has already been paid for this invoice by the customer
     */
    readonly paidAmount?: number;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    readonly customerInternalNote?: string;
    /**
     * If true, the net amount of each position will be shown on the invoice. Otherwise gross amount
     */
    readonly showNet?: boolean;
    /**
     * Enshrined invoices cannot be changed. Can only be set via [Invoice/{invoiceId}/enshrine](#tag/Invoice/operation/invoiceEnshrine). This operation cannot be undone.
     */
    readonly enshrined?: string;
    /**
     * Type which was used to send the invoice. IMPORTANT: Please refer to the invoice section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
    /**
     * If the delivery date should be a time range, another timestamp can be provided in this attribute
     * * to define a range from timestamp used in deliveryDate attribute to the timestamp used here.
     */
    readonly deliveryDateUntil?: string;
    /**
     * Internal attribute
     */
    readonly sendPaymentReceivedNotificationDate?: string;
};

/**
 * Invoice model
 *
 * Invoice model
 */
export type ModelInvoice = {
    /**
     * The invoice id. <span style='color:red'>Required</span> if you want to create or update an invoice position for an existing invoice
     */
    id?: number | null;
    /**
     * The invoice object name.
     */
    objectName?: string;
    /**
     * The invoice number
     */
    invoiceNumber?: string | null;
    /**
     * The contact used in the invoice
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * The user who acts as a contact person for the invoice
     */
    contactPerson: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Date of invoice creation
     */
    readonly create?: string;
    /**
     * Date of last invoice update
     */
    readonly update?: string;
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     *
     * **Requirements:**
     * * For final invoices (invoiceType = 'ER'), the invoiceDate must be later than or equal to the invoiceDate of related advance (invoiceType = 'AR') / partial (invoiceType = 'TR') invoices.</li>
     */
    invoiceDate: string;
    /**
     * Normally consist of prefix plus the invoice number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * The time the customer has to pay the invoice in days
     */
    timeToPay?: number | null;
    /**
     * If you want to give a discount, define the percentage here. Otherwise provide zero as value
     */
    discount: number;
    /**
     * Complete address of the recipient including name, street, city, zip and country.
     * * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * Will be filled automatically by our system and can't be changed
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil
     */
    deliveryDate?: string | null;
    /**
     * If the delivery date should be a time range, another timestamp can be provided in this attribute
     * * to define a range from timestamp used in deliveryDate attribute to the timestamp used here.
     */
    deliveryDateUntil?: number | null;
    /**
     * Please have a look in our
     * <a href='#tag/Invoice/Types-and-status-of-invoices'>Types and status of invoices</a>
     * to see what the different status codes mean
     */
    status: '50' | '100' | '200' | '750' | '1000';
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the invoice must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate: number;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the invoice.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: 'default' | 'eu' | 'noteu' | 'custom';
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the invoice. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Defines how many reminders have already been sent for the invoice.
     * Starts with 1 (Payment reminder) and should be incremented by one every time another reminder is sent.
     */
    readonly dunningLevel?: number | null;
    /**
     * Payment method used for the invoice
     */
    paymentMethod?: {
        /**
         * Unique identifier of the payment method
         */
        id: number;
        /**
         * Model name, which is 'PaymentMethod'
         */
        objectName: string;
    };
    /**
     * The date the invoice was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Type of the invoice. For more information on the different types, check
     * <a href='#tag/Invoice/Types-and-status-of-invoices'>this</a> section
     *
     */
    invoiceType: 'RE' | 'WKR' | 'SR' | 'MA' | 'TR' | 'AR' | 'ER';
    /**
     * The interval in which recurring invoices are due as ISO-8601 duration.<br>
     * Necessary attribute for all recurring invoices.
     */
    readonly accountIntervall?: string | null;
    /**
     * Timestamp when the next invoice will be generated by this recurring invoice.
     */
    readonly accountNextInvoice?: number | null;
    /**
     * Currency used in the invoice. Needs to be currency code according to ISO-4217
     */
    currency: string;
    /**
     * Net sum of the invoice
     */
    readonly sumNet?: number;
    /**
     * Tax sum of the invoice
     */
    readonly sumTax?: number;
    /**
     * Gross sum of the invoice
     */
    readonly sumGross?: number;
    /**
     * Sum of all discounts in the invoice
     */
    readonly sumDiscounts?: number;
    /**
     * Net sum of the invoice in the foreign currency
     */
    readonly sumNetForeignCurrency?: number;
    /**
     * Tax sum of the invoice in the foreign currency
     */
    readonly sumTaxForeignCurrency?: number;
    /**
     * Gross sum of the invoice in the foreign currency
     */
    readonly sumGrossForeignCurrency?: number;
    /**
     * Discounts sum of the invoice in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: number;
    /**
     * Net accounting sum of the invoice. Is usually the same as sumNet
     */
    readonly sumNetAccounting?: number;
    /**
     * Tax accounting sum of the invoice. Is usually the same as sumTax
     */
    readonly sumTaxAccounting?: number;
    /**
     * Gross accounting sum of the invoice. Is usually the same as sumGross
     */
    readonly sumGrossAccounting?: number;
    /**
     * Amount which has already been paid for this invoice by the customer
     */
    readonly paidAmount?: number | null;
    /**
     * If true, the net amount of each position will be shown on the invoice. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Enshrined invoices cannot be changed. Can only be set via [Invoice/{invoiceId}/enshrine](#tag/Invoice/operation/invoiceEnshrine). This operation cannot be undone.
     */
    readonly enshrined?: string;
    /**
     * Type which was used to send the invoice.
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
    /**
     * Origin of the invoice. Could f.e. be an order
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which could be 'Order'
         */
        objectName: string;
    } | null;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the invoice will be created as e-invoice.
     *
     * To create a valid e-invoice some extra data are required
     * - sevClient
     * - addressStreet
     * - addressZip
     * - addressCity
     * - bankIban
     * - bankBic
     * - contactEmail
     * - contactPhone
     * - taxNumber
     * - vatNumber
     * - contact
     * - buyerReference
     * - email
     * - invoice
     * - paymentMethod
     * - addressStreet
     * - addressZip
     * - addressCity
     * - addressCountry
     * - contact
     */
    propertyIsEInvoice?: boolean | null;
    mapAll: boolean;
};

/**
 * Invoice position model
 *
 * Invoice position model
 */
export type ModelInvoicePos = {
    /**
     * The invoice position id. <span style='color:red'>Required</span> if you want to update an invoice position for an existing invoice
     */
    id?: number;
    /**
     * The invoice position object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * Date of invoice position creation
     */
    readonly create?: string;
    /**
     * Date of last invoice position update
     */
    readonly update?: string;
    /**
     * The invoice to which the position belongs.
     */
    readonly invoice?: {
        /**
         * Unique identifier of the invoice
         */
        id: number;
        /**
         * Model name, which is 'Invoice'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: number;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Client to which invoice position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Tax rate of the position.
     */
    taxRate: number;
    /**
     * Discount sum of the position
     */
    readonly sumDiscount?: number | null;
    /**
     * Net accounting sum of the position
     */
    readonly sumNetAccounting?: number | null;
    /**
     * Tax accounting sum of the position
     */
    readonly sumTaxAccounting?: number | null;
    /**
     * Gross accounting sum of the position
     */
    readonly sumGrossAccounting?: number | null;
    /**
     * Net price of the part
     */
    readonly priceNet?: number | null;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
};

export type SaveInvoice = {
    invoice: ModelInvoice;
    invoicePosSave?: Array<ModelInvoicePos>;
    invoicePosDelete?: {
        /**
         * Id of invoice position
         */
        id: number;
        /**
         * Object name of invoice position
         */
        objectName: string;
    };
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
    discountSave?: Array<{
        /**
         * Defines if this is a discount or a surcharge
         */
        discount?: boolean;
        /**
         * A text for your discount
         */
        text?: string;
        /**
         * Defines if this is a percentage or an absolute discount
         */
        percentage?: boolean;
        /**
         * Value of the discount
         */
        value?: number;
        /**
         * Object name of the discount
         */
        objectName?: string;
        /**
         * Internal param
         */
        mapAll?: boolean;
    }>;
    discountDelete?: {
        /**
         * ID of discount to delete
         */
        id?: number;
        /**
         * Object name of discount
         */
        objectName?: string;
    };
};

/**
 * Invoice position model
 *
 * Invoice position model
 */
export type ModelInvoicePosResponse = {
    /**
     * The invoice position id
     */
    readonly id?: string;
    /**
     * The invoice position object name
     */
    readonly objectName?: string;
    /**
     * Date of invoice position creation
     */
    readonly create?: string;
    /**
     * Date of last invoice position update
     */
    readonly update?: string;
    /**
     * The invoice to which the position belongs.
     */
    readonly invoice?: {
        /**
         * Unique identifier of the invoice
         */
        id: string;
        /**
         * Model name, which is 'Invoice'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    readonly part?: {
        /**
         * Unique identifier of the part
         */
        id: string;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    readonly quantity?: boolean;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    readonly price?: string;
    /**
     * Name of the article/part.
     */
    readonly name?: string;
    /**
     * The unit in which the positions part is measured
     */
    readonly unity?: {
        /**
         * Unique identifier of the unit
         */
        id: string;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Client to which invoice position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    readonly positionNumber?: string;
    /**
     * A text describing your position.
     */
    readonly text?: string;
    /**
     * An optional discount of the position.
     */
    readonly discount?: string;
    /**
     * Tax rate of the position.
     */
    readonly taxRate?: string;
    /**
     * Discount sum of the position
     */
    readonly sumDiscount?: string;
    /**
     * Net accounting sum of the position
     */
    readonly sumNetAccounting?: string;
    /**
     * Tax accounting sum of the position
     */
    readonly sumTaxAccounting?: string;
    /**
     * Gross accounting sum of the position
     */
    readonly sumGrossAccounting?: string;
    /**
     * Net price of the part
     */
    readonly priceNet?: string;
    /**
     * Gross price of the part
     */
    readonly priceGross?: string;
    /**
     * Tax on the price of the part
     */
    readonly priceTax?: string;
};

export type SaveInvoiceResponse = {
    invoice?: ModelInvoiceResponse;
    invoicePos?: Array<ModelInvoicePosResponse>;
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
};

/**
 * Create Invoice
 *
 * Invoice model
 */
export type ModelCreateInvoiceFromOrder = {
    /**
     * select the order for which you want to create the invoice
     */
    order: {
        /**
         * Unique identifier of the order
         */
        id: number;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * defines the type of amount
     */
    type?: 'percentage' | 'net' | 'gross';
    /**
     * Amount which has already been paid for this Invoice
     */
    amount?: number | null;
    /**
     * defines the type of the invoice
     * 1. RE - Schlussrechnung
     * 2. TR - Teilrechnung
     * 3. AR - Abschlagsrechnung
     */
    partialType?: 'RE' | 'TR' | 'AR';
};

/**
 * Email model
 *
 * Email model
 */
export type ModelEmail = {
    /**
     * The email id
     */
    readonly id?: number;
    /**
     * The email object name
     */
    readonly objectName?: string;
    /**
     * Date of mail creation
     */
    readonly create?: string;
    /**
     * Date of last mail update
     */
    readonly update?: string;
    object?: ModelInvoiceResponse;
    /**
     * The sender of the email
     */
    from: string;
    /**
     * The recipient of the email
     */
    to: string;
    /**
     * The subject of the email
     */
    subject: string;
    /**
     * The text of the email
     */
    text?: string | null;
    /**
     * Client to which mail belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * A list of mail addresses which are in the cc
     */
    cc?: string | null;
    /**
     * A list of mail addresses which are in the bcc
     */
    bcc?: string | null;
    /**
     * Date the mail arrived
     */
    arrived?: string | null;
};

/**
 * Layout model
 *
 * Layout model
 */
export type ModelChangeLayout = {
    /**
     * the type to be changed
     */
    key: 'language' | 'template' | 'letterpaper' | 'payPal';
    /**
     * the id/value of the template/letterpaper/language/payPal.
     */
    value: string;
};

/**
 * Layout model
 *
 * Layout model
 */
export type ModelChangeLayoutResponse = {
    result?: string;
    metadaten?: {
        /**
         * the number of pages in the document
         */
        pages?: number;
        /**
         * the id of the document
         */
        readonly docId?: string;
        /**
         * the pdf file
         */
        thumbs?: Array<{
            key?: string;
            name?: string;
            values?: Array<{
                name?: string;
                value?: string;
                translationCode?: string;
            }>;
        }>;
    };
};

/**
 * Order model
 *
 * Order model
 */
export type ModelOrderResponse = {
    /**
     * The order id
     */
    readonly id?: string;
    /**
     * The order object name
     */
    readonly objectName?: string;
    /**
     * Date of order creation
     */
    readonly create?: string;
    /**
     * Date of last order update
     */
    readonly update?: string;
    /**
     * The order number
     */
    orderNumber?: string;
    /**
     * The contact used in the order
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    orderDate?: string;
    /**
     * Please have a look in
     * <a href='#tag/Order/Types-and-status-of-orders'>status of orders</a>
     * to see what the different status codes mean
     */
    status?: '100' | '200' | '300' | '500' | '750' | '1000';
    /**
     * Normally consist of prefix plus the order number
     */
    header?: string;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: string;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Will be filled automatically by our system and can't be changed
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Client to which order belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Delivery terms of the order
     */
    deliveryTerms?: string | null;
    /**
     * Payment terms of the order
     */
    paymentTerms?: string | null;
    /**
     * Object from which the order was created. For example an offer.
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name of the object. Could be 'Order'.
         */
        objectName: string;
    } | null;
    /**
     * Version of the order.<br>
     * Can be used if you have multiple drafts for the same order.<br>
     * Should start with 0
     */
    version?: string;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the order must not contain any vat
     */
    smallSettlement?: boolean;
    /**
     * The user who acts as a contact person for the order
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: string;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the order. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the order.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string;
    /**
     * Type of the order. For more information on the different types, check
     * <a href='#tag/Order/Types-and-status-of-orders'>this</a>
     *
     */
    orderType?: 'AN' | 'AB' | 'LI';
    /**
     * The date the order was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the order. Needs to be currency code according to ISO-4217
     */
    currency?: string;
    /**
     * Net sum of the order
     */
    readonly sumNet?: string;
    /**
     * Tax sum of the order
     */
    readonly sumTax?: string;
    /**
     * Gross sum of the order
     */
    readonly sumGross?: string;
    /**
     * Sum of all discounts in the order
     */
    readonly sumDiscounts?: string;
    /**
     * Net sum of the order in the foreign currency
     */
    readonly sumNetForeignCurrency?: string;
    /**
     * Tax sum of the order in the foreign currency
     */
    readonly sumTaxForeignCurrency?: string;
    /**
     * Gross sum of the order in the foreign currency
     */
    readonly sumGrossForeignCurrency?: string;
    /**
     * Discounts sum of the order in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: string;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the order. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the order. IMPORTANT: Please refer to the order section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * Order model
 *
 * Order model
 */
export type ModelOrder = {
    /**
     * The order id
     */
    readonly id?: number;
    /**
     * The order object name
     */
    objectName?: string;
    mapAll: boolean;
    /**
     * Date of order creation
     */
    readonly create?: string;
    /**
     * Date of last order update
     */
    readonly update?: string;
    /**
     * The order number
     */
    orderNumber: string;
    /**
     * The contact used in the order
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    orderDate: string;
    /**
     * Please have a look in
     * <a href='#tag/Order/Types-and-status-of-orders'>status of orders</a>
     * to see what the different status codes mean
     */
    status: 100 | 200 | 300 | 500 | 750 | 1000;
    /**
     * Normally consist of prefix plus the order number
     */
    header: string;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Delivery terms of the order
     */
    deliveryTerms?: string | null;
    /**
     * Payment terms of the order
     */
    paymentTerms?: string | null;
    /**
     * Version of the order.<br>
     * Can be used if you have multiple drafts for the same order.<br>
     * Should start with 0
     */
    version: number;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the order must not contain any vat
     */
    smallSettlement?: boolean;
    /**
     * The user who acts as a contact person for the order
     */
    contactPerson: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate: number;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the order. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the order.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: string;
    /**
     * Type of the order. For more information on the different types, check
     * <a href='#tag/Order/Types-and-status-of-orders'>this</a>
     *
     */
    orderType?: 'AN' | 'AB' | 'LI';
    /**
     * The date the order was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the order. Needs to be currency code according to ISO-4217
     */
    currency: string;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the order. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the order. IMPORTANT: Please refer to the order section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
    /**
     * Object from which the order was created. For example an offer.
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name of the object. Could be 'Order'.
         */
        objectName: string;
    } | null;
};

/**
 * Order position model
 *
 * Order position model
 */
export type ModelOrderPos = {
    /**
     * The order position id
     */
    readonly id?: number;
    /**
     * The order position object name
     */
    readonly objectName?: string;
    /**
     * Date of order position creation
     */
    readonly create?: string;
    /**
     * Date of last order position update
     */
    readonly update?: string;
    /**
     * The order to which the position belongs.
     */
    order?: {
        /**
         * Unique identifier of the order
         */
        id: number;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: number;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Net price of the part
     */
    readonly priceNet?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Client to which order position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate: number;
    /**
     * Discount sum of the position
     */
    readonly sumDiscount?: number | null;
};

export type SaveOrder = {
    order: ModelOrder;
    orderPosSave?: Array<ModelOrderPos>;
    orderPosDelete?: {
        /**
         * Id of order position
         */
        id: number;
        /**
         * Object name of order position
         */
        objectName: string;
    };
};

/**
 * Order position model
 *
 * Order position model
 */
export type ModelOrderPosResponse = {
    /**
     * The order position id
     */
    readonly id?: string;
    /**
     * The order position object name
     */
    readonly objectName?: string;
    /**
     * Date of order position creation
     */
    readonly create?: string;
    /**
     * Date of last order position update
     */
    readonly update?: string;
    /**
     * The order to which the position belongs.
     */
    order?: {
        /**
         * Unique identifier of the order
         */
        id: string;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: string;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity?: string;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: string | null;
    /**
     * Net price of the part
     */
    readonly priceNet?: string | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: string | null;
    /**
     * Gross price of the part
     */
    priceGross?: string | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity?: {
        /**
         * Unique identifier of the unit
         */
        id: string;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Client to which order position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: string | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: string | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate?: string;
    /**
     * Discount sum of the position
     */
    readonly sumDiscount?: string | null;
};

export type SaveOrderResponse = {
    order?: ModelOrderResponse;
    orderPos?: Array<ModelOrderPosResponse>;
};

/**
 * Order model
 *
 * Order model
 */
export type ModelOrderUpdate = {
    /**
     * The order id
     */
    readonly id?: number;
    /**
     * The order object name
     */
    readonly objectName?: string;
    /**
     * Date of order creation
     */
    readonly create?: string;
    /**
     * Date of last order update
     */
    readonly update?: string;
    /**
     * The order number
     */
    orderNumber?: string;
    /**
     * The contact used in the order
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    orderDate?: string | null;
    /**
     * Please have a look in
     * <a href='#tag/Order/Types-and-status-of-orders'>status of orders</a>
     * to see what the different status codes mean
     */
    status?: 100 | 200 | 300 | 500 | 750 | 1000;
    /**
     * Normally consist of prefix plus the order number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Will be filled automatically by our system and can't be changed
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Client to which order belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Delivery terms of the order
     */
    deliveryTerms?: string | null;
    /**
     * Payment terms of the order
     */
    paymentTerms?: string | null;
    /**
     * Object from which the order was created. For example an offer.
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name of the object. Could be 'Order'.
         */
        objectName: string;
    } | null;
    /**
     * Version of the order.<br>
     * Can be used if you have multiple drafts for the same order.<br>
     * Should start with 0
     */
    version?: number | null;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the order must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the order
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the order. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string | null;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the order.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * Type of the order. For more information on the different types, check
     * <a href='#tag/Order/Types-and-status-of-orders'>this</a>
     *
     */
    orderType?: 'AN' | 'AB' | 'LI';
    /**
     * The date the order was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the order. Needs to be currency code according to ISO-4217
     */
    currency?: string | null;
    /**
     * Net sum of the order
     */
    readonly sumNet?: number;
    /**
     * Tax sum of the order
     */
    readonly sumTax?: number;
    /**
     * Gross sum of the order
     */
    readonly sumGross?: number;
    /**
     * Sum of all discounts in the order
     */
    readonly sumDiscounts?: number;
    /**
     * Net sum of the order in the foreign currency
     */
    readonly sumNetForeignCurrency?: number;
    /**
     * Tax sum of the order in the foreign currency
     */
    readonly sumTaxForeignCurrency?: number;
    /**
     * Gross sum of the order in the foreign currency
     */
    readonly sumGrossForeignCurrency?: number;
    /**
     * Discounts sum of the order in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: number;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the order. Otherwise gross amount
     */
    showNet?: boolean | null;
    /**
     * Type which was used to send the order. IMPORTANT: Please refer to the order section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * Discounts
 *
 * Discount model
 */
export type ModelDiscount = {
    /**
     * the id of the discount
     */
    readonly id?: string;
    /**
     * Model name, which is 'Discounts'
     */
    readonly objectName?: string;
    /**
     * Date of discount creation
     */
    readonly create?: string;
    /**
     * Date of last discount update
     */
    readonly update?: string;
    /**
     * The order used for the discount
     */
    readonly object?: {
        /**
         * Unique identifier of the order
         */
        id: string;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    readonly sevClient?: string;
    /**
     * A text describing your position.
     */
    readonly text?: string;
    /**
     * Defines if this is a percentage or an absolute discount
     */
    percentage?: string;
    /**
     * Value of the discount
     */
    value?: string;
    /**
     * Defines is the Discount net or gross
     * 0 - gross
     * 1 - net
     */
    isNet?: string;
};

/**
 * Email model
 *
 * Email model
 */
export type ModelEmailOrder = {
    /**
     * The email id
     */
    readonly id?: number;
    /**
     * The email object name
     */
    readonly objectName?: string;
    /**
     * Date of mail creation
     */
    readonly create?: string;
    /**
     * Date of last mail update
     */
    readonly update?: string;
    object?: ModelOrderResponse;
    /**
     * The sender of the email
     */
    from: string;
    /**
     * The recipient of the email
     */
    to: string;
    /**
     * The subject of the email
     */
    subject: string;
    /**
     * The text of the email
     */
    text?: string | null;
    /**
     * Client to which mail belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * A list of mail addresses which are in the cc
     */
    cc?: string | null;
    /**
     * A list of mail addresses which are in the bcc
     */
    bcc?: string | null;
    /**
     * Date the mail arrived
     */
    arrived?: string | null;
};

/**
 * Create packing list
 *
 * order model
 */
export type ModelCreatePackingListFromOrder = {
    /**
     * Unique identifier of the order
     */
    id: number;
    /**
     * Model name, which is 'Order'
     */
    objectName: string;
};

/**
 * Order position model
 *
 * Order position model
 */
export type ModelOrderPosUpdate = {
    /**
     * The order position id
     */
    readonly id?: number;
    /**
     * The order position object name
     */
    readonly objectName?: string;
    /**
     * Date of order position creation
     */
    readonly create?: string;
    /**
     * Date of last order position update
     */
    readonly update?: string;
    /**
     * The order to which the position belongs.
     */
    order?: {
        /**
         * Unique identifier of the order
         */
        id: number;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity?: number | null;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Net price of the part
     */
    readonly priceNet?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity?: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Client to which order position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate?: number | null;
    /**
     * Discount sum of the position
     */
    readonly sumDiscount?: number | null;
};

/**
 * Voucher model
 *
 * Voucher model
 */
export type ModelVoucher = {
    /**
     * The voucher id
     */
    readonly id?: number;
    /**
     * The voucher object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * Date of voucher creation
     */
    readonly create?: string;
    /**
     * Date of last voucher update
     */
    readonly update?: string;
    /**
     * Client to which voucher belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * User who created the voucher. Will be filled automatically.
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    voucherDate?: string | null;
    /**
     * The contact used in the voucher as a supplier.<br>
     * If you don't have a contact as a supplier, you can set this object to null.
     */
    supplier?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The supplier name.<br>
     * The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier.
     */
    supplierName?: string | null;
    /**
     * The description of the voucher. Essentially the voucher number.
     */
    description?: string | null;
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * Please have a look in
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>status of vouchers</a>
     * to see what the different status codes mean
     */
    status: 50 | 100 | 1000;
    /**
     * Net sum of the voucher
     */
    readonly sumNet?: number;
    /**
     * Tax sum of the voucher
     */
    readonly sumTax?: number;
    /**
     * Gross sum of the voucher
     */
    readonly sumGross?: number;
    /**
     * Net accounting sum of the voucher. Is usually the same as sumNet
     */
    readonly sumNetAccounting?: number;
    /**
     * Tax accounting sum of the voucher. Is usually the same as sumTax
     */
    readonly sumTaxAccounting?: number;
    /**
     * Gross accounting sum of the voucher. Is usually the same as sumGross
     */
    readonly sumGrossAccounting?: number;
    /**
     * Sum of all discounts in the voucher
     */
    readonly sumDiscounts?: number;
    /**
     * Discounts sum of the voucher in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: number;
    /**
     * Amount which has already been paid for this voucher by the customer
     */
    readonly paidAmount?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     */
    taxRule: {
        /**
         * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
         *
         * Defines the vat-regulation.
         * For "Regelbesteuerung" it can be one of:
         * - `1` - Umsatzsteuerpflichtige Umstze (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "default"`
         * - `2` - Ausfuhren (tax rates: 0.0)
         * - `3` - Innergemeinschaftliche Lieferungen (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "eu"`
         * - `4` - Steuerfreie Umstze 4 UStG (tax rates: 0.0)
         * - `5` - Reverse Charge gem. 13b UStG (tax rates: 0.0)
         *
         * For small business owner ("Kleinunternehmer") it can be:
         * - `11` - Steuer nicht erhoben nach 19UStG (tax rates: 0.0) - replaces `"taxType": "ss"`
         */
        id: '1' | '2' | '3' | '4' | '5' | '11';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the voucher.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: string;
    /**
     * Defines if your voucher is a credit (C) or debit (D)
     */
    creditDebit: 'C' | 'D';
    /**
     * Type of the voucher. For more information on the different types, check
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>this</a>
     *
     */
    voucherType: 'VOU' | 'RV';
    /**
     * specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred
     */
    currency?: string | null;
    /**
     * Defines the exchange rate day and and then the exchange rate is set from sevdesk. Needs to be provided as timestamp or dd.mm.yyyy
     */
    propertyForeignCurrencyDeadline?: string | null;
    /**
     * Defines the exchange rate
     */
    propertyExchangeRate?: number | null;
    /**
     * The DateInterval in which recurring vouchers are generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringInterval?: 'P0Y0M1W' | 'P0Y0M2W' | 'P0Y1M0W' | 'P0Y3M0W' | 'P0Y6M0W' | 'P1Y0M0W' | 'P2Y0M0W' | 'P3Y0M0W' | 'P4Y0M0W' | 'P5Y0M0W';
    /**
     * The date when the recurring vouchers start being generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    readonly recurringStartDate?: string | null;
    /**
     * The date when the next voucher should be generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    readonly recurringNextVoucher?: string | null;
    /**
     * The date when the last voucher was generated.
     */
    readonly recurringLastVoucher?: string | null;
    /**
     * The date when the recurring vouchers end being generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    readonly recurringEndDate?: string | null;
    /**
     * Enshrined vouchers cannot be changed. Can only be set via [Voucher/{voucherId}/enshrine](#tag/Voucher/operation/voucherEnshrine). This operation cannot be undone.
     */
    readonly enshrined?: string;
    /**
     * ** Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * Tax set of the voucher. Needs to be added if you chose the taxType=custom.
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Payment deadline of the voucher.
     */
    paymentDeadline?: string | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDate?: string;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDateUntil?: string | null;
    /**
     * The document of the voucher.
     */
    document?: {
        /**
         * Unique identifier of the document
         */
        id: number;
        /**
         * Model name, which is 'Document'
         */
        objectName: string;
    } | null;
    /**
     * Cost centre for the voucher
     */
    costCentre?: {
        /**
         * Unique identifier of the cost centre
         */
        id: number;
        /**
         * Model name, which is 'CostCentre'
         */
        objectName: string;
    };
};

/**
 * VoucherPos model
 *
 * Voucher position model
 */
export type ModelVoucherPos = {
    /**
     * The voucher position id
     */
    readonly id?: number;
    /**
     * The voucher position object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * Date of voucher position creation
     */
    readonly create?: string;
    /**
     * Date of last voucher position update
     */
    readonly update?: string;
    /**
     * Client to which voucher position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * The voucher to which the position belongs.
     */
    readonly voucher: {
        /**
         * Unique identifier of the voucher
         */
        id: number;
        /**
         * Model name, which is 'Voucher'
         */
        objectName: string;
    };
    /**
     * <b>Use this in sevdesk-Update 2.0 (replaces accountingType).</b>
     * The account datev to which the position belongs.<br>
     * An account datev is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Account-Datev'>this</a> section.
     */
    accountDatev: {
        /**
         * Unique identifier of the account datev
         */
        id: number;
        /**
         * Model name, which is 'AccountDatev'
         */
        objectName: string;
    };
    /**
     * The accounting type to which the position belongs.<br>
     * An accounting type is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Accounting-type'>this</a> section.
     */
    accountingType: {
        /**
         * Unique identifier of the accounting type
         */
        id: number;
        /**
         * Model name, which is 'AccountingType'
         */
        objectName: string;
    };
    /**
     * The accounting type to which the position belongs estimated by our voucher recognition.<br>
     * An accounting type is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Accounting-type'>this</a> section.
     */
    readonly estimatedAccountingType?: {
        /**
         * Unique identifier of the accounting type
         */
        id: number;
        /**
         * Model name, which is 'AccountingType'
         */
        objectName: string;
    };
    /**
     * Tax rate of the voucher position.
     */
    taxRate: number;
    /**
     * Determines whether 'sumNet' or 'sumGross' is regarded.<br>
     * If both are not given, 'sum' is regarded and treated as net or gross depending on 'net'.
     * All positions must be either net or gross, a mixture of the two is not possible.
     */
    net: boolean;
    /**
     * Determines whether position is regarded as an asset which can be depreciated.
     */
    isAsset?: boolean;
    /**
     * Net sum of the voucher position.<br>
     * Only regarded if 'net' is 'true', otherwise its readOnly.
     */
    sumNet: number;
    /**
     * Tax sum of the voucher position.
     */
    readonly sumTax?: number;
    /**
     * Gross sum of the voucher position.<br>
     * Only regarded if 'net' is 'false', otherwise its readOnly.
     */
    sumGross: number;
    /**
     * Net accounting sum. Is equal to sumNet.
     */
    readonly sumNetAccounting?: number;
    /**
     * Tax accounting sum. Is equal to sumTax.
     */
    readonly sumTaxAccounting?: number;
    /**
     * Gross accounting sum. Is equal to sumGross.
     */
    readonly sumGrossAccounting?: number;
    /**
     * Comment for the voucher position.
     */
    comment?: string | null;
};

export type SaveVoucher = {
    voucher: ModelVoucher;
    voucherPosSave?: Array<ModelVoucherPos>;
    voucherPosDelete?: {
        /**
         * Id of voucher position
         */
        id: number;
        /**
         * Object name of voucher position
         */
        objectName: string;
    };
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
};

/**
 * Voucher model
 *
 * Voucher model
 */
export type ModelVoucherResponse = {
    /**
     * The voucher id
     */
    readonly id?: string;
    /**
     * The voucher object name
     */
    readonly objectName?: string;
    mapAll?: boolean;
    /**
     * Date of voucher creation
     */
    readonly create?: string;
    /**
     * Date of last voucher update
     */
    readonly update?: string;
    /**
     * Client to which voucher belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * User who created the voucher. Will be filled automatically.
     */
    readonly createUser?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    voucherDate?: string | null;
    /**
     * The contact used in the voucher as a supplier.<br>
     * If you don't have a contact as a supplier, you can set this object to null.
     */
    supplier?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The supplier name.<br>
     * The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier.
     */
    supplierName?: string | null;
    /**
     * The description of the voucher. Essentially the voucher number.
     */
    description?: string | null;
    /**
     * The document of the voucher.
     */
    document?: {
        /**
         * Unique identifier of the document
         */
        id: string;
        /**
         * Model name, which is 'Document'
         */
        objectName: string;
    } | null;
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * Please have a look in
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>status of vouchers</a>
     * to see what the different status codes mean
     */
    status?: '50' | '100' | '1000';
    /**
     * Net sum of the voucher
     */
    readonly sumNet?: string;
    /**
     * Tax sum of the voucher
     */
    readonly sumTax?: string;
    /**
     * Gross sum of the voucher
     */
    readonly sumGross?: string;
    /**
     * Net accounting sum of the voucher. Is usually the same as sumNet
     */
    readonly sumNetAccounting?: string;
    /**
     * Tax accounting sum of the voucher. Is usually the same as sumTax
     */
    readonly sumTaxAccounting?: string;
    /**
     * Gross accounting sum of the voucher. Is usually the same as sumGross
     */
    readonly sumGrossAccounting?: string;
    /**
     * Sum of all discounts in the voucher
     */
    readonly sumDiscounts?: string;
    /**
     * Discounts sum of the voucher in the foreign currency
     */
    readonly sumDiscountsForeignCurrency?: string;
    /**
     * Amount which has already been paid for this voucher by the customer
     */
    readonly paidAmount?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     */
    taxRule?: {
        /**
         * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
         *
         * Defines the vat-regulation.
         * For "Regelbesteuerung" it can be one of:
         * - `1` - Umsatzsteuerpflichtige Umstze (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "default"`
         * - `2` - Ausfuhren (tax rates: 0.0)
         * - `3` - Innergemeinschaftliche Lieferungen (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "eu"`
         * - `4` - Steuerfreie Umstze 4 UStG (tax rates: 0.0)
         * - `5` - Reverse Charge gem. 13b UStG (tax rates: 0.0)
         *
         * For small business owner ("Kleinunternehmer") it can be:
         * - `11` - Steuer nicht erhoben nach 19UStG (tax rates: 0.0) - replaces `"taxType": "ss"`
         */
        id: '1' | '2' | '3' | '4' | '5' | '11';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the voucher.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * Defines if your voucher is a credit (C) or debit (D)
     */
    creditDebit?: 'C' | 'D';
    /**
     * Cost centre for the voucher
     */
    costCentre?: {
        /**
         * Unique identifier of the cost centre
         */
        id: string;
        /**
         * Model name, which is 'CostCentre'
         */
        objectName: string;
    };
    /**
     * Type of the voucher. For more information on the different types, check
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>this</a>
     *
     */
    voucherType?: 'VOU' | 'RV';
    /**
     * specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred
     */
    currency?: string | null;
    /**
     * Defines the exchange rate day and and then the exchange rate is set from sevdesk. Needs to be provided as timestamp or dd.mm.yyyy
     */
    propertyForeignCurrencyDeadline?: string | null;
    /**
     * Defines the exchange rate
     */
    propertyExchangeRate?: string | null;
    /**
     * The DateInterval in which recurring vouchers are generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringInterval?: 'P0Y0M1W' | 'P0Y0M2W' | 'P0Y1M0W' | 'P0Y3M0W' | 'P0Y6M0W' | 'P1Y0M0W' | 'P2Y0M0W' | 'P3Y0M0W' | 'P4Y0M0W' | 'P5Y0M0W';
    /**
     * The date when the recurring vouchers start being generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringStartDate?: string | null;
    /**
     * The date when the next voucher should be generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringNextVoucher?: string | null;
    /**
     * The date when the last voucher was generated.
     */
    recurringLastVoucher?: string | null;
    /**
     * The date when the recurring vouchers end being generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringEndDate?: string | null;
    /**
     * Enshrined vouchers cannot be changed. Can only be set via [Voucher/{voucherId}/enshrine](#tag/Voucher/operation/voucherEnshrine). This operation cannot be undone.
     */
    readonly enshrined?: string;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * Tax set of the voucher. Needs to be added if you chose the taxType=custom.
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Payment deadline of the voucher.
     */
    paymentDeadline?: string | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDate?: string;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDateUntil?: string | null;
};

/**
 * VoucherPos model
 *
 * Voucher position model
 */
export type ModelVoucherPosResponse = {
    /**
     * The voucher position id
     */
    readonly id?: string;
    /**
     * The voucher position object name
     */
    readonly objectName?: string;
    /**
     * Date of voucher position creation
     */
    readonly create?: string;
    /**
     * Date of last voucher position update
     */
    readonly update?: string;
    /**
     * Client to which voucher position belongs. Will be filled automatically
     */
    readonly sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * The voucher to which the position belongs.
     */
    readonly voucher: {
        /**
         * Unique identifier of the voucher
         */
        id: string;
        /**
         * Model name, which is 'Voucher'
         */
        objectName: string;
    };
    /**
     * <b>Use this in sevdesk-Update 2.0 (replaces accountingType).</b>
     * The account datev to which the position belongs.<br>
     * An account datev is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Account-Datev'>this</a> section.
     */
    accountDatev: {
        /**
         * Unique identifier of the account datev
         */
        id: number;
        /**
         * Model name, which is 'AccountDatev'
         */
        objectName: string;
    };
    /**
     * The accounting type to which the position belongs.<br>
     * An accounting type is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Accounting-type'>this</a> section.
     */
    accountingType: {
        /**
         * Unique identifier of the accounting type
         */
        id: string;
        /**
         * Model name, which is 'AccountingType'
         */
        objectName: string;
    };
    /**
     * The accounting type to which the position belongs estimated by our voucher recognition.<br>
     * An accounting type is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Accounting-type'>this</a> section.
     */
    readonly estimatedAccountingType?: {
        /**
         * Unique identifier of the accounting type
         */
        id: string;
        /**
         * Model name, which is 'AccountingType'
         */
        objectName: string;
    };
    /**
     * Tax rate of the voucher position.
     */
    taxRate: string;
    /**
     * Determines whether 'sumNet' or 'sumGross' is regarded.<br>
     * If both are not given, 'sum' is regarded and treated as net or gross depending on 'net'.
     * All positions must be either net or gross, a mixture of the two is not possible.
     */
    net: boolean;
    /**
     * Determines whether position is regarded as an asset which can be depreciated.
     */
    isAsset?: boolean;
    /**
     * Net sum of the voucher position.<br>
     * Only regarded if 'net' is 'true', otherwise its readOnly.
     */
    sumNet: string;
    /**
     * Tax sum of the voucher position.
     */
    readonly sumTax?: string;
    /**
     * Gross sum of the voucher position.<br>
     * Only regarded if 'net' is 'false', otherwise its readOnly.
     */
    sumGross: string;
    /**
     * Net accounting sum. Is equal to sumNet.
     */
    readonly sumNetAccounting?: string;
    /**
     * Tax accounting sum. Is equal to sumTax.
     */
    readonly sumTaxAccounting?: string;
    /**
     * Gross accounting sum. Is equal to sumGross.
     */
    readonly sumGrossAccounting?: string;
    /**
     * Comment for the voucher position.
     */
    comment?: string | null;
};

export type SaveVoucherResponse = {
    voucher?: ModelVoucherResponse;
    voucherPos?: Array<ModelVoucherPosResponse>;
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
};

/**
 * Voucher model
 *
 * Voucher model
 */
export type ModelVoucherUpdate = {
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    voucherDate?: string | null;
    /**
     * The contact used in the voucher as a supplier.<br>
     * If you don't have a contact as a supplier, you can set this object to null.
     */
    supplier?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The supplier name.<br>
     * The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier.
     */
    supplierName?: string | null;
    /**
     * The description of the voucher. Essentially the voucher number.
     */
    description?: string | null;
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * <b>Not supported in sevdesk-Update 2.0.</b><br><br>    Please have a look in <a href='#tag/Voucher/Types-and-status-of-vouchers'>status of vouchers</a>    to see what the different status codes mean
     */
    status?: 50 | 100 | 1000;
    /**
     * Amount which has already been paid for this voucher by the customer
     */
    readonly paidAmount?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     */
    taxRule?: {
        /**
         * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
         *
         * Defines the vat-regulation.
         * For "Regelbesteuerung" it can be one of:
         * - `1` - Umsatzsteuerpflichtige Umstze (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "default"`
         * - `2` - Ausfuhren (tax rates: 0.0)
         * - `3` - Innergemeinschaftliche Lieferungen (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "eu"`
         * - `4` - Steuerfreie Umstze 4 UStG (tax rates: 0.0)
         * - `5` - Reverse Charge gem. 13b UStG (tax rates: 0.0)
         *
         * For small business owner ("Kleinunternehmer") it can be:
         * - `11` - Steuer nicht erhoben nach 19UStG (tax rates: 0.0) - replaces `"taxType": "ss"`
         */
        id: '1' | '2' | '3' | '4' | '5' | '11';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the voucher.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string;
    /**
     * Defines if your voucher is a credit (C) or debit (D)
     */
    creditDebit?: 'C' | 'D';
    /**
     * Type of the voucher. For more information on the different types, check
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>this</a>
     *
     */
    voucherType?: 'VOU' | 'RV';
    /**
     * specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred
     */
    currency?: string | null;
    /**
     * Defines the exchange rate day and and then the exchange rate is set from sevdesk. Needs to be provided as timestamp or dd.mm.yyyy
     */
    propertyForeignCurrencyDeadline?: string | null;
    /**
     * Defines the exchange rate
     */
    propertyExchangeRate?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * Tax set of the voucher. Needs to be added if you chose the taxType=custom.
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Payment deadline of the voucher.
     */
    paymentDeadline?: string | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDate?: string;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDateUntil?: string | null;
    /**
     * The document of the voucher.
     */
    document?: {
        /**
         * Unique identifier of the document
         */
        id: number;
        /**
         * Model name, which is 'Document'
         */
        objectName: string;
    } | null;
    /**
     * Cost centre for the voucher
     */
    costCentre?: {
        /**
         * Unique identifier of the cost centre
         */
        id: number;
        /**
         * Model name, which is 'CostCentre'
         */
        objectName: string;
    };
};

/**
 * ReceiptGuide Data Transfer Object
 *
 * Model holds data about a single selectable account with additional information matching to that account.
 */
export type ReceiptGuideDto = {
    /**
     * The ID of the matching account datev
     */
    accountDatevId?: number;
    /**
     * The account number of the account datev (dependent on the active accounting system of the client)
     */
    accountNumber?: string;
    /**
     * The name of the account
     */
    accountName?: string;
    /**
     * The description of the account and/or what the account is used for
     */
    description?: string;
    /**
     * An array that holds all possible tax rules for this account
     */
    allowedTaxRules?: Array<{
        /**
         * The name of the tax rule
         */
        name?: string;
        /**
         * A readable description of the tax rule
         */
        description?: string;
        /**
         * The id of the tax rule to use in different scenarios
         */
        id?: number;
        /**
         * An array of tax rates which are combinable with this tax rule
         */
        taxRates?: Array<string>;
    }>;
    /**
     * An array that holds the viable receipt types for this account
     */
    allowedReceiptTypes?: Array<string>;
};

/**
 * Tag model
 *
 * tag model
 */
export type ModelTagResponse = {
    /**
     * Id of the tag
     */
    readonly id?: string;
    /**
     * Internal object name which is 'Tag'.
     */
    readonly objectName?: string;
    additionalInformation?: string;
    /**
     * Date of tag creation
     */
    readonly create?: string;
    /**
     * name of the tag
     */
    readonly name?: string;
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

/**
 * Tag model
 *
 * tag model
 */
export type ModelTagCreateResponse = {
    /**
     * Id of the tag
     */
    readonly id?: string;
    /**
     * Internal object name which is 'TagRelation'.
     */
    readonly objectName?: string;
    additionalInformation?: string;
    /**
     * Date of tag creation
     */
    readonly create?: string;
    /**
     * The tag information
     */
    tag?: {
        /**
         * Unique identifier of the tag
         */
        id: string;
        /**
         * Model name, which is 'Tag'
         */
        objectName: string;
    };
    object?: {
        /**
         * Id of the invoice/order/voucher/creditNote
         */
        id: number;
        /**
         * Model name
         */
        objectName: 'Invoice' | 'Voucher' | 'Order' | 'CreditNote';
    };
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

/**
 * CheckAccount model
 *
 * CheckAccount model. Responsible for the payment accounts.
 */
export type ModelCheckAccountResponseWritable = {
    /**
     * Name of the check account
     */
    name?: string;
    /**
     * The IBAN of the account
     */
    iban?: string | null;
    /**
     * The type of the check account. Account with a CSV or MT940 import are regarded as online.
     */
    type?: 'online' | 'offline' | 'register';
    /**
     * Import type, for accounts that are type "online" but not connected to a data provider.
     */
    importType?: 'CSV' | 'MT940' | null;
    /**
     * The currency of the check account.
     */
    currency?: string;
    /**
     * Defines if this check account is the default account.
     */
    defaultAccount?: string;
    /**
     * This will be 1 if the account is your base account that comes with every sevdesk setup.
     */
    baseAccount?: string;
    /**
     * Defines the sorting of accounts, highest is first.
     */
    priority?: string;
    /**
     * Status of the check account. 0 <-> Archived - 100 <-> Active
     */
    status?: '0' | '100';
    /**
     * The account balance as reported by PayPal or finAPI. Not set for other types of accounts.
     */
    balance?: string | null;
    /**
     * Bank server of check account, only set if the account is connected to a data provider
     */
    bankServer?: string | null;
    /**
     * Defines if transactions on this account are automatically mapped to invoice and vouchers when imported if possible.
     */
    autoMapTransactions?: string | null;
    /**
     * If this is 1 the account will be automatically updated through PayPal or finAPI. Only applicable for connected online accounts.
     */
    autoSyncTransactions?: string;
    /**
     * Timepoint of the last payment import through PayPal or finAPI.
     */
    lastSync?: string;
    /**
     * The booking account used for this account, e.g. 1800 in SKR04 and 1200 in SKR03. Must be unique among all your CheckAccounts.
     */
    accountingNumber?: string;
};

/**
 * CheckAccountTransaction model
 *
 * CheckAccountTransaction model. Responsible for the transactions on payment accounts.
 */
export type ModelCheckAccountTransactionResponseWritable = {
    /**
     * Date the check account transaction was imported
     */
    valueDate?: string;
    /**
     * Date the check account transaction was booked
     */
    entryDate?: string | null;
    /**
     * The purpose of the transaction
     */
    paymtPurpose?: string | null;
    /**
     * Amount of the transaction
     */
    amount?: string;
    /**
     * Name of the other party
     */
    payeePayerName?: string | null;
    /**
     * IBAN or account number of the other party
     */
    payeePayerAcctNo?: string | null;
    /**
     * BIC or bank code of the other party
     */
    payeePayerBankCode?: string | null;
    /**
     * ZKA business transaction code. This can be given for finAPI accounts.
     */
    gvCode?: string | null;
    /**
     * Transaction type, according to the bank. This can be given for finAPI accounts.
     */
    entryText?: string | null;
    /**
     * Transaction primanota. This can be given for finAPI accounts.
     */
    primaNotaNo?: string | null;
};

/**
 * CheckAccountTransaction model
 *
 * CheckAccountTransaction model. Responsible for the transactions on payment accounts.
 */
export type ModelCheckAccountTransactionWritable = {
    /**
     * Date the check account transaction was booked
     */
    valueDate: string;
    /**
     * Date the check account transaction was imported
     */
    entryDate?: string | null;
    /**
     * The purpose of the transaction
     */
    paymtPurpose?: string | null;
    /**
     * Amount of the transaction
     */
    amount: number;
    /**
     * Name of the other party
     */
    payeePayerName: string | null;
    /**
     * IBAN or account number of the other party
     */
    payeePayerAcctNo?: string | null;
    /**
     * BIC or bank code of the other party
     */
    payeePayerBankCode?: string | null;
    /**
     * The check account to which the transaction belongs
     */
    checkAccount: {
        /**
         * Unique identifier of the check account
         */
        id: number;
        /**
         * Model name, which is 'CheckAccount'
         */
        objectName: string;
    };
    /**
     * Status of the check account transaction.<br>
     * 100 <-> Created<br>
     * 200 <-> Linked<br>
     * 300 <-> Private<br>
     * 400 <-> Booked
     */
    status: 100 | 200 | 300 | 400;
    /**
     * The check account transaction serving as the source of the rebooking
     */
    sourceTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: number;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    } | null;
    /**
     * The check account transaction serving as the target of the rebooking
     */
    targetTransaction?: {
        /**
         * Unique identifier of the check account transaction
         */
        id: number;
        /**
         * Model name, which is 'CheckAccountTransaction'
         */
        objectName: string;
    } | null;
};

/**
 * Contact model
 *
 * Contact model
 */
export type ModelContactResponseWritable = {
    [key: string]: unknown;
};

/**
 * Contact address
 *
 * ContactAddress model
 */
export type ModelContactAddressResponseWritable = {
    /**
     * The contact to which this contact address belongs.
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Street name
     */
    street?: string | null;
    /**
     * Zib code
     */
    zip?: string | null;
    /**
     * City name
     */
    city?: string | null;
    /**
     * Country of the contact address.<br>
     * For all countries, send a GET to /StaticCountry
     */
    country: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Category of the contact address.<br>
     * For all categories, send a GET to /Category?objectType=ContactAddress.
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * Name in address
     */
    name?: string | null;
    /**
     * Second name in address
     */
    name2?: string;
    /**
     * Third name in address
     */
    name3?: string | null;
    /**
     * Fourth name in address
     */
    name4?: string | null;
};

/**
 * Contact address
 *
 * ContactAddress model
 */
export type ModelContactAddressWritable = {
    /**
     * The contact to which this contact address belongs.
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Street name
     */
    street?: string | null;
    /**
     * Zib code
     */
    zip?: string | null;
    /**
     * City name
     */
    city?: string | null;
    /**
     * Country of the contact address.<br>
     * For all countries, send a GET to /StaticCountry
     */
    country: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Category of the contact address.<br>
     * For all categories, send a GET to /Category?objectType=ContactAddress.
     */
    category: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * Name in address
     */
    name?: string | null;
    /**
     * Second name in address
     */
    name2?: string;
    /**
     * Third name in address
     */
    name3?: string | null;
    /**
     * Fourth name in address
     */
    name4?: string | null;
};

/**
 * CommunicationWay model
 *
 * Contact communication way model
 */
export type ModelCommunicationWayResponseWritable = {
    [key: string]: unknown;
};

/**
 * CommunicationWay model
 *
 * Contact communication way model
 */
export type ModelCommunicationWayWritable = {
    /**
     * The contact to which this communication way belongs.
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Type of the communication way
     */
    type: 'EMAIL' | 'PHONE' | 'WEB' | 'MOBILE';
    /**
     * The value of the communication way.<br>
     * For example the phone number, e-mail address or website.
     */
    value: string;
    /**
     * The key of the communication way.<br>
     * Similar to the category of addresses.<br>
     * For all communication way keys please send a GET to /CommunicationWayKey.
     */
    key: {
        /**
         * Unique identifier of the key
         */
        id: number;
        /**
         * Model name, which is 'CommunicationWayKey'
         */
        objectName: string;
    };
    /**
     * Defines whether the communication way is the main communication way for the contact.
     */
    main?: boolean | null;
};

/**
 * AccountingContact model
 *
 * Accounting contact model
 */
export type ModelAccountingContactResponseWritable = {
    [key: string]: unknown;
};

/**
 * contact fields model
 *
 * contact fields model
 */
export type ModelContactCustomFieldSettingResponseWritable = unknown;

/**
 * contact fields model
 *
 * contact fields model
 */
export type ModelContactCustomFieldResponseWritable = {
    /**
     * id of the contact field
     */
    id?: string;
    /**
     * Internal object name which is 'ContactCustomField'.
     */
    objectName?: string;
    /**
     * Date of contact field creation
     */
    create?: string;
    /**
     * Date of contact field update
     */
    update?: string;
    /**
     * Client to which contact field belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
    /**
     * name of the contact
     */
    contact?: {
        /**
         * Unique identifier of contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * the contact custom field setting
     */
    contactCustomFieldSetting?: ModelContactCustomFieldSettingResponseWritable;
    /**
     * The value of the contact field
     */
    value?: string;
};

/**
 * creditNote model
 *
 * creditNote model
 */
export type ModelCreditNoteResponseWritable = {
    /**
     * The creditNote number
     */
    creditNoteNumber?: string | null;
    /**
     * The contact used in the creditNote
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The credit note date
     */
    creditNoteDate?: string;
    /**
     * Please have a look in
     * <a href='#tag/CreditNote/Status-of-credit-notes'>status of credit note</a>
     * to see what the different status codes mean
     */
    status?: '100' | '200' | '750' | '1000';
    /**
     * Normally consist of prefix plus the creditNote number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: string;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil
     */
    deliveryDate?: string;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the creditNote must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the creditNote
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    } | null;
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: string | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the creditNote. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string | null;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the creditNote.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * The date the creditNote was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the creditNote. Needs to be currency code according to ISO-4217
     */
    currency?: string | null;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * creditNote model
 *
 * creditNote model
 */
export type ModelCreditNoteWritable = {
    /**
     * The creditNote id. <span style='color:red'>Required</span> if you want to create/update an credit note position for an existing credit note"
     */
    id?: number;
    /**
     * The creditNote object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * The creditNote number
     */
    creditNoteNumber: string;
    /**
     * The contact used in the creditNote
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    creditNoteDate: string;
    /**
     * Please have a look in
     * <a href='#tag/CreditNote/Status-of-credit-notes'>status of credit note</a>
     * to see what the different status codes mean
     */
    status: '100' | '200' | '300' | '500' | '750' | '1000';
    /**
     * Normally consist of prefix plus the creditNote number
     */
    header: string;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the creditNote must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the creditNote
     */
    contactPerson: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate: number;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the creditNote. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the creditNote.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: string;
    /**
     * The date the creditNote was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Defines the booking category, for more information see the section [Credit note booking categories](#tag/CreditNote/Credit-note-booking-categories)
     *
     * The booking category of the credit note.
     *
     * **<code>ACCOUNTING_TYPE</code> is currently not supported in sevdesk-Update 2.0.**
     */
    bookingCategory: 'PROVISION' | 'ROYALTY_ASSIGNED' | 'ROYALTY_UNASSIGNED' | 'UNDERACHIEVEMENT' | 'ACCOUNTING_TYPE';
    /**
     * Currency used in the creditNote. Needs to be currency code according to ISO-4217
     */
    currency: string;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * creditNote position model
 *
 * creditNote position model
 */
export type ModelCreditNotePosWritable = {
    /**
     * The creditNote position object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * The creditNote to which the position belongs.  <span style='color:red'>Required</span> if you want to create/update an credit note position for an existing credit note"
     */
    creditNote?: {
        /**
         * Unique identifier of the creditNote
         */
        id: number;
        /**
         * Model name, which is 'creditNote'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: number;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to creditNote multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate: number;
};

export type SaveCreditNoteWritable = {
    creditNote: ModelCreditNoteWritable;
    creditNotePosSave?: Array<ModelCreditNotePosWritable>;
    creditNotePosDelete?: {
        /**
         * Id of credit note position
         */
        id: number;
        /**
         * Object name of credit note position
         */
        objectName: string;
    };
    discountSave?: {
        /**
         * Defines if this is a discount or a surcharge
         */
        discount: boolean;
        /**
         * A text for your discount
         */
        text: string;
        /**
         * Defines if this is a percentage or an absolute discount
         */
        percentage: boolean;
        /**
         * Value of the discount
         */
        value: number;
        /**
         * Object name of the discount
         */
        objectName: string;
        /**
         * Internal param
         */
        mapAll: boolean;
    };
    discountDelete?: {
        /**
         * ID of discount to delete
         */
        id: number;
        /**
         * Object name of discount
         */
        objectName: string;
    };
};

/**
 * creditNote position model
 *
 * creditNote position model
 */
export type ModelCreditNotePosResponseWritable = {
    /**
     * The creditNote to which the position belongs.
     */
    creditNote: {
        /**
         * Unique identifier of the creditNote
         */
        id: string;
        /**
         * Model name, which is 'creditNote'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: string;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: string;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: string | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: string | null;
    /**
     * Gross price of the part
     */
    priceGross?: string | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: string;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to creditNote multiple positions.
     */
    positionNumber?: string | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: string | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate: string;
};

export type SaveCreditNoteResponseWritable = {
    creditNote?: ModelCreditNoteResponseWritable;
    creditNotePos?: Array<ModelCreditNotePosResponseWritable>;
};

/**
 * creditNote model
 *
 * creditNote model
 */
export type ModelCreditNoteUpdateWritable = {
    /**
     * The creditNote number
     */
    creditNoteNumber?: string | null;
    /**
     * The contact used in the creditNote
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    creditNoteDate?: string;
    /**
     * Please have a look in
     * <a href='#tag/CreditNote/Status-of-credit-notes'>status of credit note</a>
     * to see what the different status codes mean
     */
    status?: '100' | '200' | '750' | '1000';
    /**
     * Normally consist of prefix plus the creditNote number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil
     */
    deliveryDate?: string;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the creditNote must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the creditNote
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    } | null;
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the creditNote. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string | null;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the creditNote.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * The date the creditNote was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the creditNote. Needs to be currency code according to ISO-4217
     */
    currency?: string | null;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the creditNote. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the creditNote. IMPORTANT: Please refer to the creditNote section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

export type ModelCreditNoteMailResponseWritable = {
    id?: number;
    objectName?: string;
    additionalInformation?: string;
    object?: ModelCreditNoteResponseWritable;
    from?: string;
    to?: string;
    subject?: string;
    text?: string;
    /**
     * Client to which creditNote belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: number;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

/**
 * Part model
 *
 * Part model
 */
export type ModelPartWritable = {
    /**
     * Name of the part
     */
    name: string;
    /**
     * The part number
     */
    partNumber: string;
    /**
     * A text describing the part
     */
    text?: string | null;
    /**
     * Category of the part.<br>
     * For all categories, send a GET to /Category?objectType=Part
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * The stock of the part
     */
    stock: number;
    /**
     * Defines if the stock should be enabled
     */
    stockEnabled?: boolean;
    /**
     * The unit in which the part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Net price for which the part is sold. we will change this parameter so that the gross price is calculated automatically, until then the priceGross parameter must be used.
     */
    price?: number | null;
    /**
     * Net price for which the part is sold
     */
    priceNet?: number | null;
    /**
     * Gross price for which the part is sold
     */
    priceGross?: number | null;
    /**
     * Purchase price of the part
     */
    pricePurchase?: number | null;
    /**
     * Tax rate of the part
     */
    taxRate: number;
    /**
     * Status of the part. 50 <-> Inactive - 100 <-> Active
     */
    status?: 50 | 100;
    /**
     * An internal comment for the part.<br>
     * Does not appear on invoices and orders.
     */
    internalComment?: string | null;
};

/**
 * Part model
 *
 * Part model
 */
export type ModelPartUpdateWritable = {
    /**
     * Name of the part
     */
    name?: string;
    /**
     * The part number
     */
    partNumber?: string;
    /**
     * A text describing the part
     */
    text?: string | null;
    /**
     * Category of the part.<br>
     * For all categories, send a GET to /Category?objectType=Part
     */
    category?: {
        /**
         * Unique identifier of the category
         */
        id: number;
        /**
         * Model name, which is 'Category'
         */
        objectName: string;
    } | null;
    /**
     * The stock of the part
     */
    stock?: number;
    /**
     * Defines if the stock should be enabled
     */
    stockEnabled?: boolean | null;
    /**
     * The unit in which the part is measured
     */
    unity?: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Net price for which the part is sold. we will change this parameter so that the gross price is calculated automatically, until then the priceGross parameter must be used.
     */
    price?: number | null;
    /**
     * Net price for which the part is sold
     */
    priceNet?: number | null;
    /**
     * Gross price for which the part is sold
     */
    priceGross?: number | null;
    /**
     * Purchase price of the part
     */
    pricePurchase?: number | null;
    /**
     * Tax rate of the part
     */
    taxRate?: number;
    /**
     * Status of the part. 50 <-> Inactive - 100 <-> Active
     */
    status?: 50 | 100;
    /**
     * An internal comment for the part.<br>
     * Does not appear on invoices and orders.
     */
    internalComment?: string | null;
};

/**
 * Invoice model
 *
 * Invoice model
 */
export type ModelInvoiceResponseWritable = {
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
};

/**
 * Invoice model
 *
 * Invoice model
 */
export type ModelInvoiceWritable = {
    /**
     * The invoice id. <span style='color:red'>Required</span> if you want to create or update an invoice position for an existing invoice
     */
    id?: number | null;
    /**
     * The invoice object name.
     */
    objectName?: string;
    /**
     * The invoice number
     */
    invoiceNumber?: string | null;
    /**
     * The contact used in the invoice
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * The user who acts as a contact person for the invoice
     */
    contactPerson: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     *
     * **Requirements:**
     * * For final invoices (invoiceType = 'ER'), the invoiceDate must be later than or equal to the invoiceDate of related advance (invoiceType = 'AR') / partial (invoiceType = 'TR') invoices.</li>
     */
    invoiceDate: string;
    /**
     * Normally consist of prefix plus the invoice number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * The time the customer has to pay the invoice in days
     */
    timeToPay?: number | null;
    /**
     * If you want to give a discount, define the percentage here. Otherwise provide zero as value
     */
    discount: number;
    /**
     * Complete address of the recipient including name, street, city, zip and country.
     * * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * Timestamp. This can also be a date range if you also use the attribute deliveryDateUntil
     */
    deliveryDate?: string | null;
    /**
     * If the delivery date should be a time range, another timestamp can be provided in this attribute
     * * to define a range from timestamp used in deliveryDate attribute to the timestamp used here.
     */
    deliveryDateUntil?: number | null;
    /**
     * Please have a look in our
     * <a href='#tag/Invoice/Types-and-status-of-invoices'>Types and status of invoices</a>
     * to see what the different status codes mean
     */
    status: '50' | '100' | '200' | '750' | '1000';
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the invoice must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate: number;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the invoice.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: 'default' | 'eu' | 'noteu' | 'custom';
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the invoice. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Payment method used for the invoice
     */
    paymentMethod?: {
        /**
         * Unique identifier of the payment method
         */
        id: number;
        /**
         * Model name, which is 'PaymentMethod'
         */
        objectName: string;
    };
    /**
     * The date the invoice was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Type of the invoice. For more information on the different types, check
     * <a href='#tag/Invoice/Types-and-status-of-invoices'>this</a> section
     *
     */
    invoiceType: 'RE' | 'WKR' | 'SR' | 'MA' | 'TR' | 'AR' | 'ER';
    /**
     * Currency used in the invoice. Needs to be currency code according to ISO-4217
     */
    currency: string;
    /**
     * If true, the net amount of each position will be shown on the invoice. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the invoice.
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
    /**
     * Origin of the invoice. Could f.e. be an order
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which could be 'Order'
         */
        objectName: string;
    } | null;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the invoice will be created as e-invoice.
     *
     * To create a valid e-invoice some extra data are required
     * - sevClient
     * - addressStreet
     * - addressZip
     * - addressCity
     * - bankIban
     * - bankBic
     * - contactEmail
     * - contactPhone
     * - taxNumber
     * - vatNumber
     * - contact
     * - buyerReference
     * - email
     * - invoice
     * - paymentMethod
     * - addressStreet
     * - addressZip
     * - addressCity
     * - addressCountry
     * - contact
     */
    propertyIsEInvoice?: boolean | null;
    mapAll: boolean;
};

/**
 * Invoice position model
 *
 * Invoice position model
 */
export type ModelInvoicePosWritable = {
    /**
     * The invoice position id. <span style='color:red'>Required</span> if you want to update an invoice position for an existing invoice
     */
    id?: number;
    /**
     * The invoice position object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: number;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Tax rate of the position.
     */
    taxRate: number;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
};

export type SaveInvoiceWritable = {
    invoice: ModelInvoiceWritable;
    invoicePosSave?: Array<ModelInvoicePosWritable>;
    invoicePosDelete?: {
        /**
         * Id of invoice position
         */
        id: number;
        /**
         * Object name of invoice position
         */
        objectName: string;
    };
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
    discountSave?: Array<{
        /**
         * Defines if this is a discount or a surcharge
         */
        discount?: boolean;
        /**
         * A text for your discount
         */
        text?: string;
        /**
         * Defines if this is a percentage or an absolute discount
         */
        percentage?: boolean;
        /**
         * Value of the discount
         */
        value?: number;
        /**
         * Object name of the discount
         */
        objectName?: string;
        /**
         * Internal param
         */
        mapAll?: boolean;
    }>;
    discountDelete?: {
        /**
         * ID of discount to delete
         */
        id?: number;
        /**
         * Object name of discount
         */
        objectName?: string;
    };
};

/**
 * Invoice position model
 *
 * Invoice position model
 */
export type ModelInvoicePosResponseWritable = {
    [key: string]: unknown;
};

export type SaveInvoiceResponseWritable = {
    invoice?: ModelInvoiceResponseWritable;
    invoicePos?: Array<ModelInvoicePosResponseWritable>;
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
};

/**
 * Email model
 *
 * Email model
 */
export type ModelEmailWritable = {
    object?: ModelInvoiceResponseWritable;
    /**
     * The sender of the email
     */
    from: string;
    /**
     * The recipient of the email
     */
    to: string;
    /**
     * The subject of the email
     */
    subject: string;
    /**
     * The text of the email
     */
    text?: string | null;
    /**
     * A list of mail addresses which are in the cc
     */
    cc?: string | null;
    /**
     * A list of mail addresses which are in the bcc
     */
    bcc?: string | null;
    /**
     * Date the mail arrived
     */
    arrived?: string | null;
};

/**
 * Layout model
 *
 * Layout model
 */
export type ModelChangeLayoutResponseWritable = {
    result?: string;
    metadaten?: {
        /**
         * the number of pages in the document
         */
        pages?: number;
        /**
         * the pdf file
         */
        thumbs?: Array<{
            key?: string;
            name?: string;
            values?: Array<{
                name?: string;
                value?: string;
                translationCode?: string;
            }>;
        }>;
    };
};

/**
 * Order model
 *
 * Order model
 */
export type ModelOrderResponseWritable = {
    /**
     * The order number
     */
    orderNumber?: string;
    /**
     * The contact used in the order
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    orderDate?: string;
    /**
     * Please have a look in
     * <a href='#tag/Order/Types-and-status-of-orders'>status of orders</a>
     * to see what the different status codes mean
     */
    status?: '100' | '200' | '300' | '500' | '750' | '1000';
    /**
     * Normally consist of prefix plus the order number
     */
    header?: string;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: string;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Delivery terms of the order
     */
    deliveryTerms?: string | null;
    /**
     * Payment terms of the order
     */
    paymentTerms?: string | null;
    /**
     * Object from which the order was created. For example an offer.
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name of the object. Could be 'Order'.
         */
        objectName: string;
    } | null;
    /**
     * Version of the order.<br>
     * Can be used if you have multiple drafts for the same order.<br>
     * Should start with 0
     */
    version?: string;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the order must not contain any vat
     */
    smallSettlement?: boolean;
    /**
     * The user who acts as a contact person for the order
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: string;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: string;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the order. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the order.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string;
    /**
     * Type of the order. For more information on the different types, check
     * <a href='#tag/Order/Types-and-status-of-orders'>this</a>
     *
     */
    orderType?: 'AN' | 'AB' | 'LI';
    /**
     * The date the order was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the order. Needs to be currency code according to ISO-4217
     */
    currency?: string;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the order. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the order. IMPORTANT: Please refer to the order section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * Order model
 *
 * Order model
 */
export type ModelOrderWritable = {
    /**
     * The order object name
     */
    objectName?: string;
    mapAll: boolean;
    /**
     * The order number
     */
    orderNumber: string;
    /**
     * The contact used in the order
     */
    contact: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    };
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    orderDate: string;
    /**
     * Please have a look in
     * <a href='#tag/Order/Types-and-status-of-orders'>status of orders</a>
     * to see what the different status codes mean
     */
    status: 100 | 200 | 300 | 500 | 750 | 1000;
    /**
     * Normally consist of prefix plus the order number
     */
    header: string;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    };
    /**
     * Delivery terms of the order
     */
    deliveryTerms?: string | null;
    /**
     * Payment terms of the order
     */
    paymentTerms?: string | null;
    /**
     * Version of the order.<br>
     * Can be used if you have multiple drafts for the same order.<br>
     * Should start with 0
     */
    version: number;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the order must not contain any vat
     */
    smallSettlement?: boolean;
    /**
     * The user who acts as a contact person for the order
     */
    contactPerson: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate: number;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the order. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText: string;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the order.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: string;
    /**
     * Type of the order. For more information on the different types, check
     * <a href='#tag/Order/Types-and-status-of-orders'>this</a>
     *
     */
    orderType?: 'AN' | 'AB' | 'LI';
    /**
     * The date the order was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the order. Needs to be currency code according to ISO-4217
     */
    currency: string;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the order. Otherwise gross amount
     */
    showNet?: boolean;
    /**
     * Type which was used to send the order. IMPORTANT: Please refer to the order section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
    /**
     * Object from which the order was created. For example an offer.
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name of the object. Could be 'Order'.
         */
        objectName: string;
    } | null;
};

/**
 * Order position model
 *
 * Order position model
 */
export type ModelOrderPosWritable = {
    /**
     * The order to which the position belongs.
     */
    order?: {
        /**
         * Unique identifier of the order
         */
        id: number;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity: number;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate: number;
};

export type SaveOrderWritable = {
    order: ModelOrderWritable;
    orderPosSave?: Array<ModelOrderPosWritable>;
    orderPosDelete?: {
        /**
         * Id of order position
         */
        id: number;
        /**
         * Object name of order position
         */
        objectName: string;
    };
};

/**
 * Order position model
 *
 * Order position model
 */
export type ModelOrderPosResponseWritable = {
    /**
     * The order to which the position belongs.
     */
    order?: {
        /**
         * Unique identifier of the order
         */
        id: string;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: string;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity?: string;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: string | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: string | null;
    /**
     * Gross price of the part
     */
    priceGross?: string | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity?: {
        /**
         * Unique identifier of the unit
         */
        id: string;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: string | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: string | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate?: string;
};

export type SaveOrderResponseWritable = {
    order?: ModelOrderResponseWritable;
    orderPos?: Array<ModelOrderPosResponseWritable>;
};

/**
 * Order model
 *
 * Order model
 */
export type ModelOrderUpdateWritable = {
    /**
     * The order number
     */
    orderNumber?: string;
    /**
     * The contact used in the order
     */
    contact?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    orderDate?: string | null;
    /**
     * Please have a look in
     * <a href='#tag/Order/Types-and-status-of-orders'>status of orders</a>
     * to see what the different status codes mean
     */
    status?: 100 | 200 | 300 | 500 | 750 | 1000;
    /**
     * Normally consist of prefix plus the order number
     */
    header?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    headText?: string | null;
    /**
     * Certain html tags can be used here to format your text
     */
    footText?: string | null;
    /**
     * Can be omitted as complete address is defined in address attribute
     */
    addressCountry?: {
        /**
         * Unique identifier of the country
         */
        id: number;
        /**
         * Model name, which is 'StaticCountry'
         */
        objectName: string;
    } | null;
    /**
     * Delivery terms of the order
     */
    deliveryTerms?: string | null;
    /**
     * Payment terms of the order
     */
    paymentTerms?: string | null;
    /**
     * Object from which the order was created. For example an offer.
     */
    origin?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name of the object. Could be 'Order'.
         */
        objectName: string;
    } | null;
    /**
     * Version of the order.<br>
     * Can be used if you have multiple drafts for the same order.<br>
     * Should start with 0
     */
    version?: number | null;
    /**
     * Defines if the client uses the small settlement scheme.
     * If yes, the order must not contain any vat
     */
    smallSettlement?: boolean | null;
    /**
     * The user who acts as a contact person for the order
     */
    contactPerson?: {
        /**
         * Unique identifier of the user
         */
        id: number;
        /**
         * Model name, which is 'SevUser'
         */
        objectName: string;
    };
    /**
     * This is not used anymore. Use the taxRate of the individual positions instead.
     */
    taxRate?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * See [list of available VAT rules](#section/sevdesk-Update-2.0/Tax-Rules).
     */
    taxRule?: {
        id: '1' | '2' | '3' | '4' | '5' | '11' | '17' | '18' | '19' | '20' | '21';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax set of the order. Needs to be added if you chose the tax type custom
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * A common tax text would be 'Umsatzsteuer 19%'
     */
    taxText?: string | null;
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the order.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * Type of the order. For more information on the different types, check
     * <a href='#tag/Order/Types-and-status-of-orders'>this</a>
     *
     */
    orderType?: 'AN' | 'AB' | 'LI';
    /**
     * The date the order was sent to the customer
     */
    sendDate?: string | null;
    /**
     * Complete address of the recipient including name, street, city, zip and country.<br>
     * Line breaks can be used and will be displayed on the invoice pdf.
     */
    address?: string | null;
    /**
     * Currency used in the order. Needs to be currency code according to ISO-4217
     */
    currency?: string | null;
    /**
     * Internal note of the customer. Contains data entered into field 'Referenz/Bestellnummer'
     */
    customerInternalNote?: string | null;
    /**
     * If true, the net amount of each position will be shown on the order. Otherwise gross amount
     */
    showNet?: boolean | null;
    /**
     * Type which was used to send the order. IMPORTANT: Please refer to the order section of the
     * *     API-Overview to understand how this attribute can be used before using it!
     */
    sendType?: 'VPR' | 'VPDF' | 'VM' | 'VP';
};

/**
 * Discounts
 *
 * Discount model
 */
export type ModelDiscountWritable = {
    /**
     * Defines if this is a percentage or an absolute discount
     */
    percentage?: string;
    /**
     * Value of the discount
     */
    value?: string;
    /**
     * Defines is the Discount net or gross
     * 0 - gross
     * 1 - net
     */
    isNet?: string;
};

/**
 * Email model
 *
 * Email model
 */
export type ModelEmailOrderWritable = {
    object?: ModelOrderResponseWritable;
    /**
     * The sender of the email
     */
    from: string;
    /**
     * The recipient of the email
     */
    to: string;
    /**
     * The subject of the email
     */
    subject: string;
    /**
     * The text of the email
     */
    text?: string | null;
    /**
     * A list of mail addresses which are in the cc
     */
    cc?: string | null;
    /**
     * A list of mail addresses which are in the bcc
     */
    bcc?: string | null;
    /**
     * Date the mail arrived
     */
    arrived?: string | null;
};

/**
 * Order position model
 *
 * Order position model
 */
export type ModelOrderPosUpdateWritable = {
    /**
     * The order to which the position belongs.
     */
    order?: {
        /**
         * Unique identifier of the order
         */
        id: number;
        /**
         * Model name, which is 'Order'
         */
        objectName: string;
    };
    /**
     * Part from your inventory which is used in the position.
     */
    part?: {
        /**
         * Unique identifier of the part
         */
        id: number;
        /**
         * Model name, which is 'Part'
         */
        objectName: string;
    };
    /**
     * Quantity of the article/part
     */
    quantity?: number | null;
    /**
     * Price of the article/part. Is either gross or net, depending on the sevdesk account setting.
     */
    price?: number | null;
    /**
     * Tax on the price of the part
     */
    priceTax?: number | null;
    /**
     * Gross price of the part
     */
    priceGross?: number | null;
    /**
     * Name of the article/part.
     */
    name?: string | null;
    /**
     * The unit in which the positions part is measured
     */
    unity?: {
        /**
         * Unique identifier of the unit
         */
        id: number;
        /**
         * Model name, which is 'Unity'
         */
        objectName: string;
    };
    /**
     * Position number of your position. Can be used to order multiple positions.
     */
    positionNumber?: number | null;
    /**
     * A text describing your position.
     */
    text?: string | null;
    /**
     * An optional discount of the position.
     */
    discount?: number | null;
    /**
     * Defines if the position is optional.
     */
    optional?: boolean | null;
    /**
     * Tax rate of the position.
     */
    taxRate?: number | null;
};

/**
 * Voucher model
 *
 * Voucher model
 */
export type ModelVoucherWritable = {
    /**
     * The voucher object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    voucherDate?: string | null;
    /**
     * The contact used in the voucher as a supplier.<br>
     * If you don't have a contact as a supplier, you can set this object to null.
     */
    supplier?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The supplier name.<br>
     * The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier.
     */
    supplierName?: string | null;
    /**
     * The description of the voucher. Essentially the voucher number.
     */
    description?: string | null;
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * Please have a look in
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>status of vouchers</a>
     * to see what the different status codes mean
     */
    status: 50 | 100 | 1000;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     */
    taxRule: {
        /**
         * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
         *
         * Defines the vat-regulation.
         * For "Regelbesteuerung" it can be one of:
         * - `1` - Umsatzsteuerpflichtige Umstze (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "default"`
         * - `2` - Ausfuhren (tax rates: 0.0)
         * - `3` - Innergemeinschaftliche Lieferungen (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "eu"`
         * - `4` - Steuerfreie Umstze 4 UStG (tax rates: 0.0)
         * - `5` - Reverse Charge gem. 13b UStG (tax rates: 0.0)
         *
         * For small business owner ("Kleinunternehmer") it can be:
         * - `11` - Steuer nicht erhoben nach 19UStG (tax rates: 0.0) - replaces `"taxType": "ss"`
         */
        id: '1' | '2' | '3' | '4' | '5' | '11';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the voucher.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType: string;
    /**
     * Defines if your voucher is a credit (C) or debit (D)
     */
    creditDebit: 'C' | 'D';
    /**
     * Type of the voucher. For more information on the different types, check
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>this</a>
     *
     */
    voucherType: 'VOU' | 'RV';
    /**
     * specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred
     */
    currency?: string | null;
    /**
     * Defines the exchange rate day and and then the exchange rate is set from sevdesk. Needs to be provided as timestamp or dd.mm.yyyy
     */
    propertyForeignCurrencyDeadline?: string | null;
    /**
     * Defines the exchange rate
     */
    propertyExchangeRate?: number | null;
    /**
     * ** Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * Tax set of the voucher. Needs to be added if you chose the taxType=custom.
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Payment deadline of the voucher.
     */
    paymentDeadline?: string | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDate?: string;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDateUntil?: string | null;
    /**
     * The document of the voucher.
     */
    document?: {
        /**
         * Unique identifier of the document
         */
        id: number;
        /**
         * Model name, which is 'Document'
         */
        objectName: string;
    } | null;
    /**
     * Cost centre for the voucher
     */
    costCentre?: {
        /**
         * Unique identifier of the cost centre
         */
        id: number;
        /**
         * Model name, which is 'CostCentre'
         */
        objectName: string;
    };
};

/**
 * VoucherPos model
 *
 * Voucher position model
 */
export type ModelVoucherPosWritable = {
    /**
     * The voucher position object name
     */
    objectName: string;
    mapAll: boolean;
    /**
     * <b>Use this in sevdesk-Update 2.0 (replaces accountingType).</b>
     * The account datev to which the position belongs.<br>
     * An account datev is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Account-Datev'>this</a> section.
     */
    accountDatev: {
        /**
         * Unique identifier of the account datev
         */
        id: number;
        /**
         * Model name, which is 'AccountDatev'
         */
        objectName: string;
    };
    /**
     * The accounting type to which the position belongs.<br>
     * An accounting type is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Accounting-type'>this</a> section.
     */
    accountingType: {
        /**
         * Unique identifier of the accounting type
         */
        id: number;
        /**
         * Model name, which is 'AccountingType'
         */
        objectName: string;
    };
    /**
     * Tax rate of the voucher position.
     */
    taxRate: number;
    /**
     * Determines whether 'sumNet' or 'sumGross' is regarded.<br>
     * If both are not given, 'sum' is regarded and treated as net or gross depending on 'net'.
     * All positions must be either net or gross, a mixture of the two is not possible.
     */
    net: boolean;
    /**
     * Determines whether position is regarded as an asset which can be depreciated.
     */
    isAsset?: boolean;
    /**
     * Net sum of the voucher position.<br>
     * Only regarded if 'net' is 'true', otherwise its readOnly.
     */
    sumNet: number;
    /**
     * Gross sum of the voucher position.<br>
     * Only regarded if 'net' is 'false', otherwise its readOnly.
     */
    sumGross: number;
    /**
     * Comment for the voucher position.
     */
    comment?: string | null;
};

export type SaveVoucherWritable = {
    voucher: ModelVoucherWritable;
    voucherPosSave?: Array<ModelVoucherPosWritable>;
    voucherPosDelete?: {
        /**
         * Id of voucher position
         */
        id: number;
        /**
         * Object name of voucher position
         */
        objectName: string;
    };
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
};

/**
 * Voucher model
 *
 * Voucher model
 */
export type ModelVoucherResponseWritable = {
    mapAll?: boolean;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    voucherDate?: string | null;
    /**
     * The contact used in the voucher as a supplier.<br>
     * If you don't have a contact as a supplier, you can set this object to null.
     */
    supplier?: {
        /**
         * Unique identifier of the contact
         */
        id: string;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The supplier name.<br>
     * The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier.
     */
    supplierName?: string | null;
    /**
     * The description of the voucher. Essentially the voucher number.
     */
    description?: string | null;
    /**
     * The document of the voucher.
     */
    document?: {
        /**
         * Unique identifier of the document
         */
        id: string;
        /**
         * Model name, which is 'Document'
         */
        objectName: string;
    } | null;
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * Please have a look in
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>status of vouchers</a>
     * to see what the different status codes mean
     */
    status?: '50' | '100' | '1000';
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     */
    taxRule?: {
        /**
         * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
         *
         * Defines the vat-regulation.
         * For "Regelbesteuerung" it can be one of:
         * - `1` - Umsatzsteuerpflichtige Umstze (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "default"`
         * - `2` - Ausfuhren (tax rates: 0.0)
         * - `3` - Innergemeinschaftliche Lieferungen (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "eu"`
         * - `4` - Steuerfreie Umstze 4 UStG (tax rates: 0.0)
         * - `5` - Reverse Charge gem. 13b UStG (tax rates: 0.0)
         *
         * For small business owner ("Kleinunternehmer") it can be:
         * - `11` - Steuer nicht erhoben nach 19UStG (tax rates: 0.0) - replaces `"taxType": "ss"`
         */
        id: '1' | '2' | '3' | '4' | '5' | '11';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the voucher.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string | null;
    /**
     * Defines if your voucher is a credit (C) or debit (D)
     */
    creditDebit?: 'C' | 'D';
    /**
     * Cost centre for the voucher
     */
    costCentre?: {
        /**
         * Unique identifier of the cost centre
         */
        id: string;
        /**
         * Model name, which is 'CostCentre'
         */
        objectName: string;
    };
    /**
     * Type of the voucher. For more information on the different types, check
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>this</a>
     *
     */
    voucherType?: 'VOU' | 'RV';
    /**
     * specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred
     */
    currency?: string | null;
    /**
     * Defines the exchange rate day and and then the exchange rate is set from sevdesk. Needs to be provided as timestamp or dd.mm.yyyy
     */
    propertyForeignCurrencyDeadline?: string | null;
    /**
     * Defines the exchange rate
     */
    propertyExchangeRate?: string | null;
    /**
     * The DateInterval in which recurring vouchers are generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringInterval?: 'P0Y0M1W' | 'P0Y0M2W' | 'P0Y1M0W' | 'P0Y3M0W' | 'P0Y6M0W' | 'P1Y0M0W' | 'P2Y0M0W' | 'P3Y0M0W' | 'P4Y0M0W' | 'P5Y0M0W';
    /**
     * The date when the recurring vouchers start being generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringStartDate?: string | null;
    /**
     * The date when the next voucher should be generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringNextVoucher?: string | null;
    /**
     * The date when the last voucher was generated.
     */
    recurringLastVoucher?: string | null;
    /**
     * The date when the recurring vouchers end being generated.<br>
     * Necessary attribute for all recurring vouchers.
     */
    recurringEndDate?: string | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * Tax set of the voucher. Needs to be added if you chose the taxType=custom.
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: string;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Payment deadline of the voucher.
     */
    paymentDeadline?: string | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDate?: string;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDateUntil?: string | null;
};

/**
 * VoucherPos model
 *
 * Voucher position model
 */
export type ModelVoucherPosResponseWritable = {
    /**
     * <b>Use this in sevdesk-Update 2.0 (replaces accountingType).</b>
     * The account datev to which the position belongs.<br>
     * An account datev is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Account-Datev'>this</a> section.
     */
    accountDatev: {
        /**
         * Unique identifier of the account datev
         */
        id: number;
        /**
         * Model name, which is 'AccountDatev'
         */
        objectName: string;
    };
    /**
     * The accounting type to which the position belongs.<br>
     * An accounting type is the booking account to which the position belongs.<br>
     * For more information, please refer to
     * <a href='#tag/Voucher/Accounting-type'>this</a> section.
     */
    accountingType: {
        /**
         * Unique identifier of the accounting type
         */
        id: string;
        /**
         * Model name, which is 'AccountingType'
         */
        objectName: string;
    };
    /**
     * Tax rate of the voucher position.
     */
    taxRate: string;
    /**
     * Determines whether 'sumNet' or 'sumGross' is regarded.<br>
     * If both are not given, 'sum' is regarded and treated as net or gross depending on 'net'.
     * All positions must be either net or gross, a mixture of the two is not possible.
     */
    net: boolean;
    /**
     * Determines whether position is regarded as an asset which can be depreciated.
     */
    isAsset?: boolean;
    /**
     * Net sum of the voucher position.<br>
     * Only regarded if 'net' is 'true', otherwise its readOnly.
     */
    sumNet: string;
    /**
     * Gross sum of the voucher position.<br>
     * Only regarded if 'net' is 'false', otherwise its readOnly.
     */
    sumGross: string;
    /**
     * Comment for the voucher position.
     */
    comment?: string | null;
};

export type SaveVoucherResponseWritable = {
    voucher?: ModelVoucherResponseWritable;
    voucherPos?: Array<ModelVoucherPosResponseWritable>;
    /**
     * Filename of a previously upload file which should be attached.
     */
    filename?: Blob | File;
};

/**
 * Voucher model
 *
 * Voucher model
 */
export type ModelVoucherUpdateWritable = {
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    voucherDate?: string | null;
    /**
     * The contact used in the voucher as a supplier.<br>
     * If you don't have a contact as a supplier, you can set this object to null.
     */
    supplier?: {
        /**
         * Unique identifier of the contact
         */
        id: number;
        /**
         * Model name, which is 'Contact'
         */
        objectName: string;
    } | null;
    /**
     * The supplier name.<br>
     * The value you provide here will determine what supplier name is shown for the voucher in case you did not provide a supplier.
     */
    supplierName?: string | null;
    /**
     * The description of the voucher. Essentially the voucher number.
     */
    description?: string | null;
    /**
     * Needs to be timestamp or dd.mm.yyyy
     */
    payDate?: string | null;
    /**
     * <b>Not supported in sevdesk-Update 2.0.</b><br><br>    Please have a look in <a href='#tag/Voucher/Types-and-status-of-vouchers'>status of vouchers</a>    to see what the different status codes mean
     */
    status?: 50 | 100 | 1000;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     */
    taxRule?: {
        /**
         * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
         *
         * Defines the vat-regulation.
         * For "Regelbesteuerung" it can be one of:
         * - `1` - Umsatzsteuerpflichtige Umstze (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "default"`
         * - `2` - Ausfuhren (tax rates: 0.0)
         * - `3` - Innergemeinschaftliche Lieferungen (tax rates: 0.0, 7.0, 19.0) - replaces `"taxType": "eu"`
         * - `4` - Steuerfreie Umstze 4 UStG (tax rates: 0.0)
         * - `5` - Reverse Charge gem. 13b UStG (tax rates: 0.0)
         *
         * For small business owner ("Kleinunternehmer") it can be:
         * - `11` - Steuer nicht erhoben nach 19UStG (tax rates: 0.0) - replaces `"taxType": "ss"`
         */
        id: '1' | '2' | '3' | '4' | '5' | '11';
        /**
         * Name of the object. Must always be TaxRule
         */
        objectName: 'TaxRule';
    };
    /**
     * **Use this in sevdesk-Update 1.0 (instead of taxRule).**
     *
     * Tax type of the voucher.
     * There are four tax types:
     * 1. default - Umsatzsteuer ausweisen
     * 2. eu - Steuerfreie innergemeinschaftliche Lieferung (Europische Union)
     * 3. noteu - Steuerschuldnerschaft des Leistungsempfngers (auerhalb EU, z. B. Schweiz)
     * 4. custom - Using custom tax set
     * 5. ss - Not subject to VAT according to 19 1 UStG
     * Tax rates are heavily connected to the tax type used.
     */
    taxType?: string;
    /**
     * Defines if your voucher is a credit (C) or debit (D)
     */
    creditDebit?: 'C' | 'D';
    /**
     * Type of the voucher. For more information on the different types, check
     * <a href='#tag/Voucher/Types-and-status-of-vouchers'>this</a>
     *
     */
    voucherType?: 'VOU' | 'RV';
    /**
     * specifies which currency the voucher should have. Attention: If the currency differs from the default currency stored in the account, then either the "propertyForeignCurrencyDeadline" or "propertyExchangeRate" parameter must be specified. If both parameters are specified, then the "propertyForeignCurrencyDeadline" parameter is preferred
     */
    currency?: string | null;
    /**
     * Defines the exchange rate day and and then the exchange rate is set from sevdesk. Needs to be provided as timestamp or dd.mm.yyyy
     */
    propertyForeignCurrencyDeadline?: string | null;
    /**
     * Defines the exchange rate
     */
    propertyExchangeRate?: number | null;
    /**
     * **Use this in sevdesk-Update 2.0 (replaces taxType / taxSet).**
     *
     * Tax set of the voucher. Needs to be added if you chose the taxType=custom.
     */
    taxSet?: {
        /**
         * Unique identifier of the object
         */
        id: number;
        /**
         * Model name, which is 'TaxSet'
         */
        objectName: string;
    } | null;
    /**
     * Payment deadline of the voucher.
     */
    paymentDeadline?: string | null;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDate?: string;
    /**
     * Needs to be provided as timestamp or dd.mm.yyyy
     */
    deliveryDateUntil?: string | null;
    /**
     * The document of the voucher.
     */
    document?: {
        /**
         * Unique identifier of the document
         */
        id: number;
        /**
         * Model name, which is 'Document'
         */
        objectName: string;
    } | null;
    /**
     * Cost centre for the voucher
     */
    costCentre?: {
        /**
         * Unique identifier of the cost centre
         */
        id: number;
        /**
         * Model name, which is 'CostCentre'
         */
        objectName: string;
    };
};

/**
 * Tag model
 *
 * tag model
 */
export type ModelTagResponseWritable = {
    additionalInformation?: string;
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

/**
 * Tag model
 *
 * tag model
 */
export type ModelTagCreateResponseWritable = {
    additionalInformation?: string;
    /**
     * The tag information
     */
    tag?: {
        /**
         * Unique identifier of the tag
         */
        id: string;
        /**
         * Model name, which is 'Tag'
         */
        objectName: string;
    };
    object?: {
        /**
         * Id of the invoice/order/voucher/creditNote
         */
        id: number;
        /**
         * Model name
         */
        objectName: 'Invoice' | 'Voucher' | 'Order' | 'CreditNote';
    };
    /**
     * Client to which invoice belongs. Will be filled automatically
     */
    sevClient?: {
        /**
         * Unique identifier of the client
         */
        id: string;
        /**
         * Model name, which is 'SevClient'
         */
        objectName: string;
    };
};

export type BookkeepingSystemVersionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Tools/bookkeepingSystemVersion';
};

export type BookkeepingSystemVersionErrors = {
    /**
     * Authentication required
     */
    401: unknown;
};

export type BookkeepingSystemVersionResponses = {
    /**
     * Successful Request
     */
    200: {
        objects?: {
            version?: '1.0' | '2.0';
        };
    };
};

export type BookkeepingSystemVersionResponse = BookkeepingSystemVersionResponses[keyof BookkeepingSystemVersionResponses];

export type GetCheckAccountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/CheckAccount';
};

export type GetCheckAccountsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type GetCheckAccountsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCheckAccountResponse>;
    };
};

export type GetCheckAccountsResponse = GetCheckAccountsResponses[keyof GetCheckAccountsResponses];

export type CreateFileImportAccountData = {
    /**
     * Data to create a file import account
     */
    body?: CreateFileImportAccount;
    path?: never;
    query?: never;
    url: '/CheckAccount/Factory/fileImportAccount';
};

export type CreateFileImportAccountErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Invalid value given
     */
    422: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type CreateFileImportAccountResponses = {
    /**
     * Created
     */
    201: {
        objects?: CreateFileImportAccountResponse;
    };
};

export type CreateFileImportAccountResponse2 = CreateFileImportAccountResponses[keyof CreateFileImportAccountResponses];

export type CreateClearingAccountData = {
    /**
     * Data to create a clearning account
     */
    body?: CreateClearingAccount;
    path?: never;
    query?: never;
    url: '/CheckAccount/Factory/clearingAccount';
};

export type CreateClearingAccountErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Invalid value given
     */
    422: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type CreateClearingAccountResponses = {
    /**
     * Created
     */
    201: {
        objects?: CreateClearingAccountResponse;
    };
};

export type CreateClearingAccountResponse2 = CreateClearingAccountResponses[keyof CreateClearingAccountResponses];

export type DeleteCheckAccountData = {
    body?: never;
    path: {
        /**
         * Id of check account to delete
         */
        checkAccountId: number;
    };
    query?: never;
    url: '/CheckAccount/{checkAccountId}';
};

export type DeleteCheckAccountErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type DeleteCheckAccountResponses = {
    /**
     * Successful operation - check account deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteCheckAccountResponse = DeleteCheckAccountResponses[keyof DeleteCheckAccountResponses];

export type GetCheckAccountByIdData = {
    body?: never;
    path: {
        /**
         * ID of check account
         */
        checkAccountId: number;
    };
    query?: never;
    url: '/CheckAccount/{checkAccountId}';
};

export type GetCheckAccountByIdErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type GetCheckAccountByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCheckAccountResponse>;
    };
};

export type GetCheckAccountByIdResponse = GetCheckAccountByIdResponses[keyof GetCheckAccountByIdResponses];

export type UpdateCheckAccountData = {
    /**
     * Update data
     */
    body?: ModelCheckAccountUpdate;
    path: {
        /**
         * ID of check account to update
         */
        checkAccountId: number;
    };
    query?: never;
    url: '/CheckAccount/{checkAccountId}';
};

export type UpdateCheckAccountErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type UpdateCheckAccountResponses = {
    /**
     * Successful operation - Returns changed check account resource
     */
    200: ModelCheckAccountResponse;
};

export type UpdateCheckAccountResponse = UpdateCheckAccountResponses[keyof UpdateCheckAccountResponses];

export type GetBalanceAtDateData = {
    body?: never;
    path: {
        /**
         * ID of check account
         */
        checkAccountId: number;
    };
    query: {
        /**
         * Only consider transactions up to this date at 23:59:59
         */
        date: string;
    };
    url: '/CheckAccount/{checkAccountId}/getBalanceAtDate';
};

export type GetBalanceAtDateErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type GetBalanceAtDateResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: string;
    };
};

export type GetBalanceAtDateResponse = GetBalanceAtDateResponses[keyof GetBalanceAtDateResponses];

export type GetTransactionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Retrieve all transactions on this check account. Must be provided with checkAccount[objectName]
         */
        'checkAccount[id]'?: number;
        /**
         * Only required if checkAccount[id] was provided. 'CheckAccount' should be used as value.
         */
        'checkAccount[objectName]'?: string;
        /**
         * Only retrieve booked transactions
         */
        isBooked?: boolean;
        /**
         * Only retrieve transactions with this payment purpose
         */
        paymtPurpose?: string;
        /**
         * Only retrieve transactions from this date on
         */
        startDate?: string;
        /**
         * Only retrieve transactions up to this date
         */
        endDate?: string;
        /**
         * Only retrieve transactions with this payee / payer
         */
        payeePayerName?: string;
        /**
         * Only retrieve credit transactions
         */
        onlyCredit?: boolean;
        /**
         * Only retrieve debit transactions
         */
        onlyDebit?: boolean;
    };
    url: '/CheckAccountTransaction';
};

export type GetTransactionsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type GetTransactionsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCheckAccountTransactionResponse>;
    };
};

export type GetTransactionsResponse = GetTransactionsResponses[keyof GetTransactionsResponses];

export type CreateTransactionData = {
    /**
     * Creation data. Please be aware, that you need to provide at least all required parameter
     * of the CheckAccountTransaction model!
     */
    body?: ModelCheckAccountTransactionWritable;
    path?: never;
    query?: never;
    url: '/CheckAccountTransaction';
};

export type CreateTransactionErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type CreateTransactionResponses = {
    /**
     * Created - Returns created transaction
     */
    201: ModelCheckAccountTransactionResponse;
};

export type CreateTransactionResponse = CreateTransactionResponses[keyof CreateTransactionResponses];

export type DeleteCheckAccountTransactionData = {
    body?: never;
    path: {
        /**
         * Id of check account transaction to delete
         */
        checkAccountTransactionId: number;
    };
    query?: never;
    url: '/CheckAccountTransaction/{checkAccountTransactionId}';
};

export type DeleteCheckAccountTransactionErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type DeleteCheckAccountTransactionResponses = {
    /**
     * Successful operation - check account transaction deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteCheckAccountTransactionResponse = DeleteCheckAccountTransactionResponses[keyof DeleteCheckAccountTransactionResponses];

export type GetCheckAccountTransactionByIdData = {
    body?: never;
    path: {
        /**
         * ID of check account transaction
         */
        checkAccountTransactionId: number;
    };
    query?: never;
    url: '/CheckAccountTransaction/{checkAccountTransactionId}';
};

export type GetCheckAccountTransactionByIdErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type GetCheckAccountTransactionByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCheckAccountTransactionResponse>;
    };
};

export type GetCheckAccountTransactionByIdResponse = GetCheckAccountTransactionByIdResponses[keyof GetCheckAccountTransactionByIdResponses];

export type UpdateCheckAccountTransactionData = {
    /**
     * Update data
     */
    body?: ModelCheckAccountTransactionUpdate;
    path: {
        /**
         * ID of check account to update transaction
         */
        checkAccountTransactionId: number;
    };
    query?: never;
    url: '/CheckAccountTransaction/{checkAccountTransactionId}';
};

export type UpdateCheckAccountTransactionErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type UpdateCheckAccountTransactionResponses = {
    /**
     * Successful operation - Returns changed check account resource
     */
    200: ModelCheckAccountTransactionResponse;
};

export type UpdateCheckAccountTransactionResponse = UpdateCheckAccountTransactionResponses[keyof UpdateCheckAccountTransactionResponses];

export type CheckAccountTransactionEnshrineData = {
    body?: never;
    path: {
        /**
         * ID of the transaction to enshrine
         */
        checkAccountTransactionId: number;
    };
    query?: never;
    url: '/CheckAccountTransaction/{checkAccountTransactionId}/enshrine';
};

export type CheckAccountTransactionEnshrineErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type CheckAccountTransactionEnshrineError = CheckAccountTransactionEnshrineErrors[keyof CheckAccountTransactionEnshrineErrors];

export type CheckAccountTransactionEnshrineResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: unknown;
    };
};

export type CheckAccountTransactionEnshrineResponse = CheckAccountTransactionEnshrineResponses[keyof CheckAccountTransactionEnshrineResponses];

export type ListPrivateTransactionRulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/PrivateTransactionRule';
};

export type ListPrivateTransactionRulesErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type ListPrivateTransactionRulesResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelPrivateTransactionRuleResponse>;
    };
};

export type ListPrivateTransactionRulesResponse = ListPrivateTransactionRulesResponses[keyof ListPrivateTransactionRulesResponses];

export type CreatePrivateTransactionRuleData = {
    body?: CreatePrivateTransactionRule;
    path?: never;
    query?: never;
    url: '/PrivateTransactionRule';
};

export type CreatePrivateTransactionRuleErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error, you did not submit valid input
     */
    422: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type CreatePrivateTransactionRuleResponses = {
    /**
     * Created - Returns created rule
     */
    201: ModelPrivateTransactionRuleResponse;
};

export type CreatePrivateTransactionRuleResponse = CreatePrivateTransactionRuleResponses[keyof CreatePrivateTransactionRuleResponses];

export type DeletePrivateTransactionRuleData = {
    body?: never;
    path: {
        /**
         * Id of the rule to delete
         */
        id: number;
    };
    query?: never;
    url: '/PrivateTransactionRule/{id}';
};

export type DeletePrivateTransactionRuleErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server error
     */
    500: unknown;
};

export type DeletePrivateTransactionRuleResponses = {
    /**
     * Successful operation - entity deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeletePrivateTransactionRuleResponse = DeletePrivateTransactionRuleResponses[keyof DeletePrivateTransactionRuleResponses];

export type GetNextCustomerNumberData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Contact/Factory/getNextCustomerNumber';
};

export type GetNextCustomerNumberErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetNextCustomerNumberResponses = {
    /**
     * Returns next available customer number
     */
    200: {
        /**
         * Next available customer number
         */
        objects?: string;
    };
};

export type GetNextCustomerNumberResponse = GetNextCustomerNumberResponses[keyof GetNextCustomerNumberResponses];

export type FindContactsByCustomFieldValueData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The value to be checked.
         */
        value: string;
        /**
         * ID of ContactCustomFieldSetting for which the value has to be checked.
         */
        'customFieldSetting[id]'?: string;
        /**
         * Object name. Only needed if you also defined the ID of a ContactCustomFieldSetting.
         */
        'customFieldSetting[objectName]'?: string;
        /**
         * The ContactCustomFieldSetting name, if no ContactCustomFieldSetting is provided.
         */
        customFieldName: string;
    };
    url: '/Contact/Factory/findContactsByCustomFieldValue';
};

export type FindContactsByCustomFieldValueErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type FindContactsByCustomFieldValueResponses = {
    /**
     * Array of contacts having a certain custom field value set.
     */
    200: {
        objects?: Array<ModelContactResponse>;
    };
};

export type FindContactsByCustomFieldValueResponse = FindContactsByCustomFieldValueResponses[keyof FindContactsByCustomFieldValueResponses];

export type ContactCustomerNumberAvailabilityCheckData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The customer number to be checked.
         */
        customerNumber?: string;
    };
    url: '/Contact/Mapper/checkCustomerNumberAvailability';
};

export type ContactCustomerNumberAvailabilityCheckErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ContactCustomerNumberAvailabilityCheckResponses = {
    /**
     * Returns whether given customer number is available.
     */
    200: {
        objects?: boolean;
    };
};

export type ContactCustomerNumberAvailabilityCheckResponse = ContactCustomerNumberAvailabilityCheckResponses[keyof ContactCustomerNumberAvailabilityCheckResponses];

export type GetContactsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Defines if both organizations <b>and</b> persons should be returned.<br>
         * '0' -> only organizations, '1' -> organizations and persons
         */
        depth?: '0' | '1';
        /**
         * Retrieve all contacts with this customer number
         */
        customerNumber?: string;
    };
    url: '/Contact';
};

export type GetContactsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactResponse>;
    };
};

export type GetContactsResponse = GetContactsResponses[keyof GetContactsResponses];

export type CreateContactData = {
    /**
     * Creation data
     */
    body?: ModelContact;
    path?: never;
    query?: never;
    url: '/Contact';
};

export type CreateContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateContactResponses = {
    /**
     * Created - Returns created contact
     */
    201: ModelContactResponse;
};

export type CreateContactResponse = CreateContactResponses[keyof CreateContactResponses];

export type DeleteContactData = {
    body?: never;
    path: {
        /**
         * Id of contact resource to delete
         */
        contactId: number;
    };
    query?: never;
    url: '/Contact/{contactId}';
};

export type DeleteContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteContactResponses = {
    /**
     * Successful operation - contact deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteContactResponse = DeleteContactResponses[keyof DeleteContactResponses];

export type GetContactByIdData = {
    body?: never;
    path: {
        /**
         * ID of contact to return
         */
        contactId: number;
    };
    query?: never;
    url: '/Contact/{contactId}';
};

export type GetContactByIdErrors = {
    /**
     * Bad request. Contact was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactResponse>;
    };
};

export type GetContactByIdResponse = GetContactByIdResponses[keyof GetContactByIdResponses];

export type UpdateContactData = {
    /**
     * Update data
     */
    body?: ModelContactUpdate;
    path: {
        /**
         * ID of contact to update
         */
        contactId: number;
    };
    query?: never;
    url: '/Contact/{contactId}';
};

export type UpdateContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateContactResponses = {
    /**
     * Successful operation - Returns changed contact resource
     */
    200: ModelContactResponse;
};

export type UpdateContactResponse = UpdateContactResponses[keyof UpdateContactResponses];

export type GetContactTabsItemCountByIdData = {
    body?: never;
    path: {
        /**
         * ID of contact to return
         */
        contactId: number;
    };
    query?: never;
    url: '/Contact/{contactId}/getTabsItemCount';
};

export type GetContactTabsItemCountByIdErrors = {
    /**
     * Bad request.
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactTabsItemCountByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        orders?: number;
        invoices?: number;
        creditNotes?: number;
        documents?: number;
        persons?: number;
        vouchers?: number;
        letters?: number;
        parts?: string;
        invoicePos?: number;
    };
};

export type GetContactTabsItemCountByIdResponse = GetContactTabsItemCountByIdResponses[keyof GetContactTabsItemCountByIdResponses];

export type GetContactAddressesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/ContactAddress';
};

export type GetContactAddressesErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactAddressesResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactAddressResponse>;
    };
};

export type GetContactAddressesResponse = GetContactAddressesResponses[keyof GetContactAddressesResponses];

export type CreateContactAddressData = {
    /**
     * Creation data
     */
    body?: ModelContactAddressWritable;
    path?: never;
    query?: never;
    url: '/ContactAddress';
};

export type CreateContactAddressErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateContactAddressResponses = {
    /**
     * Created - Returns created contact address
     */
    201: ModelContactAddressResponse;
};

export type CreateContactAddressResponse = CreateContactAddressResponses[keyof CreateContactAddressResponses];

export type DeleteContactAddressData = {
    body?: never;
    path: {
        /**
         * Id of contact address resource to delete
         */
        contactAddressId: number;
    };
    query?: never;
    url: '/ContactAddress/{contactAddressId}';
};

export type DeleteContactAddressErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteContactAddressResponses = {
    /**
     * Successful operation - contact address deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteContactAddressResponse = DeleteContactAddressResponses[keyof DeleteContactAddressResponses];

export type ContactAddressIdData = {
    body?: never;
    path: {
        /**
         * ID of contact address to return
         */
        contactAddressId: number;
    };
    query?: never;
    url: '/ContactAddress/{contactAddressId}';
};

export type ContactAddressIdErrors = {
    /**
     * Bad request. Contact address was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ContactAddressIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactAddressResponse>;
    };
};

export type ContactAddressIdResponse = ContactAddressIdResponses[keyof ContactAddressIdResponses];

export type UpdateContactAddressData = {
    /**
     * Creation data
     */
    body?: ModelContactAddressUpdate;
    path: {
        /**
         * ID of contact address to return
         */
        contactAddressId: number;
    };
    query?: never;
    url: '/ContactAddress/{contactAddressId}';
};

export type UpdateContactAddressErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateContactAddressResponses = {
    /**
     * Created - Returns created contact address
     */
    201: ModelContactAddressResponse;
};

export type UpdateContactAddressResponse = UpdateContactAddressResponses[keyof UpdateContactAddressResponses];

export type GetCommunicationWaysData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * ID of contact for which you want the communication ways.
         */
        'contact[id]'?: string;
        /**
         * Object name. Only needed if you also defined the ID of a contact.
         */
        'contact[objectName]'?: string;
        /**
         * Type of the communication ways you want to get.
         */
        type?: 'PHONE' | 'EMAIL' | 'WEB' | 'MOBILE';
        /**
         * Define if you only want the main communication way.
         */
        main?: '0' | '1';
    };
    url: '/CommunicationWay';
};

export type GetCommunicationWaysErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetCommunicationWaysResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCommunicationWayResponse>;
    };
};

export type GetCommunicationWaysResponse = GetCommunicationWaysResponses[keyof GetCommunicationWaysResponses];

export type CreateCommunicationWayData = {
    /**
     * Creation data
     */
    body?: ModelCommunicationWayWritable;
    path?: never;
    query?: never;
    url: '/CommunicationWay';
};

export type CreateCommunicationWayErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateCommunicationWayResponses = {
    /**
     * Created - Returns created contact communication way
     */
    201: ModelCommunicationWayResponse;
};

export type CreateCommunicationWayResponse = CreateCommunicationWayResponses[keyof CreateCommunicationWayResponses];

export type DeleteCommunicationWayData = {
    body?: never;
    path: {
        /**
         * Id of communication way resource to delete
         */
        communicationWayId: number;
    };
    query?: never;
    url: '/CommunicationWay/{communicationWayId}';
};

export type DeleteCommunicationWayErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteCommunicationWayResponses = {
    /**
     * Successful operation - Communication way deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteCommunicationWayResponse = DeleteCommunicationWayResponses[keyof DeleteCommunicationWayResponses];

export type GetCommunicationWayByIdData = {
    body?: never;
    path: {
        /**
         * ID of communication way to return
         */
        communicationWayId: number;
    };
    query?: never;
    url: '/CommunicationWay/{communicationWayId}';
};

export type GetCommunicationWayByIdErrors = {
    /**
     * Bad request. communication way was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetCommunicationWayByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCommunicationWayResponse>;
    };
};

export type GetCommunicationWayByIdResponse = GetCommunicationWayByIdResponses[keyof GetCommunicationWayByIdResponses];

export type UpdateCommunicationWayData = {
    /**
     * Update data
     */
    body?: ModelCommunicationWayUpdate;
    path: {
        /**
         * ID of CommunicationWay to update
         */
        communicationWayId: number;
    };
    query?: never;
    url: '/CommunicationWay/{communicationWayId}';
};

export type UpdateCommunicationWayErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateCommunicationWayResponses = {
    /**
     * Successful operation - Returns changed CommunicationWay resource
     */
    200: ModelCommunicationWayResponse;
};

export type UpdateCommunicationWayResponse = UpdateCommunicationWayResponses[keyof UpdateCommunicationWayResponses];

export type GetCommunicationWayKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/CommunicationWayKey';
};

export type GetCommunicationWayKeysErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetCommunicationWayKeysResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<{
            /**
             * The id of the communication way key
             * 1. ID: 1 - Privat
             * 2. ID: 2 - Arbeit
             * 3. ID: 3 - Fax
             * 4. ID: 4 - Mobil
             * 5. ID: 5 - " "
             * 6. ID: 6 - Autobox
             * 7. ID: 7 - Newsletter
             * 8. ID: 8 - Rechnungsadresse
             */
            id?: string;
            /**
             * object name which is 'CommunicationWayKey'.
             */
            objectName?: string;
            /**
             * Date the communication way key was created
             */
            create?: string;
            /**
             * Date the communication way key was last updated
             */
            upadate?: string;
            /**
             * Name of the communication way key
             */
            name?: 'Arbeit' | 'Autobox' | 'Fax' | 'Mobil' | 'Newsletter' | 'Privat' | 'Rechnungsadresse' | ' ';
            translationCode?: string;
        }>;
    };
};

export type GetCommunicationWayKeysResponse = GetCommunicationWayKeysResponses[keyof GetCommunicationWayKeysResponses];

export type GetAccountingContactData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * ID of contact for which you want the accounting contact.
         */
        'contact[id]'?: string;
        /**
         * Object name. Only needed if you also defined the ID of a contact.
         */
        'contact[objectName]'?: string;
    };
    url: '/AccountingContact';
};

export type GetAccountingContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetAccountingContactResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelAccountingContactResponse>;
    };
};

export type GetAccountingContactResponse = GetAccountingContactResponses[keyof GetAccountingContactResponses];

export type CreateAccountingContactData = {
    /**
     * Creation data
     */
    body?: ModelAccountingContact;
    path?: never;
    query?: never;
    url: '/AccountingContact';
};

export type CreateAccountingContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateAccountingContactResponses = {
    /**
     * Created - Returns created accounting contact
     */
    201: ModelAccountingContactResponse;
};

export type CreateAccountingContactResponse = CreateAccountingContactResponses[keyof CreateAccountingContactResponses];

export type DeleteAccountingContactData = {
    body?: never;
    path: {
        /**
         * Id of accounting contact resource to delete
         */
        accountingContactId: number;
    };
    query?: never;
    url: '/AccountingContact/{accountingContactId}';
};

export type DeleteAccountingContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteAccountingContactResponses = {
    /**
     * Successful operation - accounting contact deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteAccountingContactResponse = DeleteAccountingContactResponses[keyof DeleteAccountingContactResponses];

export type GetAccountingContactByIdData = {
    body?: never;
    path: {
        /**
         * ID of accounting contact to return
         */
        accountingContactId: number;
    };
    query?: never;
    url: '/AccountingContact/{accountingContactId}';
};

export type GetAccountingContactByIdErrors = {
    /**
     * Bad request. Accounting contact was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetAccountingContactByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelAccountingContactResponse>;
    };
};

export type GetAccountingContactByIdResponse = GetAccountingContactByIdResponses[keyof GetAccountingContactByIdResponses];

export type UpdateAccountingContactData = {
    /**
     * Update data
     */
    body?: ModelAccountingContactUpdate;
    path: {
        /**
         * ID of accounting contact to update
         */
        accountingContactId: number;
    };
    query?: never;
    url: '/AccountingContact/{accountingContactId}';
};

export type UpdateAccountingContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateAccountingContactResponses = {
    /**
     * Successful operation - Returns changed accounting contact resource
     */
    200: ModelAccountingContactResponse;
};

export type UpdateAccountingContactResponse = UpdateAccountingContactResponses[keyof UpdateAccountingContactResponses];

export type GetPlaceholderData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Model name
         */
        objectName: 'Invoice' | 'CreditNote' | 'Order' | 'Contact' | 'Letter' | 'Email';
        /**
         * Sub model name, required if you have "Email" at objectName
         */
        subObjectName?: 'Invoice' | 'CreditNote' | 'Order' | 'Contact' | 'Letter';
    };
    url: '/Textparser/fetchDictionaryEntriesByType';
};

export type GetPlaceholderErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetPlaceholderResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelTextparserFetchDictionaryEntriesByTypeResponse>;
    };
};

export type GetPlaceholderResponse = GetPlaceholderResponses[keyof GetPlaceholderResponses];

export type GetContactFieldsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/ContactCustomField';
};

export type GetContactFieldsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactFieldsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactCustomFieldResponse>;
    };
};

export type GetContactFieldsResponse = GetContactFieldsResponses[keyof GetContactFieldsResponses];

export type CreateContactFieldData = {
    body?: ModelContactCustomField;
    path?: never;
    query?: never;
    url: '/ContactCustomField';
};

export type CreateContactFieldErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateContactFieldResponses = {
    /**
     * Successful operation
     */
    200: ModelContactCustomFieldResponse;
};

export type CreateContactFieldResponse = CreateContactFieldResponses[keyof CreateContactFieldResponses];

export type DeleteContactCustomFieldIdData = {
    body?: never;
    path: {
        /**
         * Id of contact field
         */
        contactCustomFieldId: number;
    };
    query?: never;
    url: '/ContactCustomField/{contactCustomFieldId}';
};

export type DeleteContactCustomFieldIdErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteContactCustomFieldIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteContactCustomFieldIdResponse = DeleteContactCustomFieldIdResponses[keyof DeleteContactCustomFieldIdResponses];

export type GetContactFieldsByIdData = {
    body?: never;
    path: {
        /**
         * id of the contact field
         */
        contactCustomFieldId: number;
    };
    query?: never;
    url: '/ContactCustomField/{contactCustomFieldId}';
};

export type GetContactFieldsByIdErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactFieldsByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactCustomFieldResponse>;
    };
};

export type GetContactFieldsByIdResponse = GetContactFieldsByIdResponses[keyof GetContactFieldsByIdResponses];

export type UpdateContactfieldData = {
    /**
     * Update data
     */
    body?: ModelContactCustomFieldUpdate;
    path: {
        /**
         * id of the contact field
         */
        contactCustomFieldId: number;
    };
    query?: never;
    url: '/ContactCustomField/{contactCustomFieldId}';
};

export type UpdateContactfieldErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateContactfieldResponses = {
    /**
     * Successful operation
     */
    200: ModelContactCustomFieldResponse;
};

export type UpdateContactfieldResponse = UpdateContactfieldResponses[keyof UpdateContactfieldResponses];

export type GetContactFieldSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/ContactCustomFieldSetting';
};

export type GetContactFieldSettingsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactFieldSettingsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactCustomFieldSettingResponse>;
    };
};

export type GetContactFieldSettingsResponse = GetContactFieldSettingsResponses[keyof GetContactFieldSettingsResponses];

export type CreateContactFieldSettingData = {
    body?: ModelContactCustomFieldSetting;
    path?: never;
    query?: never;
    url: '/ContactCustomFieldSetting';
};

export type CreateContactFieldSettingErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateContactFieldSettingResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactCustomFieldSettingResponse>;
    };
};

export type CreateContactFieldSettingResponse = CreateContactFieldSettingResponses[keyof CreateContactFieldSettingResponses];

export type DeleteContactFieldSettingData = {
    body?: never;
    path: {
        /**
         * Id of contact field to delete
         */
        contactCustomFieldSettingId: number;
    };
    query?: never;
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}';
};

export type DeleteContactFieldSettingErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteContactFieldSettingResponses = {
    /**
     * Successful operation - contact field deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteContactFieldSettingResponse = DeleteContactFieldSettingResponses[keyof DeleteContactFieldSettingResponses];

export type GetContactFieldSettingByIdData = {
    body?: never;
    path: {
        /**
         * ID of contact field to return
         */
        contactCustomFieldSettingId: number;
    };
    query?: never;
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}';
};

export type GetContactFieldSettingByIdErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetContactFieldSettingByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelContactCustomFieldSettingResponse>;
    };
};

export type GetContactFieldSettingByIdResponse = GetContactFieldSettingByIdResponses[keyof GetContactFieldSettingByIdResponses];

export type UpdateContactFieldSettingData = {
    body?: ModelContactCustomFieldSettingUpdate;
    path: {
        /**
         * ID of contact field setting you want to update
         */
        contactCustomFieldSettingId: number;
    };
    query?: never;
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}';
};

export type UpdateContactFieldSettingErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateContactFieldSettingResponses = {
    /**
     * Successful operation
     */
    200: ModelContactCustomFieldSettingResponse;
};

export type UpdateContactFieldSettingResponse = UpdateContactFieldSettingResponses[keyof UpdateContactFieldSettingResponses];

export type GetReferenceCountData = {
    body?: never;
    path: {
        /**
         * ID of contact field you want to get the reference count
         */
        contactCustomFieldSettingId: number;
    };
    query?: never;
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}/getReferenceCount';
};

export type GetReferenceCountErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetReferenceCountResponses = {
    /**
     * Successful operation - contact field deleted
     */
    200: {
        /**
         * the count of all references
         */
        objects?: number;
    };
};

export type GetReferenceCountResponse = GetReferenceCountResponses[keyof GetReferenceCountResponses];

export type GetCreditNotesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Status of the CreditNote
         */
        status?: '100' | '200' | '300' | '500' | '750' | '1000';
        /**
         * Retrieve all CreditNotes with this creditNote number
         */
        creditNoteNumber?: string;
        /**
         * Retrieve all CreditNotes with a date equal or higher
         */
        startDate?: number;
        /**
         * Retrieve all CreditNotes with a date equal or lower
         */
        endDate?: number;
        /**
         * Retrieve all CreditNotes with this contact. Must be provided with contact[objectName]
         */
        'contact[id]'?: number;
        /**
         * Only required if contact[id] was provided. 'Contact' should be used as value.
         */
        'contact[objectName]'?: string;
    };
    url: '/CreditNote';
};

export type GetCreditNotesErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetCreditNotesResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCreditNoteResponse>;
    };
};

export type GetCreditNotesResponse = GetCreditNotesResponses[keyof GetCreditNotesResponses];

export type CreatecreditNoteData = {
    /**
     * Creation data. Please be aware, that you need to provide at least all required parameter
     * of the credit note model!
     */
    body?: SaveCreditNoteWritable;
    path?: never;
    query?: never;
    url: '/CreditNote/Factory/saveCreditNote';
};

export type CreatecreditNoteErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreatecreditNoteResponses = {
    /**
     * Created - Returns created credit note
     */
    201: SaveCreditNoteResponse;
};

export type CreatecreditNoteResponse = CreatecreditNoteResponses[keyof CreatecreditNoteResponses];

export type CreateCreditNoteFromInvoiceData = {
    body?: {
        invoice: {
            /**
             * The id of the existing invoice
             */
            id: number;
            /**
             * The objectName must be 'Invoice'
             */
            objectName: string;
        };
    };
    path?: never;
    query?: never;
    url: '/CreditNote/Factory/createFromInvoice';
};

export type CreateCreditNoteFromInvoiceErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateCreditNoteFromInvoiceResponses = {
    /**
     * Created
     */
    201: {
        objects?: {
            creditNote?: ModelCreditNoteResponse;
            /**
             * An array of creditNote positions
             */
            creditNotePos?: Array<ModelCreditNotePosResponse>;
            /**
             * An array of discounts (can be empty)
             */
            discount?: Array<ModelDiscountsResponse>;
        };
    };
};

export type CreateCreditNoteFromInvoiceResponse = CreateCreditNoteFromInvoiceResponses[keyof CreateCreditNoteFromInvoiceResponses];

export type CreateCreditNoteFromVoucherData = {
    body?: {
        voucher: {
            /**
             * The id of the existing Voucher
             */
            id: number;
            /**
             * The objectName must be 'Voucher'
             */
            objectName: string;
        };
    };
    path?: never;
    query?: never;
    url: '/CreditNote/Factory/createFromVoucher';
};

export type CreateCreditNoteFromVoucherErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateCreditNoteFromVoucherResponses = {
    /**
     * Created
     */
    201: {
        objects?: {
            creditNote?: ModelCreditNoteResponse;
            /**
             * An array of creditNote positions
             */
            creditNotePos?: Array<ModelCreditNotePosResponse>;
            /**
             * An array of discounts (can be empty)
             */
            discount?: Array<ModelDiscountsResponse>;
        };
    };
};

export type CreateCreditNoteFromVoucherResponse = CreateCreditNoteFromVoucherResponses[keyof CreateCreditNoteFromVoucherResponses];

export type DeletecreditNoteData = {
    body?: never;
    path: {
        /**
         * Id of creditNote resource to delete
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}';
};

export type DeletecreditNoteErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict - f.e occurs if the creditNote is not a draft
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeletecreditNoteResponses = {
    /**
     * Successful operation - creditNote deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeletecreditNoteResponse = DeletecreditNoteResponses[keyof DeletecreditNoteResponses];

export type GetcreditNoteByIdData = {
    body?: never;
    path: {
        /**
         * ID of creditNote to return
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}';
};

export type GetcreditNoteByIdErrors = {
    /**
     * Bad request. creditNote was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetcreditNoteByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCreditNoteResponse>;
    };
};

export type GetcreditNoteByIdResponse = GetcreditNoteByIdResponses[keyof GetcreditNoteByIdResponses];

export type UpdatecreditNoteData = {
    /**
     * Update data
     */
    body?: ModelCreditNoteUpdateWritable;
    path: {
        /**
         * ID of creditNote to update
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}';
};

export type UpdatecreditNoteErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdatecreditNoteResponses = {
    /**
     * Successful operation - Returns changed creditNote resource
     */
    200: ModelCreditNoteResponse;
};

export type UpdatecreditNoteResponse = UpdatecreditNoteResponses[keyof UpdatecreditNoteResponses];

export type SendCreditNoteByPrintingData = {
    body?: never;
    path: {
        /**
         * ID of creditNote to return
         */
        creditNoteId: number;
    };
    query: {
        /**
         * the type you want to print.
         */
        sendType: string;
    };
    url: '/CreditNote/{creditNoteId}/sendByWithRender';
};

export type SendCreditNoteByPrintingErrors = {
    /**
     * Bad request.
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type SendCreditNoteByPrintingResponses = {
    /**
     * Successful operation
     */
    200: ModelCreditNoteSendByWithRender;
};

export type SendCreditNoteByPrintingResponse = SendCreditNoteByPrintingResponses[keyof SendCreditNoteByPrintingResponses];

export type CreditNoteSendByData = {
    /**
     * Specify the send type
     */
    body?: {
        /**
         * Specifies the way in which the credit note was sent to the customer.<br>
         * Accepts 'VPR' (print), 'VP' (postal), 'VM' (mail) and 'VPDF' (downloaded pfd).
         */
        sendType: 'VPR' | 'VP' | 'VM' | 'VPDF';
        /**
         * To create a draft of a credit note for internal use. This operation will not alter the status of the credit note or create bookings for reports.
         */
        sendDraft: boolean;
    };
    path: {
        /**
         * ID of credit note to mark as sent
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}/sendBy';
};

export type CreditNoteSendByErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreditNoteSendByResponses = {
    /**
     * Successful operation - Returns changed credit note log entry
     */
    200: ModelCreditNoteResponse;
};

export type CreditNoteSendByResponse = CreditNoteSendByResponses[keyof CreditNoteSendByResponses];

export type CreditNoteEnshrineData = {
    body?: never;
    path: {
        /**
         * ID of the credit note to enshrine
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}/enshrine';
};

export type CreditNoteEnshrineErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreditNoteEnshrineError = CreditNoteEnshrineErrors[keyof CreditNoteEnshrineErrors];

export type CreditNoteEnshrineResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: unknown;
    };
};

export type CreditNoteEnshrineResponse = CreditNoteEnshrineResponses[keyof CreditNoteEnshrineResponses];

export type CreditNoteGetPdfData = {
    body?: never;
    path: {
        /**
         * ID of credit note from which you want the pdf
         */
        creditNoteId: number;
    };
    query?: {
        /**
         * If u want to download the pdf of the credit note.
         */
        download?: boolean;
        /**
         * Defines if u want to send the credit note.
         */
        preventSendBy?: boolean;
    };
    url: '/CreditNote/{creditNoteId}/getPdf';
};

export type CreditNoteGetPdfErrors = {
    /**
     * Bad request. Invoice was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreditNoteGetPdfResponses = {
    /**
     * A pdf file
     */
    200: {
        filename?: string;
        mimeType?: string;
        base64encoded?: boolean;
        content?: Blob | File;
    };
};

export type CreditNoteGetPdfResponse = CreditNoteGetPdfResponses[keyof CreditNoteGetPdfResponses];

export type SendCreditNoteViaEMailData = {
    /**
     * Mail data
     */
    body?: {
        /**
         * The recipient of the email.
         */
        toEmail: string;
        /**
         * The subject of the email.
         */
        subject: string;
        /**
         * The text of the email. Can contain html.
         */
        text: string;
        /**
         * Should a copy of this email be sent to you?
         */
        copy?: boolean;
        /**
         * Additional attachments to the mail. String of IDs of existing documents in your
         * *                      sevdesk account separated by ','
         */
        additionalAttachments?: string;
        /**
         * String of mail addresses to be put as cc separated by ','
         */
        ccEmail?: string;
        /**
         * String of mail addresses to be put as bcc separated by ','
         */
        bccEmail?: string;
    };
    path: {
        /**
         * ID of credit note to be sent via email
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}/sendViaEmail';
};

export type SendCreditNoteViaEMailErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type SendCreditNoteViaEMailResponses = {
    /**
     * Created - Returns created mail object
     */
    201: {
        objects?: Array<ModelCreditNoteMailResponse>;
    };
};

export type SendCreditNoteViaEMailResponse = SendCreditNoteViaEMailResponses[keyof SendCreditNoteViaEMailResponses];

export type BookCreditNoteData = {
    /**
     * Booking data
     */
    body?: {
        /**
         * Amount which should be booked. Can also be a partial amount.
         */
        amount: number;
        /**
         * The booking date. Most likely the current date.
         */
        date: number;
        /**
         * Define a type for the booking.<br>
         * The following type abbreviations are available (abbreviation <-> meaning).<br>
         * <ul>
         * <li>FULL_PAYMENT <-> Normal booking</li><li>N <-> Partial booking (historically used for normal booking)</li>
         * <li>CB <-> Reduced amount due to discount (skonto)</li>
         * <li>CF <-> Reduced/Higher amount due to currency fluctuations (deprecated)</li>
         * <li>O <-> Reduced/Higher amount due to other reasons</li>
         * <li>OF <-> Higher amount due to reminder charges</li>
         * <li>MTC <-> Reduced amount due to the monetary traffic costs</li>
         * </ul>
         */
        type: 'FULL_PAYMENT' | 'N' | 'CB' | 'CF' | 'O' | 'OF' | 'MTC';
        /**
         * The check account on which should be booked.
         */
        checkAccount: {
            /**
             * The id of the check account on which should be booked.
             */
            id: number;
            /**
             * Internal object name which is 'CheckAccount'.
             */
            objectName: string;
        };
        /**
         * The check account transaction on which should be booked.<br>
         * The transaction will be linked to the credit note.
         */
        checkAccountTransaction?: {
            /**
             * The id of the check account transaction on which should be booked.
             */
            id: number;
            /**
             * Internal object name which is 'CheckAccountTransaction'.
             */
            objectName: string;
        };
        /**
         * Determines if a feed is created for the booking process.
         */
        createFeed?: boolean;
    };
    path: {
        /**
         * ID of credit note to book
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}/bookAmount';
};

export type BookCreditNoteErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type BookCreditNoteResponses = {
    /**
     * Successful operation - Returns changed invoice log entry
     */
    200: {
        id?: string;
        objectName?: string;
        additionalInformation?: string;
        /**
         * Date of email creation
         */
        create?: string;
        creditNote?: {
            /**
             * The id of the credit note
             */
            id: number;
            /**
             * Internal object name which is 'CreditNote'.
             */
            objectName: string;
        };
        fromStatus?: string;
        toStatus?: string;
        ammountPayed?: string;
        bookingDate?: string;
        /**
         * Client to which creditNote belongs. Will be filled automatically
         */
        sevClient?: {
            /**
             * Unique identifier of the client
             */
            id: number;
            /**
             * Model name, which is 'SevClient'
             */
            objectName: string;
        };
    };
};

export type BookCreditNoteResponse = BookCreditNoteResponses[keyof BookCreditNoteResponses];

export type CreditNoteResetToOpenData = {
    body?: never;
    path: {
        /**
         * ID of the credit note to reset
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}/resetToOpen';
};

export type CreditNoteResetToOpenErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreditNoteResetToOpenError = CreditNoteResetToOpenErrors[keyof CreditNoteResetToOpenErrors];

export type CreditNoteResetToOpenResponses = {
    /**
     * Successful operation - Returns changed credit note
     */
    200: {
        objects?: ModelCreditNoteResponse & {
            status?: unknown;
        };
    };
};

export type CreditNoteResetToOpenResponse = CreditNoteResetToOpenResponses[keyof CreditNoteResetToOpenResponses];

export type CreditNoteResetToDraftData = {
    body?: never;
    path: {
        /**
         * ID of the credit note to reset
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}/resetToDraft';
};

export type CreditNoteResetToDraftErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreditNoteResetToDraftError = CreditNoteResetToDraftErrors[keyof CreditNoteResetToDraftErrors];

export type CreditNoteResetToDraftResponses = {
    /**
     * Successful operation - Returns changed credit note
     */
    200: {
        objects?: ModelCreditNoteResponse & {
            taxText?: unknown;
            customerInternalNote?: unknown;
        };
    };
};

export type CreditNoteResetToDraftResponse = CreditNoteResetToDraftResponses[keyof CreditNoteResetToDraftResponses];

export type GetcreditNotePositionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Retrieve all creditNote positions belonging to this creditNote. Must be provided with creditNote[objectName]
         */
        'creditNote[id]'?: number;
        /**
         * Only required if creditNote[id] was provided. 'creditNote' should be used as value.
         */
        'creditNote[objectName]'?: string;
    };
    url: '/CreditNotePos';
};

export type GetcreditNotePositionsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetcreditNotePositionsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelCreditNotePosResponse>;
    };
};

export type GetcreditNotePositionsResponse = GetcreditNotePositionsResponses[keyof GetcreditNotePositionsResponses];

export type UpdateExportConfigData = {
    /**
     * Specify the update
     */
    body?: {
        accountantNumber: number;
        accountantClientNumber: number;
        accountingYearBegin: number;
    };
    path: {
        /**
         * id of sevClient
         */
        SevClientId: number;
    };
    query?: never;
    url: '/SevClient/{SevClientId}/updateExportConfig';
};

export type UpdateExportConfigErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateExportConfigResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: unknown;
    };
};

export type UpdateExportConfigResponse = UpdateExportConfigResponses[keyof UpdateExportConfigResponses];

export type ExportDatevDepricatedData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Specifies if the document is downloaded
         */
        Download?: boolean;
        /**
         * The start date of the export as timestamp
         */
        startDate: number;
        /**
         * The end date of the export as timestamp
         */
        endDate: number;
        /**
         * Define what you want to include in the DATEV export. This parameter takes a string of 5 letters. Each stands for a model that should be included. Possible letters are: E (Earnings), X (Expenditure), T (Transactions), C (Cashregister), D (Assets). By providing one of those letter you specify that it should be included in the DATEV export. Some combinations are: EXTCD, EXTD 
         */
        scope: string;
        /**
         * include unpaid documents
         */
        withUnpaidDocuments?: boolean;
        /**
         * include enshrined documents
         */
        withEnshrinedDocuments?: boolean;
        /**
         * Specify if you want to enshrine all models which were included in the export
         */
        enshrine?: boolean;
    };
    url: '/Export/datevCSV';
};

export type ExportDatevDepricatedErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportDatevDepricatedResponses = {
    /**
     * Successful operation
     */
    200: {
        [key: string]: unknown;
    };
};

export type ExportDatevDepricatedResponse = ExportDatevDepricatedResponses[keyof ExportDatevDepricatedResponses];

export type ExportDatevCsvData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The start date of the export as timestamp
         */
        startDate: number;
        /**
         * The end date of the export as timestamp
         */
        endDate: number;
        /**
         * Define what you want to include in the DATEV export. This parameter takes a string of 5 letters. Each stands for a model that should be included. Possible letters are: E (Earnings), X (Expenditure), T (Transactions), C (Cashregister), D (Assets). By providing one of those letter you specify that it should be included in the DATEV export. Some combinations are: EXTCD, EXTD 
         */
        scope: string;
        /**
         * When this parameter is true, the export contains only paid documents where pay date is in the time range of startDate and endDate
         */
        exportByPaydate?: boolean;
        /**
         * If set to false, the export excludes enshrined documents
         */
        includeEnshrined?: boolean;
        /**
         * Specify if you want to enshrine all models which were included in the export
         */
        enshrineDocuments?: boolean;
        /**
         * Specify if you want to include the document images in the export
         */
        includeDocumentImages?: boolean;
    };
    url: '/Export/createDatevCsvZipExportJob';
};

export type ExportDatevCsvErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportDatevCsvResponses = {
    /**
     * Successful operation. Returns the ID of the export job.
     */
    200: {
        objects?: string;
    };
};

export type ExportDatevCsvResponse = ExportDatevCsvResponses[keyof ExportDatevCsvResponses];

export type ExportDatevXmlData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The start date of the export as ISO timestamp
         */
        startDate: number;
        /**
         * The end date of the export as ISO timestamp
         */
        endDate: number;
        /**
         * Define what you want to include in the DATEV export. This parameter takes a string of letters. Each letter stands for a document type that should be included. Possible letters are: E (Receipts, outgoing invoices & credit notes) and X (Expenditure documents).
         */
        scope: string;
        /**
         * When this parameter is true, the export contains only paid documents where pay date is in the time range of startDate and endDate
         */
        exportByPaydate?: boolean;
        /**
         * If set to false, the export excludes enshrined documents
         */
        includeEnshrined?: boolean;
        /**
         * If set to false, the export excludes already exported documents
         */
        includeExportedDocuments?: boolean;
        /**
         * If set to false, the export excludes XML files containing the data for each document
         */
        includeDocumentXml?: boolean;
    };
    url: '/Export/createDatevXmlZipExportJob';
};

export type ExportDatevXmlErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportDatevXmlResponses = {
    /**
     * Successful operation. Returns the ID of the export job.
     */
    200: {
        objects?: string;
    };
};

export type ExportDatevXmlResponse = ExportDatevXmlResponses[keyof ExportDatevXmlResponses];

export type GenerateDownloadHashData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The export job ID
         */
        jobId: string;
    };
    url: '/Progress/generateDownloadHash';
};

export type GenerateDownloadHashErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GenerateDownloadHashResponses = {
    /**
     * Successful operation. Returns progress hash.
     */
    200: {
        objects?: Array<ExportProgressData>;
    };
};

export type GenerateDownloadHashResponse = GenerateDownloadHashResponses[keyof GenerateDownloadHashResponses];

export type GetProgressData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The hash string of an export
         */
        hash: string;
    };
    url: '/Progress/getProgress';
};

export type GetProgressErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetProgressResponses = {
    /**
     * Successful operation.
     */
    200: {
        objects?: Array<ExportProgressData>;
    };
};

export type GetProgressResponse = GetProgressResponses[keyof GetProgressResponses];

export type JobDownloadInfoData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The export job ID
         */
        jobId: string;
    };
    url: '/ExportJob/jobDownloadInfo';
};

export type JobDownloadInfoErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type JobDownloadInfoResponses = {
    /**
     * Successful operation.
     */
    200: {
        objects?: Array<ExportJobDownloadInfo>;
    };
};

export type JobDownloadInfoResponse = JobDownloadInfoResponses[keyof JobDownloadInfoResponses];

export type ExportInvoiceData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name, which is 'Invoice'
             */
            modelName: unknown;
            /**
             * Model name, which is 'SevQuery'
             */
            objectName: unknown;
            filter?: {
                /**
                 * Type of invoices you want to export
                 * 1. RE - Rechnung
                 * 2. SR - Stornorechnung
                 * 3. TR - Teilrechnung
                 * 4. AR - Abschlagsrechnung
                 * 5. ER - Endrechnung
                 * 6. WKR - Wiederkehrende Rechnung
                 * 7. MA - Mahnung
                 */
                invoiceType?: Array<'Re' | 'SR' | 'TR' | 'AR' | 'ER' | 'WKR' | 'MA'>;
                /**
                 * Start date of the invoice
                 */
                startDate?: string;
                /**
                 * End date of the invoice
                 */
                endDate?: string;
                /**
                 * filters the invoices by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the invoices by amount
                 */
                startAmount?: number;
                /**
                 * filters the invoices by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Export/invoiceCsv';
};

export type ExportInvoiceErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportInvoiceResponses = {
    /**
     * Successful operation without download
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ExportInvoiceResponse = ExportInvoiceResponses[keyof ExportInvoiceResponses];

export type ExportInvoiceZipData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name, which is 'Invoice'
             */
            modelName: unknown;
            /**
             * Model name, which is 'SevQuery'
             */
            objectName: unknown;
            filter?: {
                /**
                 * Type of invoices you want to export
                 * 1. RE - Rechnung
                 * 2. SR - Stornorechnung
                 * 3. TR - Teilrechnung
                 * 4. AR - Abschlagsrechnung
                 * 5. ER - Endrechnung
                 * 6. WKR - Wiederkehrende Rechnung
                 * 7. MA - Mahnung
                 */
                invoiceType?: Array<'Re' | 'SR' | 'TR' | 'AR' | 'ER' | 'WKR' | 'MA'>;
                /**
                 * Start date of the invoice
                 */
                startDate?: string;
                /**
                 * End date of the invoice
                 */
                endDate?: string;
                /**
                 * filters the invoices by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the invoices by amount
                 */
                startAmount?: number;
                /**
                 * filters the invoices by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Export/invoiceZip';
};

export type ExportInvoiceZipErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportInvoiceZipResponses = {
    /**
     * Response without Download
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ExportInvoiceZipResponse = ExportInvoiceZipResponses[keyof ExportInvoiceZipResponses];

export type ExportCreditNoteData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name, which is 'CreditNote'
             */
            modelName: unknown;
            /**
             * Model name, which is 'SevQuery'
             */
            objectName: unknown;
            filter?: {
                /**
                 * Start date of the credit note
                 */
                startDate?: string;
                /**
                 * End date of the credit note
                 */
                endDate?: string;
                /**
                 * filters the credit notes by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the credit notes by amount
                 */
                startAmount?: number;
                /**
                 * filters the credit notes by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Export/creditNoteCsv';
};

export type ExportCreditNoteErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportCreditNoteResponses = {
    /**
     * Successful operation with download
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ExportCreditNoteResponse = ExportCreditNoteResponses[keyof ExportCreditNoteResponses];

export type ExportVoucherData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name, which is 'Voucher'
             */
            modelName: unknown;
            /**
             * Model name, which is 'SevQuery'
             */
            objectName: unknown;
            filter?: {
                /**
                 * Start date of the voucher
                 */
                startDate?: string;
                /**
                 * End date of the voucher
                 */
                endDate?: string;
                /**
                 * Start pay date of the voucher
                 */
                startPayDate?: string;
                /**
                 * End pay date of the voucher
                 */
                endPayDate?: string;
                /**
                 * filters the vouchers by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the vouchers by amount
                 */
                startAmount?: number;
                /**
                 * filters the vouchers by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Export/voucherListCsv';
};

export type ExportVoucherErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportVoucherResponses = {
    /**
     * Successful operation without download
     */
    200: {
        filename?: string;
        mimetype?: string;
        base64Encoded?: boolean;
        content?: string;
    };
};

export type ExportVoucherResponse = ExportVoucherResponses[keyof ExportVoucherResponses];

export type ExportTransactionsData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name, which is 'CheckAccountTransaction'
             */
            modelName: unknown;
            /**
             * Model name, which is 'SevQuery'
             */
            objectName: unknown;
            filter?: {
                /**
                 * the payment purpose
                 */
                paymtPurpose?: string;
                /**
                 * the name of the payee/payer
                 */
                name?: string;
                /**
                 * Start date of the transactions
                 */
                startDate?: string;
                /**
                 * End date of the transactions
                 */
                endDate?: string;
                /**
                 * filters the transactions by amount
                 */
                startAmount?: number;
                /**
                 * filters the transactions by amount
                 */
                endAmount?: number;
                checkAccount?: {
                    /**
                     * Id of the checkAccount
                     */
                    id: number;
                    /**
                     * Model name, which is 'CheckAccount'
                     */
                    objectName: string;
                };
            };
        };
    };
    url: '/Export/transactionsCsv';
};

export type ExportTransactionsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportTransactionsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ExportTransactionsResponse = ExportTransactionsResponses[keyof ExportTransactionsResponses];

export type ExportVoucherZipData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name, which is 'Voucher'
             */
            modelName: unknown;
            /**
             * Model name, which is 'SevQuery'
             */
            objectName: unknown;
            filter?: {
                /**
                 * Start date of the voucher
                 */
                startDate?: string;
                /**
                 * End date of the voucher
                 */
                endDate?: string;
                /**
                 * Start pay date of the voucher
                 */
                startPayDate?: string;
                /**
                 * End pay date of the voucher
                 */
                endPayDate?: string;
                /**
                 * filters the vouchers by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the vouchers by amount
                 */
                startAmount?: number;
                /**
                 * filters the vouchers by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Export/voucherZip';
};

export type ExportVoucherZipErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportVoucherZipResponses = {
    /**
     * Successful operation without download
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ExportVoucherZipResponse = ExportVoucherZipResponses[keyof ExportVoucherZipResponses];

export type ExportContactData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name, which is 'Contact'
             */
            modelName: unknown;
            /**
             * Model name, which is 'SevQuery'
             */
            objectName: unknown;
            filter?: {
                /**
                 * filters the contacts by zip code
                 */
                zip?: number;
                /**
                 * filters the contacts by city
                 */
                city?: string;
                country?: {
                    /**
                     * id of the country
                     */
                    id: number;
                    /**
                     * Model name, which is 'StaticCountry'
                     */
                    objectName: string;
                };
                /**
                 * export only organisations
                 */
                depth?: boolean;
                /**
                 * export only people
                 */
                onlyPeople?: boolean;
            };
        };
    };
    url: '/Export/contactListCsv';
};

export type ExportContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ExportContactResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ExportContactResponse = ExportContactResponses[keyof ExportContactResponses];

export type GetPartsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Retrieve all parts with this part number
         */
        partNumber?: string;
        /**
         * Retrieve all parts with this name
         */
        name?: string;
    };
    url: '/Part';
};

export type GetPartsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetPartsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelPart>;
    };
};

export type GetPartsResponse = GetPartsResponses[keyof GetPartsResponses];

export type CreatePartData = {
    /**
     * Creation data. Please be aware, that you need to provide at least all required parameter
     * of the part model!
     */
    body?: ModelPartWritable;
    path?: never;
    query?: never;
    url: '/Part';
};

export type CreatePartErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreatePartResponses = {
    /**
     * Created - Returns created part
     */
    201: ModelPart;
};

export type CreatePartResponse = CreatePartResponses[keyof CreatePartResponses];

export type GetPartByIdData = {
    body?: never;
    path: {
        /**
         * ID of part to return
         */
        partId: number;
    };
    query?: never;
    url: '/Part/{partId}';
};

export type GetPartByIdErrors = {
    /**
     * Bad request. Part was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetPartByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelPart>;
    };
};

export type GetPartByIdResponse = GetPartByIdResponses[keyof GetPartByIdResponses];

export type UpdatePartData = {
    /**
     * Update data
     */
    body?: ModelPartUpdateWritable;
    path: {
        /**
         * ID of part to update
         */
        partId: number;
    };
    query?: never;
    url: '/Part/{partId}';
};

export type UpdatePartErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdatePartResponses = {
    /**
     * Successful operation - Returns changed part resource
     */
    200: ModelPart;
};

export type UpdatePartResponse = UpdatePartResponses[keyof UpdatePartResponses];

export type PartGetStockData = {
    body?: never;
    path: {
        /**
         * ID of part for which you want the current stock.
         */
        partId: number;
    };
    query?: never;
    url: '/Part/{partId}/getStock';
};

export type PartGetStockErrors = {
    /**
     * Bad request. Part was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type PartGetStockResponses = {
    /**
     * Successful operation
     */
    200: {
        /**
         * Stock amount
         */
        objects?: number;
    };
};

export type PartGetStockResponse = PartGetStockResponses[keyof PartGetStockResponses];

export type GetInvoicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Status of the invoices
         */
        status?: 100 | 200 | 1000;
        /**
         * Retrieve all invoices with this invoice number
         */
        invoiceNumber?: string;
        /**
         * Retrieve all invoices with a date equal or higher
         */
        startDate?: number;
        /**
         * Retrieve all invoices with a date equal or lower
         */
        endDate?: number;
        /**
         * Retrieve all invoices with this contact. Must be provided with contact[objectName]
         */
        'contact[id]'?: number;
        /**
         * Only required if contact[id] was provided. 'Contact' should be used as value.
         */
        'contact[objectName]'?: string;
    };
    url: '/Invoice';
};

export type GetInvoicesErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetInvoicesResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelInvoiceResponse>;
    };
};

export type GetInvoicesResponse = GetInvoicesResponses[keyof GetInvoicesResponses];

export type CreateInvoiceByFactoryData = {
    /**
     * Creation data. Please be aware, that you need to provide at least all required parameter
     * of the invoice model!
     */
    body?: SaveInvoiceWritable;
    path?: never;
    query?: never;
    url: '/Invoice/Factory/saveInvoice';
};

export type CreateInvoiceByFactoryErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateInvoiceByFactoryResponses = {
    /**
     * Created - Returns created invoice
     */
    201: SaveInvoiceResponse;
};

export type CreateInvoiceByFactoryResponse = CreateInvoiceByFactoryResponses[keyof CreateInvoiceByFactoryResponses];

export type GetInvoiceByIdData = {
    body?: never;
    path: {
        /**
         * ID of invoice to return
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}';
};

export type GetInvoiceByIdErrors = {
    /**
     * Bad request. Invoice was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetInvoiceByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelInvoiceResponse>;
    };
};

export type GetInvoiceByIdResponse = GetInvoiceByIdResponses[keyof GetInvoiceByIdResponses];

export type GetInvoicePositionsByIdData = {
    body?: never;
    path: {
        /**
         * ID of invoice to return the positions
         */
        invoiceId: number;
    };
    query?: {
        /**
         * limits the number of entries returned
         */
        limit?: number;
        /**
         * set the index where the returned entries start
         */
        offset?: number;
        /**
         * Get some additional information. Embed can handle multiple values, they must be separated by comma.
         */
        embed?: Array<string>;
    };
    url: '/Invoice/{invoiceId}/getPositions';
};

export type GetInvoicePositionsByIdErrors = {
    /**
     * Bad request. Invoice was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetInvoicePositionsByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelInvoicePosResponse>;
    };
};

export type GetInvoicePositionsByIdResponse = GetInvoicePositionsByIdResponses[keyof GetInvoicePositionsByIdResponses];

export type CreateInvoiceFromOrderData = {
    /**
     * Create invoice
     */
    body?: ModelCreateInvoiceFromOrder;
    path?: never;
    query?: never;
    url: '/Invoice/Factory/createInvoiceFromOrder';
};

export type CreateInvoiceFromOrderErrors = {
    /**
     * Bad Request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateInvoiceFromOrderResponses = {
    /**
     * Successful operation
     */
    200: ModelInvoiceResponse;
};

export type CreateInvoiceFromOrderResponse = CreateInvoiceFromOrderResponses[keyof CreateInvoiceFromOrderResponses];

export type CreateInvoiceReminderData = {
    /**
     * Create invoice
     */
    body?: {
        /**
         * Invoice for the reminder
         */
        invoice: {
            /**
             * Id of the invoice
             */
            id: number;
            /**
             * Model name, which is 'Invoice'
             */
            objectName: string;
        };
    };
    path?: never;
    query: {
        /**
         * the id of the invoice
         */
        'invoice[id]': number;
        /**
         * Model name, which is 'Invoice'
         */
        'invoice[objectName]': string;
    };
    url: '/Invoice/Factory/createInvoiceReminder';
};

export type CreateInvoiceReminderErrors = {
    /**
     * Bad Request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateInvoiceReminderResponses = {
    /**
     * Successful operation
     */
    200: ModelInvoiceResponse;
};

export type CreateInvoiceReminderResponse = CreateInvoiceReminderResponses[keyof CreateInvoiceReminderResponses];

export type GetIsInvoicePartiallyPaidData = {
    body?: never;
    path: {
        /**
         * ID of invoice to return
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/getIsPartiallyPaid';
};

export type GetIsInvoicePartiallyPaidErrors = {
    /**
     * Bad Request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetIsInvoicePartiallyPaidResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: boolean;
    };
};

export type GetIsInvoicePartiallyPaidResponse = GetIsInvoicePartiallyPaidResponses[keyof GetIsInvoicePartiallyPaidResponses];

export type CancelInvoiceData = {
    body?: never;
    path: {
        /**
         * ID of invoice to be cancelled
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/cancelInvoice';
};

export type CancelInvoiceErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CancelInvoiceResponses = {
    /**
     * Created - Returns cancellation invoice
     */
    201: ModelInvoiceResponse;
};

export type CancelInvoiceResponse = CancelInvoiceResponses[keyof CancelInvoiceResponses];

export type InvoiceRenderData = {
    /**
     * Define if the document should be forcefully re-rendered.
     */
    body?: {
        /**
         * Define if a forceful re-render should occur.
         */
        forceReload?: boolean;
    };
    path: {
        /**
         * ID of invoice to render
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/render';
};

export type InvoiceRenderErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type InvoiceRenderResponses = {
    /**
     * Returns meta-data about pdf.
     */
    201: {
        thumbs?: Array<unknown>;
        pages?: number;
        docId?: string;
        parameters?: Array<{
            key?: string;
            name?: string;
            values?: Array<{
                name?: string;
                translationCade?: string;
                value?: string;
            }>;
            visible?: boolean;
            value?: string;
        }>;
    };
};

export type InvoiceRenderResponse = InvoiceRenderResponses[keyof InvoiceRenderResponses];

export type SendInvoiceViaEMailData = {
    /**
     * Mail data
     */
    body?: {
        /**
         * The recipient of the email.
         */
        toEmail: string;
        /**
         * The subject of the email.
         */
        subject: string;
        /**
         * The text of the email. Can contain html.
         */
        text: string;
        /**
         * Should a copy of this email be sent to you?
         */
        copy?: boolean;
        /**
         * Additional attachments to the mail. String of IDs of existing documents in your
         * *                      sevdesk account separated by ','
         */
        additionalAttachments?: string;
        /**
         * String of mail addresses to be put as cc separated by ','
         */
        ccEmail?: string;
        /**
         * String of mail addresses to be put as bcc separated by ','
         */
        bccEmail?: string;
        /**
         * If true, the XML of the e-invoice is attached to the email instead of the PDF
         */
        sendXml?: boolean;
    };
    path: {
        /**
         * ID of invoice to be sent via email
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/sendViaEmail';
};

export type SendInvoiceViaEMailErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type SendInvoiceViaEMailResponses = {
    /**
     * Created - Returns created mail object
     */
    201: ModelEmail;
};

export type SendInvoiceViaEMailResponse = SendInvoiceViaEMailResponses[keyof SendInvoiceViaEMailResponses];

export type InvoiceGetPdfData = {
    body?: never;
    path: {
        /**
         * ID of invoice from which you want the pdf
         */
        invoiceId: number;
    };
    query?: {
        /**
         * If u want to download the pdf of the invoice.
         */
        download?: boolean;
        /**
         * Defines if u want to send the invoice.
         */
        preventSendBy?: boolean;
    };
    url: '/Invoice/{invoiceId}/getPdf';
};

export type InvoiceGetPdfErrors = {
    /**
     * Bad request. Invoice was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type InvoiceGetPdfResponses = {
    /**
     * A pdf file
     */
    200: {
        filename?: string;
        mimeType?: string;
        base64encoded?: boolean;
        content?: Blob | File;
    };
};

export type InvoiceGetPdfResponse = InvoiceGetPdfResponses[keyof InvoiceGetPdfResponses];

export type InvoiceGetXmlData = {
    body?: never;
    path: {
        /**
         * ID of invoice from which you want the XML
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/getXml';
};

export type InvoiceGetXmlErrors = {
    /**
     * Bad request. Invoice was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type InvoiceGetXmlResponses = {
    /**
     * A xml file
     */
    200: {
        objects?: string;
    };
};

export type InvoiceGetXmlResponse = InvoiceGetXmlResponses[keyof InvoiceGetXmlResponses];

export type InvoiceSendByData = {
    /**
     * Specify the send type
     */
    body?: {
        /**
         * Specifies the way in which the invoice was sent to the customer.<br>
         * Accepts 'VPR' (print), 'VP' (postal), 'VM' (mail) and 'VPDF' (downloaded pfd).
         */
        sendType: 'VPR' | 'VP' | 'VM' | 'VPDF';
        /**
         * To create a draft of an invoice for internal use. This operation will not alter the status of the invoice or create bookings for reports.
         */
        sendDraft: boolean;
    };
    path: {
        /**
         * ID of invoice to mark as sent
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/sendBy';
};

export type InvoiceSendByErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type InvoiceSendByResponses = {
    /**
     * Successful operation - Returns changed invoice log entry
     */
    200: ModelInvoiceResponse;
};

export type InvoiceSendByResponse = InvoiceSendByResponses[keyof InvoiceSendByResponses];

export type InvoiceEnshrineData = {
    body?: never;
    path: {
        /**
         * ID of the invoice to enshrine
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/enshrine';
};

export type InvoiceEnshrineErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type InvoiceEnshrineError = InvoiceEnshrineErrors[keyof InvoiceEnshrineErrors];

export type InvoiceEnshrineResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: unknown;
    };
};

export type InvoiceEnshrineResponse = InvoiceEnshrineResponses[keyof InvoiceEnshrineResponses];

export type BookInvoiceData = {
    /**
     * Booking data
     */
    body?: {
        /**
         * Amount which should be booked. Can also be a partial amount.
         */
        amount: number;
        /**
         * The booking date. Most likely the current date.
         */
        date: number;
        /**
         * Define a type for the booking.<br>
         * The following type abbreviations are available (abbreviation <-> meaning).<br>
         * <ul>
         * <li>FULL_PAYMENT <-> Normal booking</li><li>N <-> Partial booking (historically used for normal booking)</li>
         * <li>CB <-> Reduced amount due to discount (skonto)</li>
         * <li>CF <-> Reduced/Higher amount due to currency fluctuations (deprecated)</li>
         * <li>O <-> Reduced/Higher amount due to other reasons</li>
         * <li>OF <-> Higher amount due to reminder charges</li>
         * <li>MTC <-> Reduced amount due to the monetary traffic costs</li>
         * </ul>
         */
        type: 'FULL_PAYMENT' | 'N' | 'CB' | 'CF' | 'O' | 'OF' | 'MTC';
        /**
         * The check account on which should be booked.
         */
        checkAccount: {
            /**
             * The id of the check account on which should be booked.
             */
            id: number;
            /**
             * Internal object name which is 'CheckAccount'.
             */
            objectName: string;
        };
        /**
         * The check account transaction on which should be booked.<br>
         * The transaction will be linked to the invoice.
         */
        checkAccountTransaction?: {
            /**
             * The id of the check account transaction on which should be booked.
             */
            id: number;
            /**
             * Internal object name which is 'CheckAccountTransaction'.
             */
            objectName: string;
        };
        /**
         * Determines if a feed is created for the booking process.
         */
        createFeed?: boolean;
    };
    path: {
        /**
         * ID of invoice to book
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/bookAmount';
};

export type BookInvoiceErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type BookInvoiceResponses = {
    /**
     * Successful operation - Returns changed invoice log entry
     */
    200: {
        id?: string;
        objectName?: string;
        additionalInformation?: string;
        /**
         * Date of email creation
         */
        create?: string;
        creditNote?: {
            /**
             * The id of the invoice
             */
            id: number;
            /**
             * Internal object name which is 'Invoice'.
             */
            objectName: string;
        };
        fromStatus?: string;
        toStatus?: string;
        ammountPayed?: string;
        bookingDate?: string;
        /**
         * Client to which invoice belongs. Will be filled automatically
         */
        sevClient?: {
            /**
             * Unique identifier of the client
             */
            id: number;
            /**
             * Model name, which is 'SevClient'
             */
            objectName: string;
        };
    };
};

export type BookInvoiceResponse = BookInvoiceResponses[keyof BookInvoiceResponses];

export type InvoiceResetToOpenData = {
    body?: never;
    path: {
        /**
         * ID of the invoice to reset
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/resetToOpen';
};

export type InvoiceResetToOpenErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type InvoiceResetToOpenError = InvoiceResetToOpenErrors[keyof InvoiceResetToOpenErrors];

export type InvoiceResetToOpenResponses = {
    /**
     * Successful operation - Returns changed invoice
     */
    200: {
        objects?: ModelInvoiceResponse & {
            status?: unknown;
            payDate?: unknown;
            enshrined?: unknown;
            accountIntervall?: unknown;
            accountNextInvoice?: unknown;
        };
    };
};

export type InvoiceResetToOpenResponse = InvoiceResetToOpenResponses[keyof InvoiceResetToOpenResponses];

export type InvoiceResetToDraftData = {
    body?: never;
    path: {
        /**
         * ID of the invoice to reset
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/resetToDraft';
};

export type InvoiceResetToDraftErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type InvoiceResetToDraftError = InvoiceResetToDraftErrors[keyof InvoiceResetToDraftErrors];

export type InvoiceResetToDraftResponses = {
    /**
     * Successful operation - Returns changed invoice
     */
    200: {
        objects?: ModelInvoiceResponse & {
            payDate?: unknown;
            enshrined?: unknown;
            accountIntervall?: unknown;
            accountNextInvoice?: unknown;
        };
    };
};

export type InvoiceResetToDraftResponse = InvoiceResetToDraftResponses[keyof InvoiceResetToDraftResponses];

export type GetInvoicePosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Retrieve all InvoicePos with this InvoicePos id
         */
        id?: number;
        /**
         * Retrieve all invoices positions with this invoice. Must be provided with invoice[objectName]
         */
        'invoice[id]'?: number;
        /**
         * Only required if invoice[id] was provided. 'Invoice' should be used as value.
         */
        'invoice[objectName]'?: string;
        /**
         * Retrieve all invoices positions with this part. Must be provided with part[objectName]
         */
        'part[id]'?: number;
        /**
         * Only required if part[id] was provided. 'Part' should be used as value.
         */
        'part[objectName]'?: string;
    };
    url: '/InvoicePos';
};

export type GetInvoicePosErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetInvoicePosResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelInvoicePosResponse>;
    };
};

export type GetInvoicePosResponse = GetInvoicePosResponses[keyof GetInvoicePosResponses];

export type GetLetterpapersWithThumbData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/DocServer/getLetterpapersWithThumb';
};

export type GetLetterpapersWithThumbErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetLetterpapersWithThumbResponses = {
    /**
     * Successful operation
     */
    200: {
        result?: string;
        letterpapers?: Array<{
            id?: string;
            pdf?: string;
            sevClient?: string;
            name?: string;
            default?: number;
            img?: string;
        }>;
    };
};

export type GetLetterpapersWithThumbResponse = GetLetterpapersWithThumbResponses[keyof GetLetterpapersWithThumbResponses];

export type GetTemplatesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Type of the templates you want to get.
         */
        type?: 'Invoice' | 'invoicereminder' | 'Order' | 'Contractnote' | 'Packinglist' | 'Letter' | 'Creditnote';
    };
    url: '/DocServer/getTemplatesWithThumb';
};

export type GetTemplatesErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetTemplatesResponses = {
    /**
     * Successful operation
     */
    200: {
        result?: string;
        templates?: Array<{
            id?: string;
            name?: string;
            translationCode?: string;
            sevClient?: string;
            type?: string;
            html?: string;
            default?: number;
            premium?: boolean;
        }>;
    };
};

export type GetTemplatesResponse = GetTemplatesResponses[keyof GetTemplatesResponses];

export type UpdateInvoiceTemplateData = {
    /**
     * Change Layout
     */
    body?: ModelChangeLayout;
    path: {
        /**
         * ID of invoice to update
         */
        invoiceId: number;
    };
    query?: never;
    url: '/Invoice/{invoiceId}/changeParameter';
};

export type UpdateInvoiceTemplateErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateInvoiceTemplateResponses = {
    /**
     * Successful operation
     */
    200: ModelChangeLayoutResponse;
};

export type UpdateInvoiceTemplateResponse = UpdateInvoiceTemplateResponses[keyof UpdateInvoiceTemplateResponses];

export type UpdateOrderTemplateData = {
    /**
     * Change Layout
     */
    body?: ModelChangeLayout;
    path: {
        /**
         * ID of order to update
         */
        orderId: number;
    };
    query?: never;
    url: '/Order/{orderId}/changeParameter';
};

export type UpdateOrderTemplateErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateOrderTemplateResponses = {
    /**
     * Successful operation
     */
    200: ModelChangeLayoutResponse;
};

export type UpdateOrderTemplateResponse = UpdateOrderTemplateResponses[keyof UpdateOrderTemplateResponses];

export type UpdateCreditNoteTemplateData = {
    /**
     * Change Layout
     */
    body?: ModelChangeLayout;
    path: {
        /**
         * ID of credit note to update
         */
        creditNoteId: number;
    };
    query?: never;
    url: '/CreditNote/{creditNoteId}/changeParameter';
};

export type UpdateCreditNoteTemplateErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateCreditNoteTemplateResponses = {
    /**
     * Successful operation
     */
    200: ModelChangeLayoutResponse;
};

export type UpdateCreditNoteTemplateResponse = UpdateCreditNoteTemplateResponses[keyof UpdateCreditNoteTemplateResponses];

export type GetOrdersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Status of the order
         */
        status?: 100 | 200 | 300 | 500 | 750 | 1000;
        /**
         * Retrieve all orders with this order number
         */
        orderNumber?: string;
        /**
         * Retrieve all orders with a date equal or higher
         */
        startDate?: number;
        /**
         * Retrieve all orders with a date equal or lower
         */
        endDate?: number;
        /**
         * Retrieve all orders with this contact. Must be provided with contact[objectName]
         */
        'contact[id]'?: number;
        /**
         * Only required if contact[id] was provided. 'Contact' should be used as value.
         */
        'contact[objectName]'?: string;
    };
    url: '/Order';
};

export type GetOrdersErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetOrdersResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelOrderResponse>;
    };
};

export type GetOrdersResponse = GetOrdersResponses[keyof GetOrdersResponses];

export type CreateOrderData = {
    /**
     * Creation data. Please be aware, that you need to provide at least all required parameter
     * of the order model!
     */
    body?: SaveOrderWritable;
    path?: never;
    query?: never;
    url: '/Order/Factory/saveOrder';
};

export type CreateOrderErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateOrderResponses = {
    /**
     * Created - Returns created voucher
     */
    201: SaveOrderResponse;
};

export type CreateOrderResponse = CreateOrderResponses[keyof CreateOrderResponses];

export type DeleteOrderData = {
    body?: never;
    path: {
        /**
         * Id of order resource to delete
         */
        orderId: number;
    };
    query?: never;
    url: '/Order/{orderId}';
};

export type DeleteOrderErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict - f.e occurs if the order is not a draft
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteOrderResponses = {
    /**
     * Successful operation - Order deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteOrderResponse = DeleteOrderResponses[keyof DeleteOrderResponses];

export type GetOrderByIdData = {
    body?: never;
    path: {
        /**
         * ID of order to return
         */
        orderId: number;
    };
    query?: never;
    url: '/Order/{orderId}';
};

export type GetOrderByIdErrors = {
    /**
     * Bad request. Order was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetOrderByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelOrderResponse>;
    };
};

export type GetOrderByIdResponse = GetOrderByIdResponses[keyof GetOrderByIdResponses];

export type UpdateOrderData = {
    /**
     * Update data
     */
    body?: ModelOrderUpdateWritable;
    path: {
        /**
         * ID of order to update
         */
        orderId: number;
    };
    query?: never;
    url: '/Order/{orderId}';
};

export type UpdateOrderErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateOrderResponses = {
    /**
     * Successful operation - Returns changed order resource
     */
    200: ModelOrderResponse;
};

export type UpdateOrderResponse = UpdateOrderResponses[keyof UpdateOrderResponses];

export type GetOrderPositionsByIdData = {
    body?: never;
    path: {
        /**
         * ID of order to return the positions
         */
        orderId: number;
    };
    query?: {
        /**
         * limits the number of entries returned
         */
        limit?: number;
        /**
         * set the index where the returned entries start
         */
        offset?: number;
        /**
         * Get some additional information. Embed can handle multiple values, they must be separated by comma.
         */
        embed?: Array<string>;
    };
    url: '/Order/{orderId}/getPositions';
};

export type GetOrderPositionsByIdErrors = {
    /**
     * Bad request. order was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetOrderPositionsByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelOrderPosResponse>;
    };
};

export type GetOrderPositionsByIdResponse = GetOrderPositionsByIdResponses[keyof GetOrderPositionsByIdResponses];

export type GetDiscountsData = {
    body?: never;
    path: {
        /**
         * ID of order to return the positions
         */
        orderId: number;
    };
    query?: {
        /**
         * limits the number of entries returned
         */
        limit?: number;
        /**
         * set the index where the returned entries start
         */
        offset?: number;
        /**
         * Get some additional information. Embed can handle multiple values, they must be separated by comma.
         */
        embed?: Array<string>;
    };
    url: '/Order/{orderId}/getDiscounts';
};

export type GetDiscountsErrors = {
    /**
     * Bad request. order was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetDiscountsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelDiscount>;
    };
};

export type GetDiscountsResponse = GetDiscountsResponses[keyof GetDiscountsResponses];

export type GetRelatedObjectsData = {
    body?: never;
    path: {
        /**
         * ID of order to return the positions
         */
        orderId: number;
    };
    query?: {
        /**
         * Define if the related objects include the order itself
         */
        includeItself?: boolean;
        /**
         * Define if you want the related objects sorted by type
         */
        sortByType?: boolean;
        /**
         * Get some additional information. Embed can handle multiple values, they must be separated by comma.
         */
        embed?: Array<string>;
    };
    url: '/Order/{orderId}/getRelatedObjects';
};

export type GetRelatedObjectsErrors = {
    /**
     * Bad request. order was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetRelatedObjectsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelOrderPosResponse>;
    };
};

export type GetRelatedObjectsResponse = GetRelatedObjectsResponses[keyof GetRelatedObjectsResponses];

export type SendorderViaEMailData = {
    /**
     * Mail data
     */
    body?: {
        /**
         * The recipient of the email.
         */
        toEmail: string;
        /**
         * The subject of the email.
         */
        subject: string;
        /**
         * The text of the email. Can contain html.
         */
        text: string;
        /**
         * Should a copy of this email be sent to you?
         */
        copy?: boolean;
        /**
         * Additional attachments to the mail. String of IDs of existing documents in your
         * *                      sevdesk account separated by ','
         */
        additionalAttachments?: string;
        /**
         * String of mail addresses to be put as cc separated by ','
         */
        ccEmail?: string;
        /**
         * String of mail addresses to be put as bcc separated by ','
         */
        bccEmail?: string;
    };
    path: {
        /**
         * ID of order to be sent via email
         */
        orderId: number;
    };
    query?: never;
    url: '/Order/{orderId}/sendViaEmail';
};

export type SendorderViaEMailErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type SendorderViaEMailResponses = {
    /**
     * Created - Returns created mail object
     */
    201: {
        objects?: Array<ModelEmailOrder>;
    };
};

export type SendorderViaEMailResponse = SendorderViaEMailResponses[keyof SendorderViaEMailResponses];

export type CreatePackingListFromOrderData = {
    /**
     * Create packing list
     */
    body?: ModelCreatePackingListFromOrder;
    path?: never;
    query: {
        /**
         * the id of the order
         */
        'order[id]': number;
        /**
         * Model name, which is 'Order'
         */
        'order[objectName]': string;
    };
    url: '/Order/Factory/createPackingListFromOrder';
};

export type CreatePackingListFromOrderErrors = {
    /**
     * Bad Request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreatePackingListFromOrderResponses = {
    /**
     * Successful operation
     */
    200: ModelOrderResponse;
};

export type CreatePackingListFromOrderResponse = CreatePackingListFromOrderResponses[keyof CreatePackingListFromOrderResponses];

export type CreateContractNoteFromOrderData = {
    /**
     * Create contract note
     */
    body?: ModelCreatePackingListFromOrder;
    path?: never;
    query: {
        /**
         * the id of the order
         */
        'order[id]': number;
        /**
         * Model name, which is 'Order'
         */
        'order[objectName]': string;
    };
    url: '/Order/Factory/createContractNoteFromOrder';
};

export type CreateContractNoteFromOrderErrors = {
    /**
     * Bad Request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateContractNoteFromOrderResponses = {
    /**
     * Successful operation
     */
    200: ModelOrderResponse;
};

export type CreateContractNoteFromOrderResponse = CreateContractNoteFromOrderResponses[keyof CreateContractNoteFromOrderResponses];

export type OrderGetPdfData = {
    body?: never;
    path: {
        /**
         * ID of order from which you want the pdf
         */
        orderId: number;
    };
    query?: {
        /**
         * If u want to download the pdf of the order.
         */
        download?: boolean;
        /**
         * Defines if u want to send the order.
         */
        preventSendBy?: boolean;
    };
    url: '/Order/{orderId}/getPdf';
};

export type OrderGetPdfErrors = {
    /**
     * Bad request. order was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type OrderGetPdfResponses = {
    /**
     * A pdf file
     */
    200: {
        filename?: string;
        mimeType?: string;
        base64encoded?: boolean;
        content?: Blob | File;
    };
};

export type OrderGetPdfResponse = OrderGetPdfResponses[keyof OrderGetPdfResponses];

export type OrderSendByData = {
    /**
     * Specify the send type
     */
    body?: {
        /**
         * Specifies the way in which the order was sent to the customer.<br>
         * Accepts 'VPR' (print), 'VP' (postal), 'VM' (mail) and 'VPDF' (downloaded pfd).
         */
        sendType: 'VPR' | 'VP' | 'VM' | 'VPDF';
        /**
         * To create a draft of an order for internal use. This operation will not alter the status of the order.
         */
        sendDraft: boolean;
    };
    path: {
        /**
         * ID of order to mark as sent
         */
        orderId: number;
    };
    query?: never;
    url: '/Order/{orderId}/sendBy';
};

export type OrderSendByErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type OrderSendByResponses = {
    /**
     * Successful operation - Returns changed order log entry
     */
    200: ModelOrderResponse;
};

export type OrderSendByResponse = OrderSendByResponses[keyof OrderSendByResponses];

export type GetOrderPositionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Retrieve all order positions belonging to this order. Must be provided with voucher[objectName]
         */
        'order[id]'?: number;
        /**
         * Only required if order[id] was provided. 'Order' should be used as value.
         */
        'order[objectName]'?: string;
    };
    url: '/OrderPos';
};

export type GetOrderPositionsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetOrderPositionsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelOrderPosResponse>;
    };
};

export type GetOrderPositionsResponse = GetOrderPositionsResponses[keyof GetOrderPositionsResponses];

export type DeleteOrderPosData = {
    body?: never;
    path: {
        /**
         * Id of order position resource to delete
         */
        orderPosId: number;
    };
    query?: never;
    url: '/OrderPos/{orderPosId}';
};

export type DeleteOrderPosErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict - f.e occurs if the order is not a draft
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteOrderPosResponses = {
    /**
     * Successful operation - order position deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteOrderPosResponse = DeleteOrderPosResponses[keyof DeleteOrderPosResponses];

export type GetOrderPositionByIdData = {
    body?: never;
    path: {
        /**
         * ID of order position to return
         */
        orderPosId: number;
    };
    query?: never;
    url: '/OrderPos/{orderPosId}';
};

export type GetOrderPositionByIdErrors = {
    /**
     * Bad request. Order position was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetOrderPositionByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelOrderPosResponse>;
    };
};

export type GetOrderPositionByIdResponse = GetOrderPositionByIdResponses[keyof GetOrderPositionByIdResponses];

export type UpdateOrderPositionData = {
    /**
     * Update data
     */
    body?: ModelOrderPosUpdateWritable;
    path: {
        /**
         * ID of order position to update
         */
        orderPosId: number;
    };
    query?: never;
    url: '/OrderPos/{orderPosId}';
};

export type UpdateOrderPositionErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateOrderPositionResponses = {
    /**
     * Successful operation - Returns changed order position resource
     */
    200: ModelOrderPosResponse;
};

export type UpdateOrderPositionResponse = UpdateOrderPositionResponses[keyof UpdateOrderPositionResponses];

export type VoucherFactorySaveVoucherData = {
    /**
     * Creation data. Please be aware, that you need to provide at least all required parameters of the voucher and voucher position model!
     */
    body?: SaveVoucherWritable;
    path?: never;
    query?: never;
    url: '/Voucher/Factory/saveVoucher';
};

export type VoucherFactorySaveVoucherErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type VoucherFactorySaveVoucherError = VoucherFactorySaveVoucherErrors[keyof VoucherFactorySaveVoucherErrors];

export type VoucherFactorySaveVoucherResponses = {
    /**
     * Created - Returns created voucher
     */
    201: SaveVoucherResponse;
};

export type VoucherFactorySaveVoucherResponse = VoucherFactorySaveVoucherResponses[keyof VoucherFactorySaveVoucherResponses];

export type VoucherUploadFileData = {
    /**
     * File to upload
     */
    body?: {
        /**
         * The file to upload
         */
        file?: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/Voucher/Factory/uploadTempFile';
};

export type VoucherUploadFileErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type VoucherUploadFileResponses = {
    /**
     * A pdf file
     */
    201: {
        objects?: {
            pages?: number;
            mimeType?: string;
            originMimeType?: string;
            filename?: string;
            contentHash?: string;
            content?: Array<unknown>;
        };
    };
};

export type VoucherUploadFileResponse = VoucherUploadFileResponses[keyof VoucherUploadFileResponses];

export type GetVouchersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Status of the vouchers to retrieve.
         */
        status?: 50 | 100 | 1000;
        /**
         * Define if you only want credit or debit vouchers.
         */
        creditDebit?: 'C' | 'D';
        /**
         * Retrieve all vouchers with a description like this.
         */
        descriptionLike?: string;
        /**
         * Retrieve all vouchers with a date equal or higher
         */
        startDate?: number;
        /**
         * Retrieve all vouchers with a date equal or lower
         */
        endDate?: number;
        /**
         * Retrieve all vouchers with this contact. Must be provided with contact[objectName]
         */
        'contact[id]'?: number;
        /**
         * Only required if contact[id] was provided. 'Contact' should be used as value.
         */
        'contact[objectName]'?: string;
    };
    url: '/Voucher';
};

export type GetVouchersErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetVouchersResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelVoucherResponse>;
    };
};

export type GetVouchersResponse = GetVouchersResponses[keyof GetVouchersResponses];

export type GetVoucherByIdData = {
    body?: never;
    path: {
        /**
         * ID of voucher to return
         */
        voucherId: number;
    };
    query?: never;
    url: '/Voucher/{voucherId}';
};

export type GetVoucherByIdErrors = {
    /**
     * Bad request. Voucher was not found
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetVoucherByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelVoucherResponse>;
    };
};

export type GetVoucherByIdResponse = GetVoucherByIdResponses[keyof GetVoucherByIdResponses];

export type UpdateVoucherData = {
    /**
     * Update data
     */
    body?: ModelVoucherUpdateWritable;
    path: {
        /**
         * ID of voucher to update
         */
        voucherId: number;
    };
    query?: never;
    url: '/Voucher/{voucherId}';
};

export type UpdateVoucherErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateVoucherResponses = {
    /**
     * Successful operation - Returns changed voucher resource
     */
    200: ModelVoucherResponse;
};

export type UpdateVoucherResponse = UpdateVoucherResponses[keyof UpdateVoucherResponses];

export type VoucherEnshrineData = {
    body?: never;
    path: {
        /**
         * ID of the voucher to enshrine
         */
        voucherId: number;
    };
    query?: never;
    url: '/Voucher/{voucherId}/enshrine';
};

export type VoucherEnshrineErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type VoucherEnshrineError = VoucherEnshrineErrors[keyof VoucherEnshrineErrors];

export type VoucherEnshrineResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: unknown;
    };
};

export type VoucherEnshrineResponse = VoucherEnshrineResponses[keyof VoucherEnshrineResponses];

export type BookVoucherData = {
    /**
     * Booking data
     */
    body?: {
        /**
         * Amount which should be booked. Can also be a partial amount.
         */
        amount: number;
        /**
         * The booking date. Most likely the current date.
         */
        date: string;
        /**
         * Define a type for the booking.<br>
         * The following type abbreviations are available (abbreviation <-> meaning).<br>
         * <ul>
         * <li>FULL_PAYMENT <-> Normal booking</li><li>N <-> Partial booking (historically used for normal booking)</li>
         * <li>CB <-> Reduced amount due to discount (skonto)</li>
         * <li>CF <-> Reduced/Higher amount due to currency fluctuations (deprecated)</li>
         * <li>O <-> Reduced/Higher amount due to other reasons</li>
         * <li>OF <-> Higher amount due to reminder charges</li>
         * <li>MTC <-> Reduced amount due to the monetary traffic costs</li>
         * </ul>
         */
        type: 'FULL_PAYMENT' | 'N' | 'CB' | 'CF' | 'O' | 'OF' | 'MTC';
        /**
         * The check account on which should be booked.
         */
        checkAccount: {
            /**
             * The id of the check account on which should be booked.
             */
            id: number;
            /**
             * Internal object name which is 'CheckAccount'.
             */
            objectName: string;
        };
        /**
         * The check account transaction on which should be booked.<br>
         * The transaction will be linked to the voucher.<br>Providing a transaction is required for online checkaccounts (like you would select an existing transaction in the UI).
         */
        checkAccountTransaction?: {
            /**
             * The id of the check account transaction on which should be booked.
             */
            id: number;
            /**
             * Internal object name which is 'CheckAccountTransaction'.
             */
            objectName: string;
        };
        /**
         * Determines if a feed is created for the booking process.
         */
        createFeed?: boolean;
    };
    path: {
        /**
         * ID of voucher to book
         */
        voucherId: number;
    };
    query?: never;
    url: '/Voucher/{voucherId}/bookAmount';
};

export type BookVoucherErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type BookVoucherResponses = {
    /**
     * Successful operation - Returns voucher log entry
     */
    200: {
        id?: string;
        objectName?: string;
        /**
         * Date of email creation
         */
        create?: string;
        voucher?: {
            /**
             * The id of the voucher
             */
            id: number;
            /**
             * Internal object name which is 'Voucher'.
             */
            objectName: string;
        };
        fromStatus?: string;
        toStatus?: string;
        amountPayed?: string;
        bookingDate?: string;
        /**
         * Client to which the voucher belongs.
         */
        sevClient?: {
            /**
             * Unique identifier of the client
             */
            id: number;
            /**
             * Model name, which is 'SevClient'
             */
            objectName: string;
        };
    };
};

export type BookVoucherResponse = BookVoucherResponses[keyof BookVoucherResponses];

export type VoucherResetToOpenData = {
    body?: never;
    path: {
        /**
         * ID of the voucher to reset
         */
        voucherId: number;
    };
    query?: never;
    url: '/Voucher/{voucherId}/resetToOpen';
};

export type VoucherResetToOpenErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type VoucherResetToOpenError = VoucherResetToOpenErrors[keyof VoucherResetToOpenErrors];

export type VoucherResetToOpenResponses = {
    /**
     * Successful operation - Returns changed voucher
     */
    200: {
        objects?: ModelVoucherResponse & {
            status?: unknown;
        };
    };
};

export type VoucherResetToOpenResponse = VoucherResetToOpenResponses[keyof VoucherResetToOpenResponses];

export type VoucherResetToDraftData = {
    body?: never;
    path: {
        /**
         * ID of the voucher to reset
         */
        voucherId: number;
    };
    query?: never;
    url: '/Voucher/{voucherId}/resetToDraft';
};

export type VoucherResetToDraftErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation error
     */
    422: ValidationError;
    /**
     * Server Error
     */
    500: unknown;
};

export type VoucherResetToDraftError = VoucherResetToDraftErrors[keyof VoucherResetToDraftErrors];

export type VoucherResetToDraftResponses = {
    /**
     * Successful operation - Returns changed voucher
     */
    200: {
        objects?: ModelVoucherResponse & {
            status?: unknown;
        };
    };
};

export type VoucherResetToDraftResponse = VoucherResetToDraftResponses[keyof VoucherResetToDraftResponses];

export type GetVoucherPositionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Retrieve all vouchers positions belonging to this voucher. Must be provided with voucher[objectName]
         */
        'voucher[id]'?: number;
        /**
         * Only required if voucher[id] was provided. 'Voucher' should be used as value.
         */
        'voucher[objectName]'?: string;
    };
    url: '/VoucherPos';
};

export type GetVoucherPositionsErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetVoucherPositionsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelVoucherPosResponse>;
    };
};

export type GetVoucherPositionsResponse = GetVoucherPositionsResponses[keyof GetVoucherPositionsResponses];

export type ForAllAccountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/ReceiptGuidance/forAllAccounts';
};

export type ForAllAccountsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ForAllAccountsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ReceiptGuideDto>;
    };
};

export type ForAllAccountsResponse = ForAllAccountsResponses[keyof ForAllAccountsResponses];

export type ForAccountNumberData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The datev account number you want to get additional information of
         */
        accountNumber: number;
    };
    url: '/ReceiptGuidance/forAccountNumber';
};

export type ForAccountNumberErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * The account you requested could not be found.
     */
    422: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ForAccountNumberResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ReceiptGuideDto>;
    };
};

export type ForAccountNumberResponse = ForAccountNumberResponses[keyof ForAccountNumberResponses];

export type ForTaxRuleData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The code of the tax rule you want to get guidance for.
         */
        taxRule: string;
    };
    url: '/ReceiptGuidance/forTaxRule';
};

export type ForTaxRuleErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * No account guides were found for the requested tax rule.
     */
    422: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ForTaxRuleResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ReceiptGuideDto>;
    };
};

export type ForTaxRuleResponse = ForTaxRuleResponses[keyof ForTaxRuleResponses];

export type ForRevenueData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/ReceiptGuidance/forRevenue';
};

export type ForRevenueErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ForRevenueResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ReceiptGuideDto>;
    };
};

export type ForRevenueResponse = ForRevenueResponses[keyof ForRevenueResponses];

export type ForExpenseData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/ReceiptGuidance/forExpense';
};

export type ForExpenseErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ForExpenseResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ReceiptGuideDto>;
    };
};

export type ForExpenseResponse = ForExpenseResponses[keyof ForExpenseResponses];

export type ReportInvoiceData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        view: string;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name which is exported
             */
            modelName: unknown;
            /**
             * SevQuery object name
             */
            objectName: unknown;
            filter?: {
                /**
                 * Type of invoices you want to export
                 * 1. RE - Rechnung
                 * 2. SR - Stornorechnung
                 * 3. TR - Teilrechnung
                 * 4. AR - Abschlagsrechnung
                 * 5. ER - Endrechnung
                 * 6. WKR - Wiederkehrende Rechnung
                 * 7. MA - Mahnung
                 */
                invoiceType?: Array<'Re' | 'SR' | 'TR' | 'AR' | 'ER' | 'WKR' | 'MA'>;
                /**
                 * Start date of the invoice
                 */
                startDate?: string;
                /**
                 * End date of the invoice
                 */
                endDate?: string;
                /**
                 * filters the invoices by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the invoices by amount
                 */
                startAmount?: number;
                /**
                 * filters the invoices by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Report/invoicelist';
};

export type ReportInvoiceErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ReportInvoiceResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ReportInvoiceResponse = ReportInvoiceResponses[keyof ReportInvoiceResponses];

export type ReportOrderData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        view: string;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name which is exported
             */
            modelName: unknown;
            /**
             * SevQuery object name
             */
            objectName: unknown;
            filter?: {
                /**
                 * Type of orders you want to export
                 * 1. AN - Angebote
                 * 2. AB - Auftrge
                 * 3. LI - Lieferscheine
                 */
                orderType?: 'AN' | 'AB' | 'LI';
                /**
                 * Start date of the order
                 */
                startDate?: string;
                /**
                 * End date of the order
                 */
                endDate?: string;
                /**
                 * filters the orders by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the orders by amount
                 */
                startAmount?: number;
                /**
                 * filters the orders by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Report/orderlist';
};

export type ReportOrderErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ReportOrderResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ReportOrderResponse = ReportOrderResponses[keyof ReportOrderResponses];

export type ReportContactData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name which is exported
             */
            modelName: unknown;
            /**
             * SevQuery object name
             */
            objectName: unknown;
            filter?: {
                /**
                 * filters the contacts by zip code
                 */
                zip?: number;
                /**
                 * filters the contacts by city
                 */
                city?: string;
                country?: {
                    /**
                     * id of the country
                     */
                    id: number;
                    /**
                     * Model name, which is 'StaticCountry'
                     */
                    objectName: string;
                };
                /**
                 * export only organisations
                 */
                depth?: boolean;
                /**
                 * export only people
                 */
                onlyPeople?: boolean;
            };
        };
    };
    url: '/Report/contactlist';
};

export type ReportContactErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ReportContactResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ReportContactResponse = ReportContactResponses[keyof ReportContactResponses];

export type ReportVoucherData = {
    body?: never;
    path?: never;
    query: {
        download?: boolean;
        sevQuery: {
            /**
             * Limit export
             */
            limit?: number;
            /**
             * Model name which is exported
             */
            modelName: unknown;
            /**
             * SevQuery object name
             */
            objectName: unknown;
            filter?: {
                /**
                 * Start date of the voucher
                 */
                startDate?: string;
                /**
                 * End date of the voucher
                 */
                endDate?: string;
                /**
                 * Start pay date of the voucher
                 */
                startPayDate?: string;
                /**
                 * End pay date of the voucher
                 */
                endPayDate?: string;
                /**
                 * filters the vouchers by contact
                 */
                contact?: {
                    /**
                     * ID of the contact
                     */
                    id: number;
                    /**
                     * Model name, which is 'Contact'
                     */
                    objectName: string;
                };
                /**
                 * filters the vouchers by amount
                 */
                startAmount?: number;
                /**
                 * filters the vouchers by amount
                 */
                endAmount?: number;
            };
        };
    };
    url: '/Report/voucherlist';
};

export type ReportVoucherErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type ReportVoucherResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: {
            filename?: string;
            mimetype?: string;
            base64Encoded?: boolean;
            content?: string;
        };
    };
};

export type ReportVoucherResponse = ReportVoucherResponses[keyof ReportVoucherResponses];

export type GetTagsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * ID of the Tag
         */
        id?: number;
        /**
         * Name of the Tag
         */
        name?: string;
    };
    url: '/Tag';
};

export type GetTagsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetTagsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelTagResponse>;
    };
};

export type GetTagsResponse = GetTagsResponses[keyof GetTagsResponses];

export type DeleteTagData = {
    body?: never;
    path: {
        /**
         * Id of tag to delete
         */
        tagId: number;
    };
    query?: never;
    url: '/Tag/{tagId}';
};

export type DeleteTagErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Conflict
     */
    409: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type DeleteTagResponses = {
    /**
     * Successful operation - tag deleted
     */
    200: {
        objects?: Array<unknown>;
    };
};

export type DeleteTagResponse = DeleteTagResponses[keyof DeleteTagResponses];

export type GetTagByIdData = {
    body?: never;
    path: {
        /**
         * ID of tag to return
         */
        tagId: number;
    };
    query?: never;
    url: '/Tag/{tagId}';
};

export type GetTagByIdErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetTagByIdResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelTagResponse>;
    };
};

export type GetTagByIdResponse = GetTagByIdResponses[keyof GetTagByIdResponses];

export type UpdateTagData = {
    body?: {
        /**
         * The name of the tag u want to update
         */
        name?: string;
    };
    path: {
        /**
         * ID of tag you want to update
         */
        tagId: number;
    };
    query?: never;
    url: '/Tag/{tagId}';
};

export type UpdateTagErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type UpdateTagResponses = {
    /**
     * Successful operation
     */
    200: ModelTagResponse;
};

export type UpdateTagResponse = UpdateTagResponses[keyof UpdateTagResponses];

export type CreateTagData = {
    body?: {
        /**
         * Name of the tag
         */
        name?: string;
        object: {
            /**
             * Id of the invoice/order/voucher/creditNote
             */
            id: number;
            /**
             * Model name
             */
            objectName: 'Invoice' | 'Voucher' | 'Order' | 'CreditNote';
        };
    };
    path?: never;
    query?: never;
    url: '/Tag/Factory/create';
};

export type CreateTagErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type CreateTagResponses = {
    /**
     * Successful operation
     */
    200: ModelTagCreateResponse;
};

export type CreateTagResponse = CreateTagResponses[keyof CreateTagResponses];

export type GetTagRelationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/TagRelation';
};

export type GetTagRelationsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Server Error
     */
    500: unknown;
};

export type GetTagRelationsResponses = {
    /**
     * Successful operation
     */
    200: {
        objects?: Array<ModelTagCreateResponse>;
    };
};

export type GetTagRelationsResponse = GetTagRelationsResponses[keyof GetTagRelationsResponses];
