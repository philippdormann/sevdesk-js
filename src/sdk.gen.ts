// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { BookCreditNoteData, BookCreditNoteErrors, BookCreditNoteResponses, BookInvoiceData, BookInvoiceErrors, BookInvoiceResponses, BookkeepingSystemVersionData, BookkeepingSystemVersionErrors, BookkeepingSystemVersionResponses, BookVoucherData, BookVoucherErrors, BookVoucherResponses, CancelInvoiceData, CancelInvoiceErrors, CancelInvoiceResponses, CheckAccountTransactionEnshrineData, CheckAccountTransactionEnshrineErrors, CheckAccountTransactionEnshrineResponses, ContactAddressIdData, ContactAddressIdErrors, ContactAddressIdResponses, ContactCustomerNumberAvailabilityCheckData, ContactCustomerNumberAvailabilityCheckErrors, ContactCustomerNumberAvailabilityCheckResponses, CreateAccountingContactData, CreateAccountingContactErrors, CreateAccountingContactResponses, CreateClearingAccountData, CreateClearingAccountErrors, CreateClearingAccountResponses, CreateCommunicationWayData, CreateCommunicationWayErrors, CreateCommunicationWayResponses, CreateContactAddressData, CreateContactAddressErrors, CreateContactAddressResponses, CreateContactData, CreateContactErrors, CreateContactFieldData, CreateContactFieldErrors, CreateContactFieldResponses, CreateContactFieldSettingData, CreateContactFieldSettingErrors, CreateContactFieldSettingResponses, CreateContactResponses, CreateContractNoteFromOrderData, CreateContractNoteFromOrderErrors, CreateContractNoteFromOrderResponses, CreatecreditNoteData, CreatecreditNoteErrors, CreateCreditNoteFromInvoiceData, CreateCreditNoteFromInvoiceErrors, CreateCreditNoteFromInvoiceResponses, CreateCreditNoteFromVoucherData, CreateCreditNoteFromVoucherErrors, CreateCreditNoteFromVoucherResponses, CreatecreditNoteResponses, CreateFileImportAccountData, CreateFileImportAccountErrors, CreateFileImportAccountResponses, CreateInvoiceByFactoryData, CreateInvoiceByFactoryErrors, CreateInvoiceByFactoryResponses, CreateInvoiceFromOrderData, CreateInvoiceFromOrderErrors, CreateInvoiceFromOrderResponses, CreateInvoiceReminderData, CreateInvoiceReminderErrors, CreateInvoiceReminderResponses, CreateOrderData, CreateOrderErrors, CreateOrderResponses, CreatePackingListFromOrderData, CreatePackingListFromOrderErrors, CreatePackingListFromOrderResponses, CreatePartData, CreatePartErrors, CreatePartResponses, CreatePrivateTransactionRuleData, CreatePrivateTransactionRuleErrors, CreatePrivateTransactionRuleResponses, CreateTagData, CreateTagErrors, CreateTagResponses, CreateTransactionData, CreateTransactionErrors, CreateTransactionResponses, CreditNoteEnshrineData, CreditNoteEnshrineErrors, CreditNoteEnshrineResponses, CreditNoteGetPdfData, CreditNoteGetPdfErrors, CreditNoteGetPdfResponses, CreditNoteResetToDraftData, CreditNoteResetToDraftErrors, CreditNoteResetToDraftResponses, CreditNoteResetToOpenData, CreditNoteResetToOpenErrors, CreditNoteResetToOpenResponses, CreditNoteSendByData, CreditNoteSendByErrors, CreditNoteSendByResponses, DeleteAccountingContactData, DeleteAccountingContactErrors, DeleteAccountingContactResponses, DeleteCheckAccountData, DeleteCheckAccountErrors, DeleteCheckAccountResponses, DeleteCheckAccountTransactionData, DeleteCheckAccountTransactionErrors, DeleteCheckAccountTransactionResponses, DeleteCommunicationWayData, DeleteCommunicationWayErrors, DeleteCommunicationWayResponses, DeleteContactAddressData, DeleteContactAddressErrors, DeleteContactAddressResponses, DeleteContactCustomFieldIdData, DeleteContactCustomFieldIdErrors, DeleteContactCustomFieldIdResponses, DeleteContactData, DeleteContactErrors, DeleteContactFieldSettingData, DeleteContactFieldSettingErrors, DeleteContactFieldSettingResponses, DeleteContactResponses, DeletecreditNoteData, DeletecreditNoteErrors, DeletecreditNoteResponses, DeleteOrderData, DeleteOrderErrors, DeleteOrderPosData, DeleteOrderPosErrors, DeleteOrderPosResponses, DeleteOrderResponses, DeletePrivateTransactionRuleData, DeletePrivateTransactionRuleErrors, DeletePrivateTransactionRuleResponses, DeleteTagData, DeleteTagErrors, DeleteTagResponses, ExportContactData, ExportContactErrors, ExportContactResponses, ExportCreditNoteData, ExportCreditNoteErrors, ExportCreditNoteResponses, ExportDatevCsvData, ExportDatevCsvErrors, ExportDatevCsvResponses, ExportDatevDepricatedData, ExportDatevDepricatedErrors, ExportDatevDepricatedResponses, ExportDatevXmlData, ExportDatevXmlErrors, ExportDatevXmlResponses, ExportInvoiceData, ExportInvoiceErrors, ExportInvoiceResponses, ExportInvoiceZipData, ExportInvoiceZipErrors, ExportInvoiceZipResponses, ExportTransactionsData, ExportTransactionsErrors, ExportTransactionsResponses, ExportVoucherData, ExportVoucherErrors, ExportVoucherResponses, ExportVoucherZipData, ExportVoucherZipErrors, ExportVoucherZipResponses, FindContactsByCustomFieldValueData, FindContactsByCustomFieldValueErrors, FindContactsByCustomFieldValueResponses, ForAccountNumberData, ForAccountNumberErrors, ForAccountNumberResponses, ForAllAccountsData, ForAllAccountsErrors, ForAllAccountsResponses, ForExpenseData, ForExpenseErrors, ForExpenseResponses, ForRevenueData, ForRevenueErrors, ForRevenueResponses, ForTaxRuleData, ForTaxRuleErrors, ForTaxRuleResponses, GenerateDownloadHashData, GenerateDownloadHashErrors, GenerateDownloadHashResponses, GetAccountingContactByIdData, GetAccountingContactByIdErrors, GetAccountingContactByIdResponses, GetAccountingContactData, GetAccountingContactErrors, GetAccountingContactResponses, GetBalanceAtDateData, GetBalanceAtDateErrors, GetBalanceAtDateResponses, GetCheckAccountByIdData, GetCheckAccountByIdErrors, GetCheckAccountByIdResponses, GetCheckAccountsData, GetCheckAccountsErrors, GetCheckAccountsResponses, GetCheckAccountTransactionByIdData, GetCheckAccountTransactionByIdErrors, GetCheckAccountTransactionByIdResponses, GetCommunicationWayByIdData, GetCommunicationWayByIdErrors, GetCommunicationWayByIdResponses, GetCommunicationWayKeysData, GetCommunicationWayKeysErrors, GetCommunicationWayKeysResponses, GetCommunicationWaysData, GetCommunicationWaysErrors, GetCommunicationWaysResponses, GetContactAddressesData, GetContactAddressesErrors, GetContactAddressesResponses, GetContactByIdData, GetContactByIdErrors, GetContactByIdResponses, GetContactFieldsByIdData, GetContactFieldsByIdErrors, GetContactFieldsByIdResponses, GetContactFieldsData, GetContactFieldsErrors, GetContactFieldSettingByIdData, GetContactFieldSettingByIdErrors, GetContactFieldSettingByIdResponses, GetContactFieldSettingsData, GetContactFieldSettingsErrors, GetContactFieldSettingsResponses, GetContactFieldsResponses, GetContactsData, GetContactsErrors, GetContactsResponses, GetContactTabsItemCountByIdData, GetContactTabsItemCountByIdErrors, GetContactTabsItemCountByIdResponses, GetcreditNoteByIdData, GetcreditNoteByIdErrors, GetcreditNoteByIdResponses, GetcreditNotePositionsData, GetcreditNotePositionsErrors, GetcreditNotePositionsResponses, GetCreditNotesData, GetCreditNotesErrors, GetCreditNotesResponses, GetDiscountsData, GetDiscountsErrors, GetDiscountsResponses, GetInvoiceByIdData, GetInvoiceByIdErrors, GetInvoiceByIdResponses, GetInvoicePosData, GetInvoicePosErrors, GetInvoicePositionsByIdData, GetInvoicePositionsByIdErrors, GetInvoicePositionsByIdResponses, GetInvoicePosResponses, GetInvoicesData, GetInvoicesErrors, GetInvoicesResponses, GetIsInvoicePartiallyPaidData, GetIsInvoicePartiallyPaidErrors, GetIsInvoicePartiallyPaidResponses, GetLetterpapersWithThumbData, GetLetterpapersWithThumbErrors, GetLetterpapersWithThumbResponses, GetNextCustomerNumberData, GetNextCustomerNumberErrors, GetNextCustomerNumberResponses, GetOrderByIdData, GetOrderByIdErrors, GetOrderByIdResponses, GetOrderPositionByIdData, GetOrderPositionByIdErrors, GetOrderPositionByIdResponses, GetOrderPositionsByIdData, GetOrderPositionsByIdErrors, GetOrderPositionsByIdResponses, GetOrderPositionsData, GetOrderPositionsErrors, GetOrderPositionsResponses, GetOrdersData, GetOrdersErrors, GetOrdersResponses, GetPartByIdData, GetPartByIdErrors, GetPartByIdResponses, GetPartsData, GetPartsErrors, GetPartsResponses, GetPlaceholderData, GetPlaceholderErrors, GetPlaceholderResponses, GetProgressData, GetProgressErrors, GetProgressResponses, GetReferenceCountData, GetReferenceCountErrors, GetReferenceCountResponses, GetRelatedObjectsData, GetRelatedObjectsErrors, GetRelatedObjectsResponses, GetTagByIdData, GetTagByIdErrors, GetTagByIdResponses, GetTagRelationsData, GetTagRelationsErrors, GetTagRelationsResponses, GetTagsData, GetTagsErrors, GetTagsResponses, GetTemplatesData, GetTemplatesErrors, GetTemplatesResponses, GetTransactionsData, GetTransactionsErrors, GetTransactionsResponses, GetVoucherByIdData, GetVoucherByIdErrors, GetVoucherByIdResponses, GetVoucherPositionsData, GetVoucherPositionsErrors, GetVoucherPositionsResponses, GetVouchersData, GetVouchersErrors, GetVouchersResponses, InvoiceEnshrineData, InvoiceEnshrineErrors, InvoiceEnshrineResponses, InvoiceGetPdfData, InvoiceGetPdfErrors, InvoiceGetPdfResponses, InvoiceGetXmlData, InvoiceGetXmlErrors, InvoiceGetXmlResponses, InvoiceRenderData, InvoiceRenderErrors, InvoiceRenderResponses, InvoiceResetToDraftData, InvoiceResetToDraftErrors, InvoiceResetToDraftResponses, InvoiceResetToOpenData, InvoiceResetToOpenErrors, InvoiceResetToOpenResponses, InvoiceSendByData, InvoiceSendByErrors, InvoiceSendByResponses, JobDownloadInfoData, JobDownloadInfoErrors, JobDownloadInfoResponses, ListPrivateTransactionRulesData, ListPrivateTransactionRulesErrors, ListPrivateTransactionRulesResponses, OrderGetPdfData, OrderGetPdfErrors, OrderGetPdfResponses, OrderSendByData, OrderSendByErrors, OrderSendByResponses, PartGetStockData, PartGetStockErrors, PartGetStockResponses, ReportContactData, ReportContactErrors, ReportContactResponses, ReportInvoiceData, ReportInvoiceErrors, ReportInvoiceResponses, ReportOrderData, ReportOrderErrors, ReportOrderResponses, ReportVoucherData, ReportVoucherErrors, ReportVoucherResponses, SendCreditNoteByPrintingData, SendCreditNoteByPrintingErrors, SendCreditNoteByPrintingResponses, SendCreditNoteViaEMailData, SendCreditNoteViaEMailErrors, SendCreditNoteViaEMailResponses, SendInvoiceViaEMailData, SendInvoiceViaEMailErrors, SendInvoiceViaEMailResponses, SendorderViaEMailData, SendorderViaEMailErrors, SendorderViaEMailResponses, UpdateAccountingContactData, UpdateAccountingContactErrors, UpdateAccountingContactResponses, UpdateCheckAccountData, UpdateCheckAccountErrors, UpdateCheckAccountResponses, UpdateCheckAccountTransactionData, UpdateCheckAccountTransactionErrors, UpdateCheckAccountTransactionResponses, UpdateCommunicationWayData, UpdateCommunicationWayErrors, UpdateCommunicationWayResponses, UpdateContactAddressData, UpdateContactAddressErrors, UpdateContactAddressResponses, UpdateContactData, UpdateContactErrors, UpdateContactfieldData, UpdateContactfieldErrors, UpdateContactfieldResponses, UpdateContactFieldSettingData, UpdateContactFieldSettingErrors, UpdateContactFieldSettingResponses, UpdateContactResponses, UpdatecreditNoteData, UpdatecreditNoteErrors, UpdatecreditNoteResponses, UpdateCreditNoteTemplateData, UpdateCreditNoteTemplateErrors, UpdateCreditNoteTemplateResponses, UpdateExportConfigData, UpdateExportConfigErrors, UpdateExportConfigResponses, UpdateInvoiceTemplateData, UpdateInvoiceTemplateErrors, UpdateInvoiceTemplateResponses, UpdateOrderData, UpdateOrderErrors, UpdateOrderPositionData, UpdateOrderPositionErrors, UpdateOrderPositionResponses, UpdateOrderResponses, UpdateOrderTemplateData, UpdateOrderTemplateErrors, UpdateOrderTemplateResponses, UpdatePartData, UpdatePartErrors, UpdatePartResponses, UpdateTagData, UpdateTagErrors, UpdateTagResponses, UpdateVoucherData, UpdateVoucherErrors, UpdateVoucherResponses, VoucherEnshrineData, VoucherEnshrineErrors, VoucherEnshrineResponses, VoucherFactorySaveVoucherData, VoucherFactorySaveVoucherErrors, VoucherFactorySaveVoucherResponses, VoucherResetToDraftData, VoucherResetToDraftErrors, VoucherResetToDraftResponses, VoucherResetToOpenData, VoucherResetToOpenErrors, VoucherResetToOpenResponses, VoucherUploadFileData, VoucherUploadFileErrors, VoucherUploadFileResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Retrieve bookkeeping system version
 *
 * To check if you already received the update to version 2.0 you can use this endpoint.
 */
export const bookkeepingSystemVersion = <ThrowOnError extends boolean = false>(options?: Options<BookkeepingSystemVersionData, ThrowOnError>) => (options?.client ?? client).get<BookkeepingSystemVersionResponses, BookkeepingSystemVersionErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Tools/bookkeepingSystemVersion',
    ...options
});

/**
 * Retrieve check accounts
 *
 * Retrieve all check accounts
 */
export const getCheckAccounts = <ThrowOnError extends boolean = false>(options?: Options<GetCheckAccountsData, ThrowOnError>) => (options?.client ?? client).get<GetCheckAccountsResponses, GetCheckAccountsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccount',
    ...options
});

/**
 * Create a new file import account
 *
 * Creates a new banking account for file imports (CSV, MT940).
 */
export const createFileImportAccount = <ThrowOnError extends boolean = false>(options?: Options<CreateFileImportAccountData, ThrowOnError>) => (options?.client ?? client).post<CreateFileImportAccountResponses, CreateFileImportAccountErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccount/Factory/fileImportAccount',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Create a new clearing account
 *
 * Creates a new clearing account.
 */
export const createClearingAccount = <ThrowOnError extends boolean = false>(options?: Options<CreateClearingAccountData, ThrowOnError>) => (options?.client ?? client).post<CreateClearingAccountResponses, CreateClearingAccountErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccount/Factory/clearingAccount',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes a check account
 */
export const deleteCheckAccount = <ThrowOnError extends boolean = false>(options: Options<DeleteCheckAccountData, ThrowOnError>) => (options.client ?? client).delete<DeleteCheckAccountResponses, DeleteCheckAccountErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccount/{checkAccountId}',
    ...options
});

/**
 * Find check account by ID
 *
 * Retrieve an existing check account
 */
export const getCheckAccountById = <ThrowOnError extends boolean = false>(options: Options<GetCheckAccountByIdData, ThrowOnError>) => (options.client ?? client).get<GetCheckAccountByIdResponses, GetCheckAccountByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccount/{checkAccountId}',
    ...options
});

/**
 * Update an existing check account
 *
 * Update a check account
 */
export const updateCheckAccount = <ThrowOnError extends boolean = false>(options: Options<UpdateCheckAccountData, ThrowOnError>) => (options.client ?? client).put<UpdateCheckAccountResponses, UpdateCheckAccountErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccount/{checkAccountId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get the balance at a given date
 *
 * Get the balance, calculated as the sum of all transactions sevdesk knows, up to and including the given date. Note that this balance does not have to be the actual bank account balance, e.g. if sevdesk did not import old transactions.
 */
export const getBalanceAtDate = <ThrowOnError extends boolean = false>(options: Options<GetBalanceAtDateData, ThrowOnError>) => (options.client ?? client).get<GetBalanceAtDateResponses, GetBalanceAtDateErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccount/{checkAccountId}/getBalanceAtDate',
    ...options
});

/**
 * Retrieve transactions
 *
 * Retrieve all transactions depending on the filters defined in the query.
 */
export const getTransactions = <ThrowOnError extends boolean = false>(options?: Options<GetTransactionsData, ThrowOnError>) => (options?.client ?? client).get<GetTransactionsResponses, GetTransactionsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccountTransaction',
    ...options
});

/**
 * Create a new transaction
 *
 * Creates a new transaction on a check account.
 */
export const createTransaction = <ThrowOnError extends boolean = false>(options?: Options<CreateTransactionData, ThrowOnError>) => (options?.client ?? client).post<CreateTransactionResponses, CreateTransactionErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccountTransaction',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes a check account transaction
 */
export const deleteCheckAccountTransaction = <ThrowOnError extends boolean = false>(options: Options<DeleteCheckAccountTransactionData, ThrowOnError>) => (options.client ?? client).delete<DeleteCheckAccountTransactionResponses, DeleteCheckAccountTransactionErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccountTransaction/{checkAccountTransactionId}',
    ...options
});

/**
 * Find check account transaction by ID
 *
 * Retrieve an existing check account transaction
 */
export const getCheckAccountTransactionById = <ThrowOnError extends boolean = false>(options: Options<GetCheckAccountTransactionByIdData, ThrowOnError>) => (options.client ?? client).get<GetCheckAccountTransactionByIdResponses, GetCheckAccountTransactionByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccountTransaction/{checkAccountTransactionId}',
    ...options
});

/**
 * Update an existing check account transaction
 *
 * Update a check account transaction
 */
export const updateCheckAccountTransaction = <ThrowOnError extends boolean = false>(options: Options<UpdateCheckAccountTransactionData, ThrowOnError>) => (options.client ?? client).put<UpdateCheckAccountTransactionResponses, UpdateCheckAccountTransactionErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccountTransaction/{checkAccountTransactionId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Enshrine
 *
 * Sets the current date and time as a value for the property `enshrined`.<br>
 * This operation is only possible if the status is "Linked" (`"status": "200"`) or higher.
 *
 * Linked invoices, credit notes or vouchers cannot be changed when the transaction is enshrined.
 *
 */
export const checkAccountTransactionEnshrine = <ThrowOnError extends boolean = false>(options: Options<CheckAccountTransactionEnshrineData, ThrowOnError>) => (options.client ?? client).put<CheckAccountTransactionEnshrineResponses, CheckAccountTransactionEnshrineErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CheckAccountTransaction/{checkAccountTransactionId}/enshrine',
    ...options
});

/**
 * List existing rules
 *
 * List all existing rules you defined for automated marking private transactions.
 */
export const listPrivateTransactionRules = <ThrowOnError extends boolean = false>(options?: Options<ListPrivateTransactionRulesData, ThrowOnError>) => (options?.client ?? client).get<ListPrivateTransactionRulesResponses, ListPrivateTransactionRulesErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/PrivateTransactionRule',
    ...options
});

/**
 * Create a new rule
 *
 * Creates a new rule for marking private transactions automatically.
 */
export const createPrivateTransactionRule = <ThrowOnError extends boolean = false>(options?: Options<CreatePrivateTransactionRuleData, ThrowOnError>) => (options?.client ?? client).post<CreatePrivateTransactionRuleResponses, CreatePrivateTransactionRuleErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/PrivateTransactionRule',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Delete the rule by id
 */
export const deletePrivateTransactionRule = <ThrowOnError extends boolean = false>(options: Options<DeletePrivateTransactionRuleData, ThrowOnError>) => (options.client ?? client).delete<DeletePrivateTransactionRuleResponses, DeletePrivateTransactionRuleErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/PrivateTransactionRule/{id}',
    ...options
});

/**
 * Get next free customer number
 *
 * Retrieves the next available customer number. Avoids duplicates.
 */
export const getNextCustomerNumber = <ThrowOnError extends boolean = false>(options?: Options<GetNextCustomerNumberData, ThrowOnError>) => (options?.client ?? client).get<GetNextCustomerNumberResponses, GetNextCustomerNumberErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact/Factory/getNextCustomerNumber',
    ...options
});

/**
 * Find contacts by custom field value
 *
 * Returns an array of contacts having a certain custom field value set.
 */
export const findContactsByCustomFieldValue = <ThrowOnError extends boolean = false>(options: Options<FindContactsByCustomFieldValueData, ThrowOnError>) => (options.client ?? client).get<FindContactsByCustomFieldValueResponses, FindContactsByCustomFieldValueErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact/Factory/findContactsByCustomFieldValue',
    ...options
});

/**
 * Check if a customer number is available
 *
 * Checks if a given customer number is available or already used.
 */
export const contactCustomerNumberAvailabilityCheck = <ThrowOnError extends boolean = false>(options?: Options<ContactCustomerNumberAvailabilityCheckData, ThrowOnError>) => (options?.client ?? client).get<ContactCustomerNumberAvailabilityCheckResponses, ContactCustomerNumberAvailabilityCheckErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact/Mapper/checkCustomerNumberAvailability',
    ...options
});

/**
 * Retrieve contacts
 *
 * There are a multitude of parameter which can be used to filter.<br>
 * A few of them are attached but
 * for a complete list please check out <a href='#tag/Contact/How-to-filter-for-certain-contacts'>this</a> list
 */
export const getContacts = <ThrowOnError extends boolean = false>(options?: Options<GetContactsData, ThrowOnError>) => (options?.client ?? client).get<GetContactsResponses, GetContactsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact',
    ...options
});

/**
 * Create a new contact
 *
 * Creates a new contact.<br>
 * For adding addresses and communication ways, you will need to use the ContactAddress and CommunicationWay endpoints.
 */
export const createContact = <ThrowOnError extends boolean = false>(options?: Options<CreateContactData, ThrowOnError>) => (options?.client ?? client).post<CreateContactResponses, CreateContactErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes a contact
 */
export const deleteContact = <ThrowOnError extends boolean = false>(options: Options<DeleteContactData, ThrowOnError>) => (options.client ?? client).delete<DeleteContactResponses, DeleteContactErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact/{contactId}',
    ...options
});

/**
 * Find contact by ID
 *
 * Returns a single contact
 */
export const getContactById = <ThrowOnError extends boolean = false>(options: Options<GetContactByIdData, ThrowOnError>) => (options.client ?? client).get<GetContactByIdResponses, GetContactByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact/{contactId}',
    ...options
});

/**
 * Update a existing contact
 *
 * Update a contact
 */
export const updateContact = <ThrowOnError extends boolean = false>(options: Options<UpdateContactData, ThrowOnError>) => (options.client ?? client).put<UpdateContactResponses, UpdateContactErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact/{contactId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get number of all items
 *
 * Get number of all invoices, orders, etc. of a specified contact
 */
export const getContactTabsItemCountById = <ThrowOnError extends boolean = false>(options: Options<GetContactTabsItemCountByIdData, ThrowOnError>) => (options.client ?? client).get<GetContactTabsItemCountByIdResponses, GetContactTabsItemCountByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Contact/{contactId}/getTabsItemCount',
    ...options
});

/**
 * Retrieve contact addresses
 *
 * Retrieve all contact addresses
 */
export const getContactAddresses = <ThrowOnError extends boolean = false>(options?: Options<GetContactAddressesData, ThrowOnError>) => (options?.client ?? client).get<GetContactAddressesResponses, GetContactAddressesErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactAddress',
    ...options
});

/**
 * Create a new contact address
 *
 * Creates a new contact address.
 */
export const createContactAddress = <ThrowOnError extends boolean = false>(options?: Options<CreateContactAddressData, ThrowOnError>) => (options?.client ?? client).post<CreateContactAddressResponses, CreateContactAddressErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactAddress',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes a contact address
 */
export const deleteContactAddress = <ThrowOnError extends boolean = false>(options: Options<DeleteContactAddressData, ThrowOnError>) => (options.client ?? client).delete<DeleteContactAddressResponses, DeleteContactAddressErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactAddress/{contactAddressId}',
    ...options
});

/**
 * Find contact address by ID
 *
 * Returns a single contact address
 */
export const contactAddressId = <ThrowOnError extends boolean = false>(options: Options<ContactAddressIdData, ThrowOnError>) => (options.client ?? client).get<ContactAddressIdResponses, ContactAddressIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactAddress/{contactAddressId}',
    ...options
});

/**
 * update a existing contact address
 *
 * update a existing contact address.
 */
export const updateContactAddress = <ThrowOnError extends boolean = false>(options: Options<UpdateContactAddressData, ThrowOnError>) => (options.client ?? client).put<UpdateContactAddressResponses, UpdateContactAddressErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactAddress/{contactAddressId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve communication ways
 *
 * Returns all communication ways which have been added up until now. Filters can be added.
 */
export const getCommunicationWays = <ThrowOnError extends boolean = false>(options?: Options<GetCommunicationWaysData, ThrowOnError>) => (options?.client ?? client).get<GetCommunicationWaysResponses, GetCommunicationWaysErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CommunicationWay',
    ...options
});

/**
 * Create a new contact communication way
 *
 * Creates a new contact communication way.
 */
export const createCommunicationWay = <ThrowOnError extends boolean = false>(options?: Options<CreateCommunicationWayData, ThrowOnError>) => (options?.client ?? client).post<CreateCommunicationWayResponses, CreateCommunicationWayErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CommunicationWay',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes a communication way
 */
export const deleteCommunicationWay = <ThrowOnError extends boolean = false>(options: Options<DeleteCommunicationWayData, ThrowOnError>) => (options.client ?? client).delete<DeleteCommunicationWayResponses, DeleteCommunicationWayErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CommunicationWay/{communicationWayId}',
    ...options
});

/**
 * Find communication way by ID
 *
 * Returns a single communication way
 */
export const getCommunicationWayById = <ThrowOnError extends boolean = false>(options: Options<GetCommunicationWayByIdData, ThrowOnError>) => (options.client ?? client).get<GetCommunicationWayByIdResponses, GetCommunicationWayByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CommunicationWay/{communicationWayId}',
    ...options
});

/**
 * Update a existing communication way
 *
 * Update a communication way
 */
export const updateCommunicationWay = <ThrowOnError extends boolean = false>(options: Options<UpdateCommunicationWayData, ThrowOnError>) => (options.client ?? client).put<UpdateCommunicationWayResponses, UpdateCommunicationWayErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CommunicationWay/{communicationWayId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve communication way keys
 *
 * Returns all communication way keys.
 */
export const getCommunicationWayKeys = <ThrowOnError extends boolean = false>(options?: Options<GetCommunicationWayKeysData, ThrowOnError>) => (options?.client ?? client).get<GetCommunicationWayKeysResponses, GetCommunicationWayKeysErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CommunicationWayKey',
    ...options
});

/**
 * Retrieve accounting contact
 *
 * Returns all accounting contact which have been added up until now. Filters can be added.
 */
export const getAccountingContact = <ThrowOnError extends boolean = false>(options?: Options<GetAccountingContactData, ThrowOnError>) => (options?.client ?? client).get<GetAccountingContactResponses, GetAccountingContactErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/AccountingContact',
    ...options
});

/**
 * Create a new accounting contact
 *
 * Creates a new accounting contact.
 */
export const createAccountingContact = <ThrowOnError extends boolean = false>(options?: Options<CreateAccountingContactData, ThrowOnError>) => (options?.client ?? client).post<CreateAccountingContactResponses, CreateAccountingContactErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/AccountingContact',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes an accounting contact
 *
 * Attention, deleting an existing AccountingContact can lead to **booking errors**, especially in the **DATEV export**.
 * Compatibility of sevdesk with DATEV is no longer guaranteed.
 */
export const deleteAccountingContact = <ThrowOnError extends boolean = false>(options: Options<DeleteAccountingContactData, ThrowOnError>) => (options.client ?? client).delete<DeleteAccountingContactResponses, DeleteAccountingContactErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/AccountingContact/{accountingContactId}',
    ...options
});

/**
 * Find accounting contact by ID
 *
 * Returns a single accounting contac
 */
export const getAccountingContactById = <ThrowOnError extends boolean = false>(options: Options<GetAccountingContactByIdData, ThrowOnError>) => (options.client ?? client).get<GetAccountingContactByIdResponses, GetAccountingContactByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/AccountingContact/{accountingContactId}',
    ...options
});

/**
 * Update an existing accounting contact
 *
 * Attention, updating an existing AccountingContact can lead to **booking errors**, especially in the **DATEV export**.
 * Compatibility of sevdesk with DATEV is no longer guaranteed.
 */
export const updateAccountingContact = <ThrowOnError extends boolean = false>(options: Options<UpdateAccountingContactData, ThrowOnError>) => (options.client ?? client).put<UpdateAccountingContactResponses, UpdateAccountingContactErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/AccountingContact/{accountingContactId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve Placeholders
 *
 * Retrieve all Placeholders
 */
export const getPlaceholder = <ThrowOnError extends boolean = false>(options: Options<GetPlaceholderData, ThrowOnError>) => (options.client ?? client).get<GetPlaceholderResponses, GetPlaceholderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Textparser/fetchDictionaryEntriesByType',
    ...options
});

/**
 * Retrieve contact fields
 *
 * Retrieve all contact fields
 */
export const getContactFields = <ThrowOnError extends boolean = false>(options?: Options<GetContactFieldsData, ThrowOnError>) => (options?.client ?? client).get<GetContactFieldsResponses, GetContactFieldsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomField',
    ...options
});

/**
 * Create contact field
 *
 * Create contact field
 */
export const createContactField = <ThrowOnError extends boolean = false>(options?: Options<CreateContactFieldData, ThrowOnError>) => (options?.client ?? client).post<CreateContactFieldResponses, CreateContactFieldErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomField',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * delete a contact field
 */
export const deleteContactCustomFieldId = <ThrowOnError extends boolean = false>(options: Options<DeleteContactCustomFieldIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteContactCustomFieldIdResponses, DeleteContactCustomFieldIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomField/{contactCustomFieldId}',
    ...options
});

/**
 * Retrieve contact fields
 *
 * Retrieve all contact fields
 */
export const getContactFieldsById = <ThrowOnError extends boolean = false>(options: Options<GetContactFieldsByIdData, ThrowOnError>) => (options.client ?? client).get<GetContactFieldsByIdResponses, GetContactFieldsByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomField/{contactCustomFieldId}',
    ...options
});

/**
 * Update a contact field
 *
 * Update a contact field
 */
export const updateContactfield = <ThrowOnError extends boolean = false>(options: Options<UpdateContactfieldData, ThrowOnError>) => (options.client ?? client).put<UpdateContactfieldResponses, UpdateContactfieldErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomField/{contactCustomFieldId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve contact field settings
 *
 * Retrieve all contact field settings
 */
export const getContactFieldSettings = <ThrowOnError extends boolean = false>(options?: Options<GetContactFieldSettingsData, ThrowOnError>) => (options?.client ?? client).get<GetContactFieldSettingsResponses, GetContactFieldSettingsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomFieldSetting',
    ...options
});

/**
 * Create contact field setting
 *
 * Create contact field setting
 */
export const createContactFieldSetting = <ThrowOnError extends boolean = false>(options?: Options<CreateContactFieldSettingData, ThrowOnError>) => (options?.client ?? client).post<CreateContactFieldSettingResponses, CreateContactFieldSettingErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomFieldSetting',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes a contact field setting
 */
export const deleteContactFieldSetting = <ThrowOnError extends boolean = false>(options: Options<DeleteContactFieldSettingData, ThrowOnError>) => (options.client ?? client).delete<DeleteContactFieldSettingResponses, DeleteContactFieldSettingErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}',
    ...options
});

/**
 * Find contact field setting by ID
 *
 * Returns a single contact field setting
 */
export const getContactFieldSettingById = <ThrowOnError extends boolean = false>(options: Options<GetContactFieldSettingByIdData, ThrowOnError>) => (options.client ?? client).get<GetContactFieldSettingByIdResponses, GetContactFieldSettingByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}',
    ...options
});

/**
 * Update contact field setting
 *
 * Update an existing contact field  setting
 */
export const updateContactFieldSetting = <ThrowOnError extends boolean = false>(options: Options<UpdateContactFieldSettingData, ThrowOnError>) => (options.client ?? client).put<UpdateContactFieldSettingResponses, UpdateContactFieldSettingErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Receive count reference
 *
 * Receive count reference
 */
export const getReferenceCount = <ThrowOnError extends boolean = false>(options: Options<GetReferenceCountData, ThrowOnError>) => (options.client ?? client).get<GetReferenceCountResponses, GetReferenceCountErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ContactCustomFieldSetting/{contactCustomFieldSettingId}/getReferenceCount',
    ...options
});

/**
 * Retrieve CreditNote
 *
 * There are a multitude of parameter which can be used to filter.
 */
export const getCreditNotes = <ThrowOnError extends boolean = false>(options?: Options<GetCreditNotesData, ThrowOnError>) => (options?.client ?? client).get<GetCreditNotesResponses, GetCreditNotesErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote',
    ...options
});

/**
 * Create a new creditNote
 *
 * The list of parameters starts with the credit note array.<br> This array contains all required attributes for a complete credit note.<br> Most of the attributes are covered in the credit note attribute list, there are only two parameters standing out, namely <b>mapAll</b> and <b>objectName</b>.<br> These are just needed for our system and you always need to provide them.<br> The list of parameters then continues with the credit note position array.<br> With this array you have the possibility to add multiple positions at once.<br> In the example it only contains one position, again together with the parameters <b>mapAll</b> and <b>objectName</b>, however, you can add more credit note positions by extending the array.<br> So if you wanted to add another position, you would add the same list of parameters with an incremented array index of "1" instead of "0".<br><br> The list ends with the five parameters creditNotePosDelete, discountSave, discountDelete, takeDefaultAddress and forCashRegister.<br> They only play a minor role if you only want to create a credit note but we will shortly explain what they can do.<br> With creditNotePosDelete you have to option to delete credit note positions as this request can also be used to update credit notes.<br> Both discount parameters are deprecated and have no use for credit notes, however they need to be provided in case you want to use the following two parameters.<br> With takeDefaultAddress you can specify that the first address of the contact you are using for the credit note is taken for the credit note address attribute automatically, so you don't need to provide the address yourself.<br> Finally, the forCashRegister parameter needs to be set to <b>true</b> if your credit note is to be booked on the cash register.<br> If you want to know more about these parameters, for example if you want to use this request to update credit notes, feel free to contact our support.<br> Finally, after covering all parameters, they only important information left, is that the order of the last five attributes always needs to be kept.<br> You will also always need to provide all of them, as otherwise the request won't work properly.
 */
export const createcreditNote = <ThrowOnError extends boolean = false>(options?: Options<CreatecreditNoteData, ThrowOnError>) => (options?.client ?? client).post<CreatecreditNoteResponses, CreatecreditNoteErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/Factory/saveCreditNote',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Creates a new creditNote from an invoice
 *
 * Use this endpoint to create a new creditNote from an invoice.
 */
export const createCreditNoteFromInvoice = <ThrowOnError extends boolean = false>(options?: Options<CreateCreditNoteFromInvoiceData, ThrowOnError>) => (options?.client ?? client).post<CreateCreditNoteFromInvoiceResponses, CreateCreditNoteFromInvoiceErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/Factory/createFromInvoice',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Creates a new creditNote from a voucher
 *
 * **Not supported with sevdesk-Update 2.0**
 *
 * Use this endpoint to create a new creditNote from a voucher.
 *
 */
export const createCreditNoteFromVoucher = <ThrowOnError extends boolean = false>(options?: Options<CreateCreditNoteFromVoucherData, ThrowOnError>) => (options?.client ?? client).post<CreateCreditNoteFromVoucherResponses, CreateCreditNoteFromVoucherErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/Factory/createFromVoucher',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes an creditNote
 */
export const deletecreditNote = <ThrowOnError extends boolean = false>(options: Options<DeletecreditNoteData, ThrowOnError>) => (options.client ?? client).delete<DeletecreditNoteResponses, DeletecreditNoteErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}',
    ...options
});

/**
 * Find creditNote by ID
 *
 * Returns a single creditNote
 */
export const getcreditNoteById = <ThrowOnError extends boolean = false>(options: Options<GetcreditNoteByIdData, ThrowOnError>) => (options.client ?? client).get<GetcreditNoteByIdResponses, GetcreditNoteByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}',
    ...options
});

/**
 * Update an existing creditNote
 *
 * Update a creditNote
 */
export const updatecreditNote = <ThrowOnError extends boolean = false>(options: Options<UpdatecreditNoteData, ThrowOnError>) => (options.client ?? client).put<UpdatecreditNoteResponses, UpdatecreditNoteErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Send credit note by printing
 *
 * Sending a credit note to end-customers is an important part of the bookkeeping process.<br> Depending on the way you want to send the credit note, you need to use different endpoints.<br> Let's start with just printing out the credit note, meaning we only need to render the pdf.
 */
export const sendCreditNoteByPrinting = <ThrowOnError extends boolean = false>(options: Options<SendCreditNoteByPrintingData, ThrowOnError>) => (options.client ?? client).get<SendCreditNoteByPrintingResponses, SendCreditNoteByPrintingErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/sendByWithRender',
    ...options
});

/**
 * Mark credit note as sent
 *
 * Marks an credit note as sent by a chosen send type.
 */
export const creditNoteSendBy = <ThrowOnError extends boolean = false>(options: Options<CreditNoteSendByData, ThrowOnError>) => (options.client ?? client).put<CreditNoteSendByResponses, CreditNoteSendByErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/sendBy',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Enshrine
 *
 * Sets the current date and time as a value for the property `enshrined`.<br>
 * This operation is only possible if the status is "Open" (`"status": "200"`) or higher.
 *
 * Enshrined credit notes cannot be changed. This operation cannot be undone.
 *
 */
export const creditNoteEnshrine = <ThrowOnError extends boolean = false>(options: Options<CreditNoteEnshrineData, ThrowOnError>) => (options.client ?? client).put<CreditNoteEnshrineResponses, CreditNoteEnshrineErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/enshrine',
    ...options
});

/**
 * Retrieve pdf document of a credit note
 *
 * Retrieves the pdf document of a credit note with additional metadata.
 */
export const creditNoteGetPdf = <ThrowOnError extends boolean = false>(options: Options<CreditNoteGetPdfData, ThrowOnError>) => (options.client ?? client).get<CreditNoteGetPdfResponses, CreditNoteGetPdfErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/getPdf',
    ...options
});

/**
 * Send credit note via email
 *
 * This endpoint sends the specified credit note to a customer via email.<br>
 * This will automatically mark the credit note as sent.<br>
 * Please note, that in production an credit note is not allowed to be changed after this happened!
 */
export const sendCreditNoteViaEMail = <ThrowOnError extends boolean = false>(options: Options<SendCreditNoteViaEMailData, ThrowOnError>) => (options.client ?? client).post<SendCreditNoteViaEMailResponses, SendCreditNoteViaEMailErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/sendViaEmail',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Book a credit note
 *
 * Booking the credit note with a transaction is probably the most important part in the bookkeeping process.<br> There are several ways on correctly booking a credit note, all by using the same endpoint.<br> Conveniently, the booking process is exactly the same as the process for invoices and vouchers.<br> For this reason, you can have a look at it in the <a href='#tag/Invoice/How-to-book-an-invoice'>invoice chapter</a> and all you need to do is to change "Invoice" into "CreditNote" in the URL.
 */
export const bookCreditNote = <ThrowOnError extends boolean = false>(options: Options<BookCreditNoteData, ThrowOnError>) => (options.client ?? client).put<BookCreditNoteResponses, BookCreditNoteErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/bookAmount',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Reset status to open
 *
 * Resets the status "Open" (`"status": "200"`). Linked transactions will be unlinked.<br>
 * This is not possible if the credit note itself or one of its transactions (CheckAccountTransaction) is already enshrined.
 *
 * This endpoint cannot be used to increase the status to "Open" (`"status": "200"`).<br>
 * Use [CreditNote/{creditNoteId}/sendBy](#tag/CreditNote/operation/creditNoteSendBy) / [CreditNote/{creditNoteId}/sendViaEmail](#tag/CreditNote/operation/sendCreditNoteViaEMail) instead.
 *
 */
export const creditNoteResetToOpen = <ThrowOnError extends boolean = false>(options: Options<CreditNoteResetToOpenData, ThrowOnError>) => (options.client ?? client).put<CreditNoteResetToOpenResponses, CreditNoteResetToOpenErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/resetToOpen',
    ...options
});

/**
 * Reset status to draft
 *
 * Resets the status to "Draft" (`"status": "100"`).<br>
 * This is only possible if the credit note has the status "Open" (`"status": "200"`).<br>
 * If it has a higher status use [CreditNote/{creditNoteId}/resetToOpen](#tag/CreditNote/operation/creditNoteResetToOpen) first.
 *
 */
export const creditNoteResetToDraft = <ThrowOnError extends boolean = false>(options: Options<CreditNoteResetToDraftData, ThrowOnError>) => (options.client ?? client).put<CreditNoteResetToDraftResponses, CreditNoteResetToDraftErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/resetToDraft',
    ...options
});

/**
 * Retrieve creditNote positions
 *
 * Retrieve all creditNote positions depending on the filters defined in the query.
 */
export const getcreditNotePositions = <ThrowOnError extends boolean = false>(options?: Options<GetcreditNotePositionsData, ThrowOnError>) => (options?.client ?? client).get<GetcreditNotePositionsResponses, GetcreditNotePositionsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNotePos',
    ...options
});

/**
 * Update export config
 *
 * Update export config to export DATEV
 */
export const updateExportConfig = <ThrowOnError extends boolean = false>(options: Options<UpdateExportConfigData, ThrowOnError>) => (options.client ?? client).put<UpdateExportConfigResponses, UpdateExportConfigErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/SevClient/{SevClientId}/updateExportConfig',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Export datev
 *
 * DATEV export as zip with CSVs. Before you can perform the DATEV export, you must first set the "accountingYearBegin". To do this, you must use the <a href='#tag/Export/operation/updateExportConfig'>updateExportConfig</a> endpoint. Please note, that this endpoint is deprecated. You should use the endpoint <a href='#tag/Export/operation/exportDatevCSV'>/Export/createDatevCsvZipExportJob</a>.
 *
 * @deprecated
 */
export const exportDatevDepricated = <ThrowOnError extends boolean = false>(options: Options<ExportDatevDepricatedData, ThrowOnError>) => (options.client ?? client).get<ExportDatevDepricatedResponses, ExportDatevDepricatedErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/datevCSV',
    ...options
});

/**
 * Start DATEV CSV ZIP export
 *
 * Start an export that generates booking data in the DATEV format (CSV)  Before you can perform the DATEV export, you first have to set the "accountingYearBegin". To do this, use the endpoint <a href='#tag/Export/operation/updateExportConfig'>updateExportConfig</a>.  After that you can use the createDatevCsvZipExportJob endpoint to start the DATEV export which returns the export ID.  You have to use the <a href='#tag/Export/operation/jobDownloadInfo'>jobDownloadInfo</a> endpoint to receive the download url when the export is ready.  <h3>Export workflow</h2> To get the DATEV CSV zip file, please implement the following workflow. <ol> <li>Set the accountingYearBegin (if not already set) via <a href='#tag/Export/operation/updateExportConfig'>updateExportConfig</a></li> <li>Start the export by using the createDatevCsvZipExportJob endpoint</li> <li>Request a progressHash with endpoint <a href='#tag/Export/operation/generateDownloadHash'>generateDownloadHash</a> (optional)</li> <li>Use the progressHash to receive export progress information with endpoint <a href='#tag/Export/operation/getProgress'>getProgress</a> (optional)</li> <li>Use the <a href='#tag/Export/operation/jobDownloadInfo'>jobDownloadInfo</a> endpoint to get the download url to the zip file.</li> </ol>
 */
export const exportDatevCsv = <ThrowOnError extends boolean = false>(options: Options<ExportDatevCsvData, ThrowOnError>) => (options.client ?? client).get<ExportDatevCsvResponses, ExportDatevCsvErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/createDatevCsvZipExportJob',
    ...options
});

/**
 * Start DATEV XML ZIP export
 *
 * Start an export that generates invoice data in the DATEV format (XML)  Before you can perform the DATEV export, you first have to set the "accountingYearBegin". To do this, use the endpoint <a href='#tag/Export/operation/updateExportConfig'>updateExportConfig</a>.   After that you can use the createDatevXmlZipExportJob endpoint to start the DATEV export which returns the export ID.  You have to use the <a href='#tag/Export/operation/jobDownloadInfo'>jobDownloadInfo</a> endpoint to receive the download url when the export is ready.  <h3>Export workflow</h2> To get the DATEV XML zip file, please implement the following workflow. <ol> <li>Set the accountingYearBegin (if not already set) via <a href='#tag/Export/operation/updateExportConfig'>updateExportConfig</a></li> <li>Start the export by using the createDatevXmlZipExportJob endpoint</li> <li>Request a progressHash with endpoint <a href='#tag/Export/operation/generateDownloadHash'>generateDownloadHash</a> (optional)</li> <li>Use the progressHash to receive export progress information with endpoint <a href='#tag/Export/operation/getProgress'>getProgress</a> (optional)</li> <li>Use the <a href='#tag/Export/operation/jobDownloadInfo'>jobDownloadInfo</a> endpoint to get the download url to the zip file.</li> </ol>
 */
export const exportDatevXml = <ThrowOnError extends boolean = false>(options: Options<ExportDatevXmlData, ThrowOnError>) => (options.client ?? client).get<ExportDatevXmlResponses, ExportDatevXmlErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/createDatevXmlZipExportJob',
    ...options
});

/**
 * Generate download hash
 *
 * Generates an identifier to request the current export progress.
 */
export const generateDownloadHash = <ThrowOnError extends boolean = false>(options: Options<GenerateDownloadHashData, ThrowOnError>) => (options.client ?? client).get<GenerateDownloadHashResponses, GenerateDownloadHashErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Progress/generateDownloadHash',
    ...options
});

/**
 * Get progress
 *
 * Get the progress state of the export. You can use polling (request every few seconds) to get the current state.
 */
export const getProgress = <ThrowOnError extends boolean = false>(options: Options<GetProgressData, ThrowOnError>) => (options.client ?? client).get<GetProgressResponses, GetProgressErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Progress/getProgress',
    ...options
});

/**
 * Get job download info
 *
 * When the export job has finished you can call this endpoint to get the download url.
 */
export const jobDownloadInfo = <ThrowOnError extends boolean = false>(options: Options<JobDownloadInfoData, ThrowOnError>) => (options.client ?? client).get<JobDownloadInfoResponses, JobDownloadInfoErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ExportJob/jobDownloadInfo',
    ...options
});

/**
 * Export invoice
 *
 * Export all invoices as csv
 */
export const exportInvoice = <ThrowOnError extends boolean = false>(options: Options<ExportInvoiceData, ThrowOnError>) => (options.client ?? client).get<ExportInvoiceResponses, ExportInvoiceErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/invoiceCsv',
    ...options
});

/**
 * Export Invoice as zip
 *
 * Export all invoices as zip
 */
export const exportInvoiceZip = <ThrowOnError extends boolean = false>(options: Options<ExportInvoiceZipData, ThrowOnError>) => (options.client ?? client).get<ExportInvoiceZipResponses, ExportInvoiceZipErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/invoiceZip',
    ...options
});

/**
 * Export creditNote
 *
 * Export all credit notes as csv
 */
export const exportCreditNote = <ThrowOnError extends boolean = false>(options: Options<ExportCreditNoteData, ThrowOnError>) => (options.client ?? client).get<ExportCreditNoteResponses, ExportCreditNoteErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/creditNoteCsv',
    ...options
});

/**
 * Export voucher as zip
 *
 * Export all vouchers as zip
 */
export const exportVoucher = <ThrowOnError extends boolean = false>(options: Options<ExportVoucherData, ThrowOnError>) => (options.client ?? client).get<ExportVoucherResponses, ExportVoucherErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/voucherListCsv',
    ...options
});

/**
 * Export transaction
 *
 * Export all transactions as csv
 */
export const exportTransactions = <ThrowOnError extends boolean = false>(options: Options<ExportTransactionsData, ThrowOnError>) => (options.client ?? client).get<ExportTransactionsResponses, ExportTransactionsErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/transactionsCsv',
    ...options
});

/**
 * Export voucher zip
 *
 * export all vouchers as zip
 */
export const exportVoucherZip = <ThrowOnError extends boolean = false>(options: Options<ExportVoucherZipData, ThrowOnError>) => (options.client ?? client).get<ExportVoucherZipResponses, ExportVoucherZipErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/voucherZip',
    ...options
});

/**
 * Export contact
 *
 * Contact export as csv
 */
export const exportContact = <ThrowOnError extends boolean = false>(options: Options<ExportContactData, ThrowOnError>) => (options.client ?? client).get<ExportContactResponses, ExportContactErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Export/contactListCsv',
    ...options
});

/**
 * Retrieve parts
 *
 * Retrieve all parts in your sevdesk inventory according to the applied filters.
 */
export const getParts = <ThrowOnError extends boolean = false>(options?: Options<GetPartsData, ThrowOnError>) => (options?.client ?? client).get<GetPartsResponses, GetPartsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Part',
    ...options
});

/**
 * Create a new part
 *
 * Creates a part in your sevdesk inventory.
 */
export const createPart = <ThrowOnError extends boolean = false>(options?: Options<CreatePartData, ThrowOnError>) => (options?.client ?? client).post<CreatePartResponses, CreatePartErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Part',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Find part by ID
 *
 * Returns a single part
 */
export const getPartById = <ThrowOnError extends boolean = false>(options: Options<GetPartByIdData, ThrowOnError>) => (options.client ?? client).get<GetPartByIdResponses, GetPartByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Part/{partId}',
    ...options
});

/**
 * Update an existing part
 *
 * Update a part
 */
export const updatePart = <ThrowOnError extends boolean = false>(options: Options<UpdatePartData, ThrowOnError>) => (options.client ?? client).put<UpdatePartResponses, UpdatePartErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Part/{partId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get stock of a part
 *
 * Returns the current stock amount of the given part.
 */
export const partGetStock = <ThrowOnError extends boolean = false>(options: Options<PartGetStockData, ThrowOnError>) => (options.client ?? client).get<PartGetStockResponses, PartGetStockErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Part/{partId}/getStock',
    ...options
});

/**
 * Retrieve invoices
 *
 * There are a multitude of parameter which can be used to filter. A few of them are attached but
 * for a complete list please check out <a href='#tag/Invoice/How-to-filter-for-certain-invoices'>this</a> list
 */
export const getInvoices = <ThrowOnError extends boolean = false>(options?: Options<GetInvoicesData, ThrowOnError>) => (options?.client ?? client).get<GetInvoicesResponses, GetInvoicesErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice',
    ...options
});

/**
 * Create a new invoice
 *
 * This endpoint offers you the following functionality.
 * <ul>
 * <li>Create invoices together with positions and discounts</li>
 * <li>Delete positions while adding new ones</li>
 * <li>Delete or add discounts, or both at the same time</li>
 * <li>Automatically fill the address of the supplied contact into the invoice address</li>
 * </ul>
 * To make your own request sample slimmer, you can omit all parameters which are not required and nullable.
 * However, for a valid and logical bookkeeping document, you will also need some of them to ensure that all the necessary data is in the invoice.<br><br> The list of parameters starts with the invoice array.<br> This array contains all required attributes for a complete invoice.<br> Most of the attributes are covered in the invoice attribute list, there are only two parameters standing out, namely <b>mapAll</b> and <b>objectName</b>.<br> These are just needed for our system and you always need to provide them.<br><br> The list of parameters then continues with the invoice position array.<br> With this array you have the possibility to add multiple positions at once.<br> In the example it only contains one position, again together with the parameters <b>mapAll</b> and <b>objectName</b>, however, you can add more invoice positions by extending the array.<br> So if you wanted to add another position, you would add the same list of parameters with an incremented array index of "1" instead of "0".<br><br> The list ends with the four parameters invoicePosDelete, discountSave, discountDelete and takeDefaultAddress.<br> They only play a minor role if you only want to create an invoice but we will shortly explain what they can do.<br> With invoicePosDelete you have to option to delete invoice positions as this request can also be used to update invoices.<br> With discountSave you can add discounts to your invoice.<br> With discountDelete you can delete discounts from your invoice.<br> With takeDefaultAddress you can specify that the first address of the contact you are using for the invoice is taken for the invoice address attribute automatically, so you don't need to provide the address yourself.<br> If you want to know more about these parameters, for example if you want to use this request to update invoices, feel free to contact our support.<br><br> Finally, after covering all parameters, they only important information left, is that the order of the last four attributes always needs to be kept.<br> You will also always need to provide all of them, as otherwise the request won't work properly.<br><br> <b>Warning:</b> You can not create a regular invoice with the <b>deliveryDate</b> being later than the <b>invoiceDate</b>.<br> To do that you will need to create a so called <b>Abschlagsrechnung</b> by setting the <b>invoiceType</b> parameter to <b>AR</b>.
 */
export const createInvoiceByFactory = <ThrowOnError extends boolean = false>(options?: Options<CreateInvoiceByFactoryData, ThrowOnError>) => (options?.client ?? client).post<CreateInvoiceByFactoryResponses, CreateInvoiceByFactoryErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/Factory/saveInvoice',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Find invoice by ID
 *
 * Returns a single invoice
 */
export const getInvoiceById = <ThrowOnError extends boolean = false>(options: Options<GetInvoiceByIdData, ThrowOnError>) => (options.client ?? client).get<GetInvoiceByIdResponses, GetInvoiceByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}',
    ...options
});

/**
 * Find invoice positions
 *
 * Returns all positions of an invoice
 */
export const getInvoicePositionsById = <ThrowOnError extends boolean = false>(options: Options<GetInvoicePositionsByIdData, ThrowOnError>) => (options.client ?? client).get<GetInvoicePositionsByIdResponses, GetInvoicePositionsByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/getPositions',
    ...options
});

/**
 * Create invoice from order
 *
 * Create an invoice from an order
 */
export const createInvoiceFromOrder = <ThrowOnError extends boolean = false>(options?: Options<CreateInvoiceFromOrderData, ThrowOnError>) => (options?.client ?? client).post<CreateInvoiceFromOrderResponses, CreateInvoiceFromOrderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/Factory/createInvoiceFromOrder',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Create invoice reminder
 *
 * Create an reminder from an invoice
 */
export const createInvoiceReminder = <ThrowOnError extends boolean = false>(options: Options<CreateInvoiceReminderData, ThrowOnError>) => (options.client ?? client).post<CreateInvoiceReminderResponses, CreateInvoiceReminderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/Factory/createInvoiceReminder',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Check if an invoice is already partially paid
 *
 * Returns 'true' if the given invoice is partially paid - 'false' if it is not.
 * Invoices which are completely paid are regarded as not partially paid.
 */
export const getIsInvoicePartiallyPaid = <ThrowOnError extends boolean = false>(options: Options<GetIsInvoicePartiallyPaidData, ThrowOnError>) => (options.client ?? client).get<GetIsInvoicePartiallyPaidResponses, GetIsInvoicePartiallyPaidErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/getIsPartiallyPaid',
    ...options
});

/**
 * Cancel an invoice / Create cancellation invoice
 *
 * This endpoint will cancel the specified invoice therefor creating a cancellation invoice.<br>
 * The cancellation invoice will be automatically paid and the source invoices status will change to 'cancelled'.
 */
export const cancelInvoice = <ThrowOnError extends boolean = false>(options: Options<CancelInvoiceData, ThrowOnError>) => (options.client ?? client).post<CancelInvoiceResponses, CancelInvoiceErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/cancelInvoice',
    ...options
});

/**
 * Render the pdf document of an invoice
 *
 * Using this endpoint you can render the pdf document of an invoice.<br>
 * Use cases for this are the retrieval of the pdf location or the forceful re-render of a already sent invoice.<br>
 * Please be aware that changing an invoice after it has been sent to a customer is not an allowed bookkeeping process.
 */
export const invoiceRender = <ThrowOnError extends boolean = false>(options: Options<InvoiceRenderData, ThrowOnError>) => (options.client ?? client).post<InvoiceRenderResponses, InvoiceRenderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/render',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Send invoice via email
 *
 * This endpoint sends the specified invoice to a customer via email.<br>
 * This will automatically mark the invoice as sent.<br>
 * Please note, that in production an invoice is not allowed to be changed after this happened!
 */
export const sendInvoiceViaEMail = <ThrowOnError extends boolean = false>(options: Options<SendInvoiceViaEMailData, ThrowOnError>) => (options.client ?? client).post<SendInvoiceViaEMailResponses, SendInvoiceViaEMailErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/sendViaEmail',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve pdf document of an invoice
 *
 * Retrieves the pdf document of an invoice with additional metadata.
 */
export const invoiceGetPdf = <ThrowOnError extends boolean = false>(options: Options<InvoiceGetPdfData, ThrowOnError>) => (options.client ?? client).get<InvoiceGetPdfResponses, InvoiceGetPdfErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/getPdf',
    ...options
});

/**
 * Retrieve XML of an e-invoice
 *
 * Retrieves the XML of an e-invoice
 */
export const invoiceGetXml = <ThrowOnError extends boolean = false>(options: Options<InvoiceGetXmlData, ThrowOnError>) => (options.client ?? client).get<InvoiceGetXmlResponses, InvoiceGetXmlErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/getXml',
    ...options
});

/**
 * Mark invoice as sent
 *
 * Marks an invoice as sent by a chosen send type.
 */
export const invoiceSendBy = <ThrowOnError extends boolean = false>(options: Options<InvoiceSendByData, ThrowOnError>) => (options.client ?? client).put<InvoiceSendByResponses, InvoiceSendByErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/sendBy',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Enshrine
 *
 * Sets the current date and time as a value for the property `enshrined`.<br>
 * This operation is only possible if the status is "Open" (`"status": "200"`) or higher.
 *
 * Enshrined invoices cannot be changed. This operation cannot be undone.
 *
 */
export const invoiceEnshrine = <ThrowOnError extends boolean = false>(options: Options<InvoiceEnshrineData, ThrowOnError>) => (options.client ?? client).put<InvoiceEnshrineResponses, InvoiceEnshrineErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/enshrine',
    ...options
});

/**
 * Book an invoice
 *
 * Booking the invoice with a transaction is probably the most important part in the bookkeeping process.<br> There are several ways on correctly booking an invoice, all by using the same endpoint.<br> for more information look <a href='#tag/Invoice/How-to-book-an-invoice'>here</a>.
 */
export const bookInvoice = <ThrowOnError extends boolean = false>(options: Options<BookInvoiceData, ThrowOnError>) => (options.client ?? client).put<BookInvoiceResponses, BookInvoiceErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/bookAmount',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Reset status to open
 *
 * Resets the status "Open" (`"status": "200"`). Linked transactions will be unlinked.<br>
 * This is not possible if the invoice itself or one of its transactions (CheckAccountTransaction) is already enshrined.
 *
 * This endpoint cannot be used to increase the status to "Open" (`"status": "200"`).<br>
 * Use [Invoice/{invoiceId}/sendBy](#tag/Invoice/operation/invoiceSendBy) / [Invoice/{invoiceId}/sendViaEmail](#tag/Invoice/operation/sendInvoiceViaEMail) instead.
 *
 * This endpoint cannot be used for recurring invoices (`"invoiceType": "WKR"`).
 * Use [Invoice/Factory/saveInvoice](#tag/Invoice/operation/createInvoiceByFactory) instead.
 *
 */
export const invoiceResetToOpen = <ThrowOnError extends boolean = false>(options: Options<InvoiceResetToOpenData, ThrowOnError>) => (options.client ?? client).put<InvoiceResetToOpenResponses, InvoiceResetToOpenErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/resetToOpen',
    ...options
});

/**
 * Reset status to draft
 *
 * Resets the status to "Draft" (`"status": "100"`).<br>
 * This is only possible if the invoice has the status "Open" (`"status": "200"`).<br>
 * If it has a higher status use [Invoice/{invoiceId}/resetToOpen](#tag/Invoice/operation/invoiceResetToOpen) first.
 *
 * This endpoint cannot be used for recurring invoices (`"invoiceType": "WKR"`).<br>
 * Use [Invoice/Factory/saveInvoice](#tag/Invoice/operation/createInvoiceByFactory) instead.
 *
 */
export const invoiceResetToDraft = <ThrowOnError extends boolean = false>(options: Options<InvoiceResetToDraftData, ThrowOnError>) => (options.client ?? client).put<InvoiceResetToDraftResponses, InvoiceResetToDraftErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/resetToDraft',
    ...options
});

/**
 * Retrieve InvoicePos
 *
 * There are a multitude of parameter which can be used to filter.
 */
export const getInvoicePos = <ThrowOnError extends boolean = false>(options?: Options<GetInvoicePosData, ThrowOnError>) => (options?.client ?? client).get<GetInvoicePosResponses, GetInvoicePosErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/InvoicePos',
    ...options
});

/**
 * Retrieve letterpapers
 *
 * Retrieve all letterpapers with Thumb
 */
export const getLetterpapersWithThumb = <ThrowOnError extends boolean = false>(options?: Options<GetLetterpapersWithThumbData, ThrowOnError>) => (options?.client ?? client).get<GetLetterpapersWithThumbResponses, GetLetterpapersWithThumbErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/DocServer/getLetterpapersWithThumb',
    ...options
});

/**
 * Retrieve templates
 *
 * Retrieve all templates
 */
export const getTemplates = <ThrowOnError extends boolean = false>(options?: Options<GetTemplatesData, ThrowOnError>) => (options?.client ?? client).get<GetTemplatesResponses, GetTemplatesErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/DocServer/getTemplatesWithThumb',
    ...options
});

/**
 * Update an invoice template
 *
 * Update an existing invoice template
 */
export const updateInvoiceTemplate = <ThrowOnError extends boolean = false>(options: Options<UpdateInvoiceTemplateData, ThrowOnError>) => (options.client ?? client).put<UpdateInvoiceTemplateResponses, UpdateInvoiceTemplateErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Invoice/{invoiceId}/changeParameter',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update an order template
 *
 * Update an existing order template
 */
export const updateOrderTemplate = <ThrowOnError extends boolean = false>(options: Options<UpdateOrderTemplateData, ThrowOnError>) => (options.client ?? client).put<UpdateOrderTemplateResponses, UpdateOrderTemplateErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}/changeParameter',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update an of credit note template
 *
 * Update an existing of credit note template
 */
export const updateCreditNoteTemplate = <ThrowOnError extends boolean = false>(options: Options<UpdateCreditNoteTemplateData, ThrowOnError>) => (options.client ?? client).put<UpdateCreditNoteTemplateResponses, UpdateCreditNoteTemplateErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/CreditNote/{creditNoteId}/changeParameter',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve orders
 *
 * There are a multitude of parameter which can be used to filter. A few of them are attached but
 * for a complete list please check out <a href='#tag/Order/How-to-filter-for-certain-orders'>this</a> list
 */
export const getOrders = <ThrowOnError extends boolean = false>(options?: Options<GetOrdersData, ThrowOnError>) => (options?.client ?? client).get<GetOrdersResponses, GetOrdersErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order',
    ...options
});

/**
 * Create a new order
 *
 * Creates an order to which positions can be added later.
 */
export const createOrder = <ThrowOnError extends boolean = false>(options?: Options<CreateOrderData, ThrowOnError>) => (options?.client ?? client).post<CreateOrderResponses, CreateOrderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/Factory/saveOrder',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Deletes an order
 */
export const deleteOrder = <ThrowOnError extends boolean = false>(options: Options<DeleteOrderData, ThrowOnError>) => (options.client ?? client).delete<DeleteOrderResponses, DeleteOrderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}',
    ...options
});

/**
 * Find order by ID
 *
 * Returns a single order
 */
export const getOrderById = <ThrowOnError extends boolean = false>(options: Options<GetOrderByIdData, ThrowOnError>) => (options.client ?? client).get<GetOrderByIdResponses, GetOrderByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}',
    ...options
});

/**
 * Update an existing order
 *
 * Update an order
 */
export const updateOrder = <ThrowOnError extends boolean = false>(options: Options<UpdateOrderData, ThrowOnError>) => (options.client ?? client).put<UpdateOrderResponses, UpdateOrderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Find order positions
 *
 * Returns all positions of an order
 */
export const getOrderPositionsById = <ThrowOnError extends boolean = false>(options: Options<GetOrderPositionsByIdData, ThrowOnError>) => (options.client ?? client).get<GetOrderPositionsByIdResponses, GetOrderPositionsByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}/getPositions',
    ...options
});

/**
 * Find order discounts
 *
 * Returns all discounts of an order
 */
export const getDiscounts = <ThrowOnError extends boolean = false>(options: Options<GetDiscountsData, ThrowOnError>) => (options.client ?? client).get<GetDiscountsResponses, GetDiscountsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}/getDiscounts',
    ...options
});

/**
 * Find related objects
 *
 * Get related objects of a specified order
 */
export const getRelatedObjects = <ThrowOnError extends boolean = false>(options: Options<GetRelatedObjectsData, ThrowOnError>) => (options.client ?? client).get<GetRelatedObjectsResponses, GetRelatedObjectsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}/getRelatedObjects',
    ...options
});

/**
 * Send order via email
 *
 * This endpoint sends the specified order to a customer via email.<br>
 * This will automatically mark the order as sent.<br>
 * Please note, that in production an order is not allowed to be changed after this happened!
 */
export const sendorderViaEMail = <ThrowOnError extends boolean = false>(options: Options<SendorderViaEMailData, ThrowOnError>) => (options.client ?? client).post<SendorderViaEMailResponses, SendorderViaEMailErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}/sendViaEmail',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create packing list from order
 *
 * Create packing list from order
 */
export const createPackingListFromOrder = <ThrowOnError extends boolean = false>(options: Options<CreatePackingListFromOrderData, ThrowOnError>) => (options.client ?? client).post<CreatePackingListFromOrderResponses, CreatePackingListFromOrderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/Factory/createPackingListFromOrder',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create contract note from order
 *
 * Create contract note from order
 */
export const createContractNoteFromOrder = <ThrowOnError extends boolean = false>(options: Options<CreateContractNoteFromOrderData, ThrowOnError>) => (options.client ?? client).post<CreateContractNoteFromOrderResponses, CreateContractNoteFromOrderErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/Factory/createContractNoteFromOrder',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve pdf document of an order
 *
 * Retrieves the pdf document of an order with additional metadata and commit the order.
 */
export const orderGetPdf = <ThrowOnError extends boolean = false>(options: Options<OrderGetPdfData, ThrowOnError>) => (options.client ?? client).get<OrderGetPdfResponses, OrderGetPdfErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}/getPdf',
    ...options
});

/**
 * Mark order as sent
 *
 * Marks an order as sent by a chosen send type.
 */
export const orderSendBy = <ThrowOnError extends boolean = false>(options: Options<OrderSendByData, ThrowOnError>) => (options.client ?? client).put<OrderSendByResponses, OrderSendByErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Order/{orderId}/sendBy',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Retrieve order positions
 *
 * Retrieve all order positions depending on the filters defined in the query.
 */
export const getOrderPositions = <ThrowOnError extends boolean = false>(options?: Options<GetOrderPositionsData, ThrowOnError>) => (options?.client ?? client).get<GetOrderPositionsResponses, GetOrderPositionsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/OrderPos',
    ...options
});

/**
 * Deletes an order Position
 */
export const deleteOrderPos = <ThrowOnError extends boolean = false>(options: Options<DeleteOrderPosData, ThrowOnError>) => (options.client ?? client).delete<DeleteOrderPosResponses, DeleteOrderPosErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/OrderPos/{orderPosId}',
    ...options
});

/**
 * Find order position by ID
 *
 * Returns a single order position
 */
export const getOrderPositionById = <ThrowOnError extends boolean = false>(options: Options<GetOrderPositionByIdData, ThrowOnError>) => (options.client ?? client).get<GetOrderPositionByIdResponses, GetOrderPositionByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/OrderPos/{orderPosId}',
    ...options
});

/**
 * Update an existing order position
 *
 * Update an order position
 */
export const updateOrderPosition = <ThrowOnError extends boolean = false>(options: Options<UpdateOrderPositionData, ThrowOnError>) => (options.client ?? client).put<UpdateOrderPositionResponses, UpdateOrderPositionErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/OrderPos/{orderPosId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create a new voucher
 *
 * Bundles the creation or updating of voucher and voucher position.<br> The list of parameters starts with the voucher model.<br> This contains all required attributes for a complete voucher.<br> Most of the attributes are covered in the voucher attribute list, there are only two parameters standing out, namely <b>mapAll</b> and <b>objectName</b>.<br> These are just needed for our system and you always need to provide them.<br><br> The list of parameters then continues with the voucher position array.<br> With this array you have the possibility to add multiple positions at once.<br> In the example it only contains one position, again together with the parameters <b>mapAll</b> and <b>objectName</b>, however, you can add more voucher positions by extending the array.<br> So if you wanted to add another position, you would add the same list of parameters with an incremented array index of \"1\" instead of \"0\".<br><br> The list ends with the two parameters voucherPosDelete and filename.<br> We will shortly explain what they can do.<br> With voucherPosDelete you can delete voucher positions as this request can also be used to update draft vouchers.<br> With filename you can attach a file to the voucher.<br> For most of our customers this is a really important step, as they need to digitize their receipts.<br> Finally, after covering all parameters, the only important information left, is that the order of the last two attributes always needs to be kept. <br><br> The only valid status values for this endpoint are 50 (draft) and 100 (open). You can only update draft vouchers. If you have to, you can downgrade the status by calling resetToOpen (from paid) and resetToDraft (from open).
 */
export const voucherFactorySaveVoucher = <ThrowOnError extends boolean = false>(options?: Options<VoucherFactorySaveVoucherData, ThrowOnError>) => (options?.client ?? client).post<VoucherFactorySaveVoucherResponses, VoucherFactorySaveVoucherErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/Factory/saveVoucher',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Upload voucher file
 *
 * To attach a document to a voucher, you will need to upload it first for later use.<br> To do this, you can use this request.<br> When you successfully uploaded the file, you will get a sevdesk internal filename in the response.<br> The filename will be a hash generated from your uploaded file. You will need it in the next request!<br> After you got the just mentioned filename, you can enter it as a value for the filename parameter of the saveVoucher request.<br> If you provided all necessary parameters and kept all of them in the right order, the file will be attached to your voucher.
 */
export const voucherUploadFile = <ThrowOnError extends boolean = false>(options?: Options<VoucherUploadFileData, ThrowOnError>) => (options?.client ?? client).post<VoucherUploadFileResponses, VoucherUploadFileErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/Factory/uploadTempFile',
    ...options,
    headers: {
        'Content-Type': 'form-data',
        ...options?.headers
    }
});

/**
 * Retrieve vouchers
 *
 * There are a multitude of parameter which can be used to filter. A few of them are attached but
 * for a complete list please check out <a href='#tag/Voucher/How-to-filter-for-certain-vouchers'>this</a> list
 */
export const getVouchers = <ThrowOnError extends boolean = false>(options?: Options<GetVouchersData, ThrowOnError>) => (options?.client ?? client).get<GetVouchersResponses, GetVouchersErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher',
    ...options
});

/**
 * Find voucher by ID
 *
 * Returns a single voucher
 */
export const getVoucherById = <ThrowOnError extends boolean = false>(options: Options<GetVoucherByIdData, ThrowOnError>) => (options.client ?? client).get<GetVoucherByIdResponses, GetVoucherByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/{voucherId}',
    ...options
});

/**
 * Update an existing voucher
 *
 * Update a draft voucher using this method if you want to change simple values like the description. Complex changes like adding a position should use /Voucher/Factory/saveVoucher.<br> You can not change the status using this endpoint.
 */
export const updateVoucher = <ThrowOnError extends boolean = false>(options: Options<UpdateVoucherData, ThrowOnError>) => (options.client ?? client).put<UpdateVoucherResponses, UpdateVoucherErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/{voucherId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Enshrine
 *
 * Sets the current date and time as a value for the property `enshrined`.<br>
 * This operation is only possible if the status is "Open" (`"status": "100"`) or higher.
 *
 * Enshrined vouchers cannot be changed. This operation cannot be undone.
 *
 */
export const voucherEnshrine = <ThrowOnError extends boolean = false>(options: Options<VoucherEnshrineData, ThrowOnError>) => (options.client ?? client).put<VoucherEnshrineResponses, VoucherEnshrineErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/{voucherId}/enshrine',
    ...options
});

/**
 * Book a voucher
 *
 * Booking the voucher with a transaction is probably the most important part in the bookkeeping process.<br> There are several ways on correctly booking a voucher, all by using the same endpoint.<br> Conveniently, the booking process is exactly the same as the process for invoices.<br> For this reason, you can have a look at it <a href='#tag/Invoice/How-to-book-an-invoice'>here</a> and all you need to do is to change "Invoice" into "Voucher" in the URL.
 */
export const bookVoucher = <ThrowOnError extends boolean = false>(options: Options<BookVoucherData, ThrowOnError>) => (options.client ?? client).put<BookVoucherResponses, BookVoucherErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/{voucherId}/bookAmount',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Reset status to open
 *
 * Resets the status to "Open" (`"status": "100"`). Linked payments will be unlinked. Created asset depreciation will be reset.<br>
 * This is not possible if the voucher is already enshrined!
 *
 * This endpoint can not be used to increase the status from "Draft" to "Open".<br>
 * You can only change the status from higher to lower ("Open" to "Draft").<br>
 * To change to higher status use [Voucher/{voucherId}/bookAmount](#tag/Voucher/operation/bookVoucher).
 * To change to lower status use [Voucher/{voucherId}/resetToDraft](#tag/Voucher/operation/voucherResetToDraft).
 *
 */
export const voucherResetToOpen = <ThrowOnError extends boolean = false>(options: Options<VoucherResetToOpenData, ThrowOnError>) => (options.client ?? client).put<VoucherResetToOpenResponses, VoucherResetToOpenErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/{voucherId}/resetToOpen',
    ...options
});

/**
 * Reset status to draft
 *
 * Resets the status "Draft" (`"status": "50"`). Linked payments will be unlinked. Created asset depreciation will be reset.<br>
 * This is not possible if the voucher is already enshrined!
 *
 * You can only change the status from higher to lower ("Open" to "Draft").<br>
 * To change to higher status use [/Voucher/Factory/saveVoucher](#tag/Voucher/operation/voucherFactorySaveVoucher).
 *
 */
export const voucherResetToDraft = <ThrowOnError extends boolean = false>(options: Options<VoucherResetToDraftData, ThrowOnError>) => (options.client ?? client).put<VoucherResetToDraftResponses, VoucherResetToDraftErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Voucher/{voucherId}/resetToDraft',
    ...options
});

/**
 * Retrieve voucher positions
 *
 * Retrieve all voucher positions depending on the filters defined in the query.
 */
export const getVoucherPositions = <ThrowOnError extends boolean = false>(options?: Options<GetVoucherPositionsData, ThrowOnError>) => (options?.client ?? client).get<GetVoucherPositionsResponses, GetVoucherPositionsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/VoucherPos',
    ...options
});

/**
 * Get all account guides
 *
 * You can use this endpoint to help you decide which accounts you can use when creating a voucher
 */
export const forAllAccounts = <ThrowOnError extends boolean = false>(options?: Options<ForAllAccountsData, ThrowOnError>) => (options?.client ?? client).get<ForAllAccountsResponses, ForAllAccountsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ReceiptGuidance/forAllAccounts',
    ...options
});

/**
 * Get guidance by account number
 *
 * You can use this endpoint to get additional information about the account that you may want to use.
 */
export const forAccountNumber = <ThrowOnError extends boolean = false>(options: Options<ForAccountNumberData, ThrowOnError>) => (options.client ?? client).get<ForAccountNumberResponses, ForAccountNumberErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ReceiptGuidance/forAccountNumber',
    ...options
});

/**
 * Get guidance by Tax Rule
 *
 * You can use this endpoint to get additional information about the tax rule (for example, USTPFL_UMS_EINN) that you may want to use.
 */
export const forTaxRule = <ThrowOnError extends boolean = false>(options: Options<ForTaxRuleData, ThrowOnError>) => (options.client ?? client).get<ForTaxRuleResponses, ForTaxRuleErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ReceiptGuidance/forTaxRule',
    ...options
});

/**
 * Get guidance for revenue accounts
 *
 * Provides all possible combinations for revenue accounts to be used with revenue receipts/vouchers.
 */
export const forRevenue = <ThrowOnError extends boolean = false>(options?: Options<ForRevenueData, ThrowOnError>) => (options?.client ?? client).get<ForRevenueResponses, ForRevenueErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ReceiptGuidance/forRevenue',
    ...options
});

/**
 * Get guidance for expense accounts
 *
 * Provides all possible combinations for expense accounts to be used with expense receipts/vouchers.
 */
export const forExpense = <ThrowOnError extends boolean = false>(options?: Options<ForExpenseData, ThrowOnError>) => (options?.client ?? client).get<ForExpenseResponses, ForExpenseErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/ReceiptGuidance/forExpense',
    ...options
});

/**
 * Export invoice list
 *
 * Export invoice list
 */
export const reportInvoice = <ThrowOnError extends boolean = false>(options: Options<ReportInvoiceData, ThrowOnError>) => (options.client ?? client).get<ReportInvoiceResponses, ReportInvoiceErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Report/invoicelist',
    ...options
});

/**
 * Export order list
 *
 * Export order list
 */
export const reportOrder = <ThrowOnError extends boolean = false>(options: Options<ReportOrderData, ThrowOnError>) => (options.client ?? client).get<ReportOrderResponses, ReportOrderErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Report/orderlist',
    ...options
});

/**
 * Export contact list
 *
 * Export contact list
 */
export const reportContact = <ThrowOnError extends boolean = false>(options: Options<ReportContactData, ThrowOnError>) => (options.client ?? client).get<ReportContactResponses, ReportContactErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Report/contactlist',
    ...options
});

/**
 * Export voucher list
 *
 * Export voucher list
 */
export const reportVoucher = <ThrowOnError extends boolean = false>(options: Options<ReportVoucherData, ThrowOnError>) => (options.client ?? client).get<ReportVoucherResponses, ReportVoucherErrors, ThrowOnError>({
    querySerializer: { parameters: { sevQuery: { object: { style: 'form' } } } },
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Report/voucherlist',
    ...options
});

/**
 * Retrieve tags
 *
 * Retrieve all tags
 */
export const getTags = <ThrowOnError extends boolean = false>(options?: Options<GetTagsData, ThrowOnError>) => (options?.client ?? client).get<GetTagsResponses, GetTagsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Tag',
    ...options
});

/**
 * Deletes a tag
 */
export const deleteTag = <ThrowOnError extends boolean = false>(options: Options<DeleteTagData, ThrowOnError>) => (options.client ?? client).delete<DeleteTagResponses, DeleteTagErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Tag/{tagId}',
    ...options
});

/**
 * Find tag by ID
 *
 * Returns a single tag
 */
export const getTagById = <ThrowOnError extends boolean = false>(options: Options<GetTagByIdData, ThrowOnError>) => (options.client ?? client).get<GetTagByIdResponses, GetTagByIdErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Tag/{tagId}',
    ...options
});

/**
 * Update tag
 *
 * Update an existing tag
 */
export const updateTag = <ThrowOnError extends boolean = false>(options: Options<UpdateTagData, ThrowOnError>) => (options.client ?? client).put<UpdateTagResponses, UpdateTagErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Tag/{tagId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create a new tag
 *
 * Create a new tag
 */
export const createTag = <ThrowOnError extends boolean = false>(options?: Options<CreateTagData, ThrowOnError>) => (options?.client ?? client).post<CreateTagResponses, CreateTagErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/Tag/Factory/create',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options?.headers
    }
});

/**
 * Retrieve tag relations
 *
 * Retrieve all tag relations
 */
export const getTagRelations = <ThrowOnError extends boolean = false>(options?: Options<GetTagRelationsData, ThrowOnError>) => (options?.client ?? client).get<GetTagRelationsResponses, GetTagRelationsErrors, ThrowOnError>({
    security: [{ name: 'Authorization', type: 'apiKey' }],
    url: '/TagRelation',
    ...options
});
